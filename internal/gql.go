// Code generated by gqlclientgen - DO NOT EDIT.

package re

import (
	"context"
	"encoding/json"
	"fmt"
	gqlclient "git.sr.ht/~emersion/gqlclient"
)

// Autogenerated input type of AbortQueuedMigrations
type AbortQueuedMigrationsInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the organization that is running the migrations.
	OwnerId string `json:"ownerId"`
}

// Autogenerated return type of AbortQueuedMigrations.
type AbortQueuedMigrationsPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Did the operation succeed?
	Success *bool `json:"success,omitempty"`
}

// Autogenerated input type of AbortRepositoryMigration
type AbortRepositoryMigrationInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the migration to be aborted.
	MigrationId string `json:"migrationId"`
}

// Autogenerated return type of AbortRepositoryMigration.
type AbortRepositoryMigrationPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Did the operation succeed?
	Success *bool `json:"success,omitempty"`
}

// Autogenerated input type of AcceptEnterpriseAdministratorInvitation
type AcceptEnterpriseAdministratorInvitationInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The id of the invitation being accepted
	InvitationId string `json:"invitationId"`
}

// Autogenerated return type of AcceptEnterpriseAdministratorInvitation.
type AcceptEnterpriseAdministratorInvitationPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The invitation that was accepted.
	Invitation *EnterpriseAdministratorInvitation `json:"invitation,omitempty"`
	// A message confirming the result of accepting an administrator invitation.
	Message *string `json:"message,omitempty"`
}

// Autogenerated input type of AcceptEnterpriseMemberInvitation
type AcceptEnterpriseMemberInvitationInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The id of the invitation being accepted
	InvitationId string `json:"invitationId"`
}

// Autogenerated return type of AcceptEnterpriseMemberInvitation.
type AcceptEnterpriseMemberInvitationPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The invitation that was accepted.
	Invitation *EnterpriseMemberInvitation `json:"invitation,omitempty"`
	// A message confirming the result of accepting an unaffiliated member invitation.
	Message *string `json:"message,omitempty"`
}

// Autogenerated input type of AcceptTopicSuggestion
type AcceptTopicSuggestionInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The name of the suggested topic.
	//
	// **Upcoming Change on 2024-04-01 UTC**
	// **Description:** `name` will be removed.
	// **Reason:** Suggested topics are no longer supported
	Name *string `json:"name,omitempty"`
	// The Node ID of the repository.
	//
	// **Upcoming Change on 2024-04-01 UTC**
	// **Description:** `repositoryId` will be removed.
	// **Reason:** Suggested topics are no longer supported
	RepositoryId string `json:"repositoryId,omitempty"`
}

// Autogenerated return type of AcceptTopicSuggestion.
type AcceptTopicSuggestionPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The accepted topic.
	Topic *Topic `json:"topic,omitempty"`
}

// Autogenerated input type of AccessUserNamespaceRepository
type AccessUserNamespaceRepositoryInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the enterprise owning the user namespace repository.
	EnterpriseId string `json:"enterpriseId"`
	// The ID of the user namespace repository to access.
	RepositoryId string `json:"repositoryId"`
}

// Autogenerated return type of AccessUserNamespaceRepository.
type AccessUserNamespaceRepositoryPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The time that repository access expires at
	ExpiresAt *DateTime `json:"expiresAt,omitempty"`
	// The repository that is temporarily accessible.
	Repository *Repository `json:"repository,omitempty"`
}

// Represents an object which can take actions on GitHub. Typically a User or Bot.
type Actor struct {
	// A URL pointing to the actor's public avatar.
	AvatarUrl URI `json:"avatarUrl"`
	// The username of the actor.
	Login string `json:"login"`
	// The HTTP path for this actor.
	ResourcePath URI `json:"resourcePath"`
	// The HTTP URL for this actor.
	Url URI `json:"url"`

	// Underlying value of the GraphQL interface
	Value ActorValue `json:"-"`
}

func (base *Actor) UnmarshalJSON(b []byte) error {
	type Raw Actor
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Bot":
		base.Value = new(Bot)
	case "EnterpriseUserAccount":
		base.Value = new(EnterpriseUserAccount)
	case "Mannequin":
		base.Value = new(Mannequin)
	case "Organization":
		base.Value = new(Organization)
	case "User":
		base.Value = new(User)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface Actor: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// ActorValue is one of: Bot | EnterpriseUserAccount | Mannequin | Organization | User
type ActorValue interface {
	isActor()
}

// The connection type for Actor.
type ActorConnection struct {
	// A list of edges.
	Edges []*ActorEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*Actor `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type ActorEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *Actor `json:"node,omitempty"`
}

// Location information for an actor
type ActorLocation struct {
	// City
	City *string `json:"city,omitempty"`
	// Country name
	Country *string `json:"country,omitempty"`
	// Country code
	CountryCode *string `json:"countryCode,omitempty"`
	// Region name
	Region *string `json:"region,omitempty"`
	// Region or state code
	RegionCode *string `json:"regionCode,omitempty"`
}

// The actor's type.
type ActorType string

const (
	// Indicates a team actor.
	ActorTypeTeam ActorType = "TEAM"
	// Indicates a user actor.
	ActorTypeUser ActorType = "USER"
)

// Autogenerated input type of AddAssigneesToAssignable
type AddAssigneesToAssignableInput struct {
	// The id of the assignable object to add assignees to.
	AssignableId string `json:"assignableId"`
	// The id of users to add as assignees.
	AssigneeIds []string `json:"assigneeIds"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
}

// Autogenerated return type of AddAssigneesToAssignable.
type AddAssigneesToAssignablePayload struct {
	// The item that was assigned.
	Assignable *Assignable `json:"assignable,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
}

// Autogenerated input type of AddComment
type AddCommentInput struct {
	// The contents of the comment.
	Body string `json:"body"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Node ID of the subject to modify.
	SubjectId string `json:"subjectId"`
}

// Autogenerated return type of AddComment.
type AddCommentPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The edge from the subject's comment connection.
	CommentEdge *IssueCommentEdge `json:"commentEdge,omitempty"`
	// The subject
	Subject *Node `json:"subject,omitempty"`
	// The edge from the subject's timeline connection.
	TimelineEdge *IssueTimelineItemEdge `json:"timelineEdge,omitempty"`
}

// Autogenerated input type of AddDiscussionComment
type AddDiscussionCommentInput struct {
	// The contents of the comment.
	Body string `json:"body"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Node ID of the discussion to comment on.
	DiscussionId string `json:"discussionId"`
	// The Node ID of the discussion comment within this discussion to reply to.
	ReplyToId string `json:"replyToId,omitempty"`
}

// Autogenerated return type of AddDiscussionComment.
type AddDiscussionCommentPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The newly created discussion comment.
	Comment *DiscussionComment `json:"comment,omitempty"`
}

// Autogenerated input type of AddDiscussionPollVote
type AddDiscussionPollVoteInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Node ID of the discussion poll option to vote for.
	PollOptionId string `json:"pollOptionId"`
}

// Autogenerated return type of AddDiscussionPollVote.
type AddDiscussionPollVotePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The poll option that a vote was added to.
	PollOption *DiscussionPollOption `json:"pollOption,omitempty"`
}

// Autogenerated input type of AddEnterpriseOrganizationMember
type AddEnterpriseOrganizationMemberInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the enterprise which owns the organization.
	EnterpriseId string `json:"enterpriseId"`
	// The ID of the organization the users will be added to.
	OrganizationId string `json:"organizationId"`
	// The role to assign the users in the organization
	Role *OrganizationMemberRole `json:"role,omitempty"`
	// The IDs of the enterprise members to add.
	UserIds []string `json:"userIds"`
}

// Autogenerated return type of AddEnterpriseOrganizationMember.
type AddEnterpriseOrganizationMemberPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The users who were added to the organization.
	Users []User `json:"users,omitempty"`
}

// Autogenerated input type of AddEnterpriseSupportEntitlement
type AddEnterpriseSupportEntitlementInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the Enterprise which the admin belongs to.
	EnterpriseId string `json:"enterpriseId"`
	// The login of a member who will receive the support entitlement.
	Login string `json:"login"`
}

// Autogenerated return type of AddEnterpriseSupportEntitlement.
type AddEnterpriseSupportEntitlementPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// A message confirming the result of adding the support entitlement.
	Message *string `json:"message,omitempty"`
}

// Autogenerated input type of AddLabelsToLabelable
type AddLabelsToLabelableInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ids of the labels to add.
	LabelIds []string `json:"labelIds"`
	// The id of the labelable object to add labels to.
	LabelableId string `json:"labelableId"`
}

// Autogenerated return type of AddLabelsToLabelable.
type AddLabelsToLabelablePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The item that was labeled.
	Labelable *Labelable `json:"labelable,omitempty"`
}

// Autogenerated input type of AddProjectCard
type AddProjectCardInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The content of the card. Must be a member of the ProjectCardItem union
	ContentId string `json:"contentId,omitempty"`
	// The note on the card.
	Note *string `json:"note,omitempty"`
	// The Node ID of the ProjectColumn.
	ProjectColumnId string `json:"projectColumnId"`
}

// Autogenerated return type of AddProjectCard.
type AddProjectCardPayload struct {
	// The edge from the ProjectColumn's card connection.
	CardEdge *ProjectCardEdge `json:"cardEdge,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ProjectColumn
	ProjectColumn *ProjectColumn `json:"projectColumn,omitempty"`
}

// Autogenerated input type of AddProjectColumn
type AddProjectColumnInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The name of the column.
	Name string `json:"name"`
	// The Node ID of the project.
	ProjectId string `json:"projectId"`
}

// Autogenerated return type of AddProjectColumn.
type AddProjectColumnPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The edge from the project's column connection.
	ColumnEdge *ProjectColumnEdge `json:"columnEdge,omitempty"`
	// The project
	Project *Project `json:"project,omitempty"`
}

// Autogenerated input type of AddProjectV2DraftIssue
type AddProjectV2DraftIssueInput struct {
	// The IDs of the assignees of the draft issue.
	AssigneeIds []string `json:"assigneeIds,omitempty"`
	// The body of the draft issue.
	Body *string `json:"body,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the Project to add the draft issue to.
	ProjectId string `json:"projectId"`
	// The title of the draft issue. A project item can also be created by providing
	// the URL of an Issue or Pull Request if you have access.
	Title string `json:"title"`
}

// Autogenerated return type of AddProjectV2DraftIssue.
type AddProjectV2DraftIssuePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The draft issue added to the project.
	ProjectItem *ProjectV2Item `json:"projectItem,omitempty"`
}

// Autogenerated input type of AddProjectV2ItemById
type AddProjectV2ItemByIdInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The id of the Issue or Pull Request to add.
	ContentId string `json:"contentId"`
	// The ID of the Project to add the item to.
	ProjectId string `json:"projectId"`
}

// Autogenerated return type of AddProjectV2ItemById.
type AddProjectV2ItemByIdPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The item added to the project.
	Item *ProjectV2Item `json:"item,omitempty"`
}

// Autogenerated input type of AddPullRequestReviewComment
type AddPullRequestReviewCommentInput struct {
	// The text of the comment. This field is required
	//
	// **Upcoming Change on 2023-10-01 UTC**
	// **Description:** `body` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
	// **Reason:** We are deprecating the addPullRequestReviewComment mutation
	Body *string `json:"body,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The SHA of the commit to comment on.
	//
	// **Upcoming Change on 2023-10-01 UTC**
	// **Description:** `commitOID` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
	// **Reason:** We are deprecating the addPullRequestReviewComment mutation
	CommitOID *GitObjectID `json:"commitOID,omitempty"`
	// The comment id to reply to.
	//
	// **Upcoming Change on 2023-10-01 UTC**
	// **Description:** `inReplyTo` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
	// **Reason:** We are deprecating the addPullRequestReviewComment mutation
	InReplyTo string `json:"inReplyTo,omitempty"`
	// The relative path of the file to comment on.
	//
	// **Upcoming Change on 2023-10-01 UTC**
	// **Description:** `path` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
	// **Reason:** We are deprecating the addPullRequestReviewComment mutation
	Path *string `json:"path,omitempty"`
	// The line index in the diff to comment on.
	//
	// **Upcoming Change on 2023-10-01 UTC**
	// **Description:** `position` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
	// **Reason:** We are deprecating the addPullRequestReviewComment mutation
	Position *int32 `json:"position,omitempty"`
	// The node ID of the pull request reviewing
	//
	// **Upcoming Change on 2023-10-01 UTC**
	// **Description:** `pullRequestId` will be removed. use
	// addPullRequestReviewThread or addPullRequestReviewThreadReply instead
	// **Reason:** We are deprecating the addPullRequestReviewComment mutation
	PullRequestId string `json:"pullRequestId,omitempty"`
	// The Node ID of the review to modify.
	//
	// **Upcoming Change on 2023-10-01 UTC**
	// **Description:** `pullRequestReviewId` will be removed. use
	// addPullRequestReviewThread or addPullRequestReviewThreadReply instead
	// **Reason:** We are deprecating the addPullRequestReviewComment mutation
	PullRequestReviewId string `json:"pullRequestReviewId,omitempty"`
}

// Autogenerated return type of AddPullRequestReviewComment.
type AddPullRequestReviewCommentPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The newly created comment.
	Comment *PullRequestReviewComment `json:"comment,omitempty"`
	// The edge from the review's comment connection.
	CommentEdge *PullRequestReviewCommentEdge `json:"commentEdge,omitempty"`
}

// Autogenerated input type of AddPullRequestReview
type AddPullRequestReviewInput struct {
	// The contents of the review body comment.
	Body *string `json:"body,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The review line comments.
	//
	// **Upcoming Change on 2023-10-01 UTC**
	// **Description:** `comments` will be removed. use the `threads` argument instead
	// **Reason:** We are deprecating comment fields that use diff-relative positioning
	Comments []*DraftPullRequestReviewComment `json:"comments,omitempty"`
	// The commit OID the review pertains to.
	CommitOID *GitObjectID `json:"commitOID,omitempty"`
	// The event to perform on the pull request review.
	Event *PullRequestReviewEvent `json:"event,omitempty"`
	// The Node ID of the pull request to modify.
	PullRequestId string `json:"pullRequestId"`
	// The review line comment threads.
	Threads []*DraftPullRequestReviewThread `json:"threads,omitempty"`
}

// Autogenerated return type of AddPullRequestReview.
type AddPullRequestReviewPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The newly created pull request review.
	PullRequestReview *PullRequestReview `json:"pullRequestReview,omitempty"`
	// The edge from the pull request's review connection.
	ReviewEdge *PullRequestReviewEdge `json:"reviewEdge,omitempty"`
}

// Autogenerated input type of AddPullRequestReviewThread
type AddPullRequestReviewThreadInput struct {
	// Body of the thread's first comment.
	Body string `json:"body"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The line of the blob to which the thread refers, required for line-level
	// threads. The end of the line range for multi-line comments.
	Line *int32 `json:"line,omitempty"`
	// Path to the file being commented on.
	Path string `json:"path"`
	// The node ID of the pull request reviewing
	PullRequestId string `json:"pullRequestId,omitempty"`
	// The Node ID of the review to modify.
	PullRequestReviewId string `json:"pullRequestReviewId,omitempty"`
	// The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range.
	Side *DiffSide `json:"side,omitempty"`
	// The first line of the range to which the comment refers.
	StartLine *int32 `json:"startLine,omitempty"`
	// The side of the diff on which the start line resides.
	StartSide *DiffSide `json:"startSide,omitempty"`
	// The level at which the comments in the corresponding thread are targeted, can be a diff line or a file
	SubjectType *PullRequestReviewThreadSubjectType `json:"subjectType,omitempty"`
}

// Autogenerated return type of AddPullRequestReviewThread.
type AddPullRequestReviewThreadPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The newly created thread.
	Thread *PullRequestReviewThread `json:"thread,omitempty"`
}

// Autogenerated input type of AddPullRequestReviewThreadReply
type AddPullRequestReviewThreadReplyInput struct {
	// The text of the reply.
	Body string `json:"body"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Node ID of the pending review to which the reply will belong.
	PullRequestReviewId string `json:"pullRequestReviewId,omitempty"`
	// The Node ID of the thread to which this reply is being written.
	PullRequestReviewThreadId string `json:"pullRequestReviewThreadId"`
}

// Autogenerated return type of AddPullRequestReviewThreadReply.
type AddPullRequestReviewThreadReplyPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The newly created reply.
	Comment *PullRequestReviewComment `json:"comment,omitempty"`
}

// Autogenerated input type of AddReaction
type AddReactionInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The name of the emoji to react with.
	Content ReactionContent `json:"content"`
	// The Node ID of the subject to modify.
	SubjectId string `json:"subjectId"`
}

// Autogenerated return type of AddReaction.
type AddReactionPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The reaction object.
	Reaction *Reaction `json:"reaction,omitempty"`
	// The reaction groups for the subject.
	ReactionGroups []ReactionGroup `json:"reactionGroups,omitempty"`
	// The reactable subject.
	Subject *Reactable `json:"subject,omitempty"`
}

// Autogenerated input type of AddStar
type AddStarInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Starrable ID to star.
	StarrableId string `json:"starrableId"`
}

// Autogenerated return type of AddStar.
type AddStarPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The starrable.
	Starrable *Starrable `json:"starrable,omitempty"`
}

// Autogenerated input type of AddSubIssue
type AddSubIssueInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The id of the issue.
	IssueId string `json:"issueId"`
	// Option to replace parent issue if one already exists
	ReplaceParent *bool `json:"replaceParent,omitempty"`
	// The id of the sub-issue.
	SubIssueId string `json:"subIssueId,omitempty"`
	// The url of the sub-issue.
	SubIssueUrl *string `json:"subIssueUrl,omitempty"`
}

// Autogenerated return type of AddSubIssue.
type AddSubIssuePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The parent issue that the sub-issue was added to.
	Issue *Issue `json:"issue,omitempty"`
	// The sub-issue of the parent.
	SubIssue *Issue `json:"subIssue,omitempty"`
}

// Autogenerated input type of AddUpvote
type AddUpvoteInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Node ID of the discussion or comment to upvote.
	SubjectId string `json:"subjectId"`
}

// Autogenerated return type of AddUpvote.
type AddUpvotePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The votable subject.
	Subject *Votable `json:"subject,omitempty"`
}

// Autogenerated input type of AddVerifiableDomain
type AddVerifiableDomainInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The URL of the domain
	Domain URI `json:"domain"`
	// The ID of the owner to add the domain to
	OwnerId string `json:"ownerId"`
}

// Autogenerated return type of AddVerifiableDomain.
type AddVerifiableDomainPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The verifiable domain that was added.
	Domain *VerifiableDomain `json:"domain,omitempty"`
}

// Represents an 'added_to_merge_queue' event on a given pull request.
type AddedToMergeQueueEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The user who added this Pull Request to the merge queue
	Enqueuer *User `json:"enqueuer,omitempty"`
	// The Node ID of the AddedToMergeQueueEvent object
	Id string `json:"id"`
	// The merge queue where this pull request was added to.
	MergeQueue *MergeQueue `json:"mergeQueue,omitempty"`
	// PullRequest referenced by event.
	PullRequest *PullRequest `json:"pullRequest,omitempty"`
}

func (*AddedToMergeQueueEvent) isNode() {}

func (*AddedToMergeQueueEvent) isPullRequestTimelineItems() {}

// Represents a 'added_to_project' event on a given issue or pull request.
type AddedToProjectEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The Node ID of the AddedToProjectEvent object
	Id string `json:"id"`
	// Project referenced by event.
	Project *Project `json:"project,omitempty"`
	// Project card referenced by this project event.
	ProjectCard *ProjectCard `json:"projectCard,omitempty"`
	// Column name referenced by this project event.
	ProjectColumnName string `json:"projectColumnName"`
}

func (*AddedToProjectEvent) isNode() {}

func (*AddedToProjectEvent) isIssueTimelineItems() {}

func (*AddedToProjectEvent) isPullRequestTimelineItems() {}

// An announcement banner for an enterprise or organization.
type AnnouncementBanner struct {
	// The date the announcement was created
	CreatedAt DateTime `json:"createdAt"`
	// The expiration date of the announcement, if any
	ExpiresAt *DateTime `json:"expiresAt,omitempty"`
	// Whether the announcement can be dismissed by the user
	IsUserDismissible bool `json:"isUserDismissible"`
	// The text of the announcement
	Message *string `json:"message,omitempty"`
}

// A GitHub App.
type App struct {
	// The client ID of the app.
	ClientId *string `json:"clientId,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The description of the app.
	Description *string `json:"description,omitempty"`
	// The Node ID of the App object
	Id string `json:"id"`
	// The IP addresses of the app.
	IpAllowListEntries *IpAllowListEntryConnection `json:"ipAllowListEntries"`
	// The hex color code, without the leading '#', for the logo background.
	LogoBackgroundColor string `json:"logoBackgroundColor"`
	// A URL pointing to the app's logo.
	LogoUrl URI `json:"logoUrl"`
	// The name of the app.
	Name string `json:"name"`
	// A slug based on the name of the app for use in URLs.
	Slug string `json:"slug"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The URL to the app's homepage.
	Url URI `json:"url"`
}

func (*App) isNode() {}

func (*App) isBranchActorAllowanceActor() {}

func (*App) isBypassActor() {}

func (*App) isIpAllowListOwner() {}

func (*App) isPushAllowanceActor() {}

func (*App) isReviewDismissalAllowanceActor() {}

func (*App) isSearchResultItem() {}

// Autogenerated input type of ApproveDeployments
type ApproveDeploymentsInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Optional comment for approving deployments
	Comment *string `json:"comment,omitempty"`
	// The ids of environments to reject deployments
	EnvironmentIds []string `json:"environmentIds"`
	// The node ID of the workflow run containing the pending deployments.
	WorkflowRunId string `json:"workflowRunId"`
}

// Autogenerated return type of ApproveDeployments.
type ApproveDeploymentsPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The affected deployments.
	Deployments []Deployment `json:"deployments,omitempty"`
}

// Autogenerated input type of ApproveVerifiableDomain
type ApproveVerifiableDomainInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the verifiable domain to approve.
	Id string `json:"id"`
}

// Autogenerated return type of ApproveVerifiableDomain.
type ApproveVerifiableDomainPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The verifiable domain that was approved.
	Domain *VerifiableDomain `json:"domain,omitempty"`
}

// Autogenerated input type of ArchiveProjectV2Item
type ArchiveProjectV2ItemInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the ProjectV2Item to archive.
	ItemId string `json:"itemId"`
	// The ID of the Project to archive the item from.
	ProjectId string `json:"projectId"`
}

// Autogenerated return type of ArchiveProjectV2Item.
type ArchiveProjectV2ItemPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The item archived from the project.
	Item *ProjectV2Item `json:"item,omitempty"`
}

// Autogenerated input type of ArchiveRepository
type ArchiveRepositoryInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the repository to mark as archived.
	RepositoryId string `json:"repositoryId"`
}

// Autogenerated return type of ArchiveRepository.
type ArchiveRepositoryPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The repository that was marked as archived.
	Repository *Repository `json:"repository,omitempty"`
}

// An object that can have users assigned to it.
type Assignable struct {
	// A list of actors assigned to this object.
	AssignedActors *AssigneeConnection `json:"assignedActors"`
	// A list of Users assigned to this object.
	Assignees *UserConnection `json:"assignees"`
	// A list of suggested actors to assign to this object
	SuggestedActors *AssigneeConnection `json:"suggestedActors"`

	// Underlying value of the GraphQL interface
	Value AssignableValue `json:"-"`
}

func (base *Assignable) UnmarshalJSON(b []byte) error {
	type Raw Assignable
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Issue":
		base.Value = new(Issue)
	case "PullRequest":
		base.Value = new(PullRequest)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface Assignable: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// AssignableValue is one of: Issue | PullRequest
type AssignableValue interface {
	isAssignable()
}

// Represents an 'assigned' event on any assignable object.
type AssignedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the assignable associated with the event.
	Assignable *Assignable `json:"assignable"`
	// Identifies the user or mannequin that was assigned.
	Assignee *Assignee `json:"assignee,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the AssignedEvent object
	Id string `json:"id"`
	// Identifies the user who was assigned.
	User *User `json:"user,omitempty"`
}

func (*AssignedEvent) isNode() {}

func (*AssignedEvent) isIssueTimelineItem() {}

func (*AssignedEvent) isIssueTimelineItems() {}

func (*AssignedEvent) isPullRequestTimelineItem() {}

func (*AssignedEvent) isPullRequestTimelineItems() {}

// Types that can be assigned to issues.
type Assignee struct {
	// Underlying value of the GraphQL union
	Value AssigneeValue `json:"-"`
}

func (base *Assignee) UnmarshalJSON(b []byte) error {
	type Raw Assignee
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Bot":
		base.Value = new(Bot)
	case "Mannequin":
		base.Value = new(Mannequin)
	case "Organization":
		base.Value = new(Organization)
	case "User":
		base.Value = new(User)
	case "":
		return fmt.Errorf("gqlclient: union Assignee: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union Assignee: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// AssigneeValue is one of: Bot | Mannequin | Organization | User
type AssigneeValue interface {
	isAssignee()
}

// The connection type for Assignee.
type AssigneeConnection struct {
	// A list of edges.
	Edges []*AssigneeEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*Assignee `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type AssigneeEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *Assignee `json:"node,omitempty"`
}

// An entry in the audit log.
type AuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`

	// Underlying value of the GraphQL interface
	Value AuditEntryValue `json:"-"`
}

func (base *AuditEntry) UnmarshalJSON(b []byte) error {
	type Raw AuditEntry
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "MembersCanDeleteReposClearAuditEntry":
		base.Value = new(MembersCanDeleteReposClearAuditEntry)
	case "MembersCanDeleteReposDisableAuditEntry":
		base.Value = new(MembersCanDeleteReposDisableAuditEntry)
	case "MembersCanDeleteReposEnableAuditEntry":
		base.Value = new(MembersCanDeleteReposEnableAuditEntry)
	case "OauthApplicationCreateAuditEntry":
		base.Value = new(OauthApplicationCreateAuditEntry)
	case "OrgAddBillingManagerAuditEntry":
		base.Value = new(OrgAddBillingManagerAuditEntry)
	case "OrgAddMemberAuditEntry":
		base.Value = new(OrgAddMemberAuditEntry)
	case "OrgBlockUserAuditEntry":
		base.Value = new(OrgBlockUserAuditEntry)
	case "OrgConfigDisableCollaboratorsOnlyAuditEntry":
		base.Value = new(OrgConfigDisableCollaboratorsOnlyAuditEntry)
	case "OrgConfigEnableCollaboratorsOnlyAuditEntry":
		base.Value = new(OrgConfigEnableCollaboratorsOnlyAuditEntry)
	case "OrgCreateAuditEntry":
		base.Value = new(OrgCreateAuditEntry)
	case "OrgDisableOauthAppRestrictionsAuditEntry":
		base.Value = new(OrgDisableOauthAppRestrictionsAuditEntry)
	case "OrgDisableSamlAuditEntry":
		base.Value = new(OrgDisableSamlAuditEntry)
	case "OrgDisableTwoFactorRequirementAuditEntry":
		base.Value = new(OrgDisableTwoFactorRequirementAuditEntry)
	case "OrgEnableOauthAppRestrictionsAuditEntry":
		base.Value = new(OrgEnableOauthAppRestrictionsAuditEntry)
	case "OrgEnableSamlAuditEntry":
		base.Value = new(OrgEnableSamlAuditEntry)
	case "OrgEnableTwoFactorRequirementAuditEntry":
		base.Value = new(OrgEnableTwoFactorRequirementAuditEntry)
	case "OrgInviteMemberAuditEntry":
		base.Value = new(OrgInviteMemberAuditEntry)
	case "OrgInviteToBusinessAuditEntry":
		base.Value = new(OrgInviteToBusinessAuditEntry)
	case "OrgOauthAppAccessApprovedAuditEntry":
		base.Value = new(OrgOauthAppAccessApprovedAuditEntry)
	case "OrgOauthAppAccessBlockedAuditEntry":
		base.Value = new(OrgOauthAppAccessBlockedAuditEntry)
	case "OrgOauthAppAccessDeniedAuditEntry":
		base.Value = new(OrgOauthAppAccessDeniedAuditEntry)
	case "OrgOauthAppAccessRequestedAuditEntry":
		base.Value = new(OrgOauthAppAccessRequestedAuditEntry)
	case "OrgOauthAppAccessUnblockedAuditEntry":
		base.Value = new(OrgOauthAppAccessUnblockedAuditEntry)
	case "OrgRemoveBillingManagerAuditEntry":
		base.Value = new(OrgRemoveBillingManagerAuditEntry)
	case "OrgRemoveMemberAuditEntry":
		base.Value = new(OrgRemoveMemberAuditEntry)
	case "OrgRemoveOutsideCollaboratorAuditEntry":
		base.Value = new(OrgRemoveOutsideCollaboratorAuditEntry)
	case "OrgRestoreMemberAuditEntry":
		base.Value = new(OrgRestoreMemberAuditEntry)
	case "OrgUnblockUserAuditEntry":
		base.Value = new(OrgUnblockUserAuditEntry)
	case "OrgUpdateDefaultRepositoryPermissionAuditEntry":
		base.Value = new(OrgUpdateDefaultRepositoryPermissionAuditEntry)
	case "OrgUpdateMemberAuditEntry":
		base.Value = new(OrgUpdateMemberAuditEntry)
	case "OrgUpdateMemberRepositoryCreationPermissionAuditEntry":
		base.Value = new(OrgUpdateMemberRepositoryCreationPermissionAuditEntry)
	case "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry":
		base.Value = new(OrgUpdateMemberRepositoryInvitationPermissionAuditEntry)
	case "PrivateRepositoryForkingDisableAuditEntry":
		base.Value = new(PrivateRepositoryForkingDisableAuditEntry)
	case "PrivateRepositoryForkingEnableAuditEntry":
		base.Value = new(PrivateRepositoryForkingEnableAuditEntry)
	case "RepoAccessAuditEntry":
		base.Value = new(RepoAccessAuditEntry)
	case "RepoAddMemberAuditEntry":
		base.Value = new(RepoAddMemberAuditEntry)
	case "RepoAddTopicAuditEntry":
		base.Value = new(RepoAddTopicAuditEntry)
	case "RepoArchivedAuditEntry":
		base.Value = new(RepoArchivedAuditEntry)
	case "RepoChangeMergeSettingAuditEntry":
		base.Value = new(RepoChangeMergeSettingAuditEntry)
	case "RepoConfigDisableAnonymousGitAccessAuditEntry":
		base.Value = new(RepoConfigDisableAnonymousGitAccessAuditEntry)
	case "RepoConfigDisableCollaboratorsOnlyAuditEntry":
		base.Value = new(RepoConfigDisableCollaboratorsOnlyAuditEntry)
	case "RepoConfigDisableContributorsOnlyAuditEntry":
		base.Value = new(RepoConfigDisableContributorsOnlyAuditEntry)
	case "RepoConfigDisableSockpuppetDisallowedAuditEntry":
		base.Value = new(RepoConfigDisableSockpuppetDisallowedAuditEntry)
	case "RepoConfigEnableAnonymousGitAccessAuditEntry":
		base.Value = new(RepoConfigEnableAnonymousGitAccessAuditEntry)
	case "RepoConfigEnableCollaboratorsOnlyAuditEntry":
		base.Value = new(RepoConfigEnableCollaboratorsOnlyAuditEntry)
	case "RepoConfigEnableContributorsOnlyAuditEntry":
		base.Value = new(RepoConfigEnableContributorsOnlyAuditEntry)
	case "RepoConfigEnableSockpuppetDisallowedAuditEntry":
		base.Value = new(RepoConfigEnableSockpuppetDisallowedAuditEntry)
	case "RepoConfigLockAnonymousGitAccessAuditEntry":
		base.Value = new(RepoConfigLockAnonymousGitAccessAuditEntry)
	case "RepoConfigUnlockAnonymousGitAccessAuditEntry":
		base.Value = new(RepoConfigUnlockAnonymousGitAccessAuditEntry)
	case "RepoCreateAuditEntry":
		base.Value = new(RepoCreateAuditEntry)
	case "RepoDestroyAuditEntry":
		base.Value = new(RepoDestroyAuditEntry)
	case "RepoRemoveMemberAuditEntry":
		base.Value = new(RepoRemoveMemberAuditEntry)
	case "RepoRemoveTopicAuditEntry":
		base.Value = new(RepoRemoveTopicAuditEntry)
	case "RepositoryVisibilityChangeDisableAuditEntry":
		base.Value = new(RepositoryVisibilityChangeDisableAuditEntry)
	case "RepositoryVisibilityChangeEnableAuditEntry":
		base.Value = new(RepositoryVisibilityChangeEnableAuditEntry)
	case "TeamAddMemberAuditEntry":
		base.Value = new(TeamAddMemberAuditEntry)
	case "TeamAddRepositoryAuditEntry":
		base.Value = new(TeamAddRepositoryAuditEntry)
	case "TeamChangeParentTeamAuditEntry":
		base.Value = new(TeamChangeParentTeamAuditEntry)
	case "TeamRemoveMemberAuditEntry":
		base.Value = new(TeamRemoveMemberAuditEntry)
	case "TeamRemoveRepositoryAuditEntry":
		base.Value = new(TeamRemoveRepositoryAuditEntry)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface AuditEntry: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// AuditEntryValue is one of: MembersCanDeleteReposClearAuditEntry | MembersCanDeleteReposDisableAuditEntry | MembersCanDeleteReposEnableAuditEntry | OauthApplicationCreateAuditEntry | OrgAddBillingManagerAuditEntry | OrgAddMemberAuditEntry | OrgBlockUserAuditEntry | OrgConfigDisableCollaboratorsOnlyAuditEntry | OrgConfigEnableCollaboratorsOnlyAuditEntry | OrgCreateAuditEntry | OrgDisableOauthAppRestrictionsAuditEntry | OrgDisableSamlAuditEntry | OrgDisableTwoFactorRequirementAuditEntry | OrgEnableOauthAppRestrictionsAuditEntry | OrgEnableSamlAuditEntry | OrgEnableTwoFactorRequirementAuditEntry | OrgInviteMemberAuditEntry | OrgInviteToBusinessAuditEntry | OrgOauthAppAccessApprovedAuditEntry | OrgOauthAppAccessBlockedAuditEntry | OrgOauthAppAccessDeniedAuditEntry | OrgOauthAppAccessRequestedAuditEntry | OrgOauthAppAccessUnblockedAuditEntry | OrgRemoveBillingManagerAuditEntry | OrgRemoveMemberAuditEntry | OrgRemoveOutsideCollaboratorAuditEntry | OrgRestoreMemberAuditEntry | OrgUnblockUserAuditEntry | OrgUpdateDefaultRepositoryPermissionAuditEntry | OrgUpdateMemberAuditEntry | OrgUpdateMemberRepositoryCreationPermissionAuditEntry | OrgUpdateMemberRepositoryInvitationPermissionAuditEntry | PrivateRepositoryForkingDisableAuditEntry | PrivateRepositoryForkingEnableAuditEntry | RepoAccessAuditEntry | RepoAddMemberAuditEntry | RepoAddTopicAuditEntry | RepoArchivedAuditEntry | RepoChangeMergeSettingAuditEntry | RepoConfigDisableAnonymousGitAccessAuditEntry | RepoConfigDisableCollaboratorsOnlyAuditEntry | RepoConfigDisableContributorsOnlyAuditEntry | RepoConfigDisableSockpuppetDisallowedAuditEntry | RepoConfigEnableAnonymousGitAccessAuditEntry | RepoConfigEnableCollaboratorsOnlyAuditEntry | RepoConfigEnableContributorsOnlyAuditEntry | RepoConfigEnableSockpuppetDisallowedAuditEntry | RepoConfigLockAnonymousGitAccessAuditEntry | RepoConfigUnlockAnonymousGitAccessAuditEntry | RepoCreateAuditEntry | RepoDestroyAuditEntry | RepoRemoveMemberAuditEntry | RepoRemoveTopicAuditEntry | RepositoryVisibilityChangeDisableAuditEntry | RepositoryVisibilityChangeEnableAuditEntry | TeamAddMemberAuditEntry | TeamAddRepositoryAuditEntry | TeamChangeParentTeamAuditEntry | TeamRemoveMemberAuditEntry | TeamRemoveRepositoryAuditEntry
type AuditEntryValue interface {
	isAuditEntry()
}

// Types that can initiate an audit log event.
type AuditEntryActor struct {
	// Underlying value of the GraphQL union
	Value AuditEntryActorValue `json:"-"`
}

func (base *AuditEntryActor) UnmarshalJSON(b []byte) error {
	type Raw AuditEntryActor
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Bot":
		base.Value = new(Bot)
	case "Organization":
		base.Value = new(Organization)
	case "User":
		base.Value = new(User)
	case "":
		return fmt.Errorf("gqlclient: union AuditEntryActor: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union AuditEntryActor: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// AuditEntryActorValue is one of: Bot | Organization | User
type AuditEntryActorValue interface {
	isAuditEntryActor()
}

// Ordering options for Audit Log connections.
type AuditLogOrder struct {
	// The ordering direction.
	Direction *OrderDirection `json:"direction,omitempty"`
	// The field to order Audit Logs by.
	Field *AuditLogOrderField `json:"field,omitempty"`
}

// Properties by which Audit Log connections can be ordered.
type AuditLogOrderField string

const (
	// Order audit log entries by timestamp
	AuditLogOrderFieldCreatedAt AuditLogOrderField = "CREATED_AT"
)

// Represents a 'auto_merge_disabled' event on a given pull request.
type AutoMergeDisabledEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The user who disabled auto-merge for this Pull Request
	Disabler *User `json:"disabler,omitempty"`
	// The Node ID of the AutoMergeDisabledEvent object
	Id string `json:"id"`
	// PullRequest referenced by event
	PullRequest *PullRequest `json:"pullRequest,omitempty"`
	// The reason auto-merge was disabled
	Reason *string `json:"reason,omitempty"`
	// The reason_code relating to why auto-merge was disabled
	ReasonCode *string `json:"reasonCode,omitempty"`
}

func (*AutoMergeDisabledEvent) isNode() {}

func (*AutoMergeDisabledEvent) isPullRequestTimelineItems() {}

// Represents a 'auto_merge_enabled' event on a given pull request.
type AutoMergeEnabledEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The user who enabled auto-merge for this Pull Request
	Enabler *User `json:"enabler,omitempty"`
	// The Node ID of the AutoMergeEnabledEvent object
	Id string `json:"id"`
	// PullRequest referenced by event.
	PullRequest *PullRequest `json:"pullRequest,omitempty"`
}

func (*AutoMergeEnabledEvent) isNode() {}

func (*AutoMergeEnabledEvent) isPullRequestTimelineItems() {}

// Represents an auto-merge request for a pull request
type AutoMergeRequest struct {
	// The email address of the author of this auto-merge request.
	AuthorEmail *string `json:"authorEmail,omitempty"`
	// The commit message of the auto-merge request. If a merge queue is required by
	// the base branch, this value will be set by the merge queue when merging.
	CommitBody *string `json:"commitBody,omitempty"`
	// The commit title of the auto-merge request. If a merge queue is required by
	// the base branch, this value will be set by the merge queue when merging
	CommitHeadline *string `json:"commitHeadline,omitempty"`
	// When was this auto-merge request was enabled.
	EnabledAt *DateTime `json:"enabledAt,omitempty"`
	// The actor who created the auto-merge request.
	EnabledBy *Actor `json:"enabledBy,omitempty"`
	// The merge method of the auto-merge request. If a merge queue is required by
	// the base branch, this value will be set by the merge queue when merging.
	MergeMethod PullRequestMergeMethod `json:"mergeMethod"`
	// The pull request that this auto-merge request is set against.
	PullRequest *PullRequest `json:"pullRequest"`
}

// Represents a 'auto_rebase_enabled' event on a given pull request.
type AutoRebaseEnabledEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The user who enabled auto-merge (rebase) for this Pull Request
	Enabler *User `json:"enabler,omitempty"`
	// The Node ID of the AutoRebaseEnabledEvent object
	Id string `json:"id"`
	// PullRequest referenced by event.
	PullRequest *PullRequest `json:"pullRequest,omitempty"`
}

func (*AutoRebaseEnabledEvent) isNode() {}

func (*AutoRebaseEnabledEvent) isPullRequestTimelineItems() {}

// Represents a 'auto_squash_enabled' event on a given pull request.
type AutoSquashEnabledEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The user who enabled auto-merge (squash) for this Pull Request
	Enabler *User `json:"enabler,omitempty"`
	// The Node ID of the AutoSquashEnabledEvent object
	Id string `json:"id"`
	// PullRequest referenced by event.
	PullRequest *PullRequest `json:"pullRequest,omitempty"`
}

func (*AutoSquashEnabledEvent) isNode() {}

func (*AutoSquashEnabledEvent) isPullRequestTimelineItems() {}

// Represents a 'automatic_base_change_failed' event on a given pull request.
type AutomaticBaseChangeFailedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the AutomaticBaseChangeFailedEvent object
	Id string `json:"id"`
	// The new base for this PR
	NewBase string `json:"newBase"`
	// The old base for this PR
	OldBase string `json:"oldBase"`
	// PullRequest referenced by event.
	PullRequest *PullRequest `json:"pullRequest"`
}

func (*AutomaticBaseChangeFailedEvent) isNode() {}

func (*AutomaticBaseChangeFailedEvent) isPullRequestTimelineItems() {}

// Represents a 'automatic_base_change_succeeded' event on a given pull request.
type AutomaticBaseChangeSucceededEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the AutomaticBaseChangeSucceededEvent object
	Id string `json:"id"`
	// The new base for this PR
	NewBase string `json:"newBase"`
	// The old base for this PR
	OldBase string `json:"oldBase"`
	// PullRequest referenced by event.
	PullRequest *PullRequest `json:"pullRequest"`
}

func (*AutomaticBaseChangeSucceededEvent) isNode() {}

func (*AutomaticBaseChangeSucceededEvent) isPullRequestTimelineItems() {}

// A (potentially binary) string encoded using base64.
type Base64String string

// Represents a 'base_ref_changed' event on a given issue or pull request.
type BaseRefChangedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the name of the base ref for the pull request after it was changed.
	CurrentRefName string `json:"currentRefName"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The Node ID of the BaseRefChangedEvent object
	Id string `json:"id"`
	// Identifies the name of the base ref for the pull request before it was changed.
	PreviousRefName string `json:"previousRefName"`
	// PullRequest referenced by event.
	PullRequest *PullRequest `json:"pullRequest"`
}

func (*BaseRefChangedEvent) isNode() {}

func (*BaseRefChangedEvent) isPullRequestTimelineItems() {}

// Represents a 'base_ref_deleted' event on a given pull request.
type BaseRefDeletedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the name of the Ref associated with the `base_ref_deleted` event.
	BaseRefName *string `json:"baseRefName,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the BaseRefDeletedEvent object
	Id string `json:"id"`
	// PullRequest referenced by event.
	PullRequest *PullRequest `json:"pullRequest,omitempty"`
}

func (*BaseRefDeletedEvent) isNode() {}

func (*BaseRefDeletedEvent) isPullRequestTimelineItem() {}

func (*BaseRefDeletedEvent) isPullRequestTimelineItems() {}

// Represents a 'base_ref_force_pushed' event on a given pull request.
type BaseRefForcePushedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the after commit SHA for the 'base_ref_force_pushed' event.
	AfterCommit *Commit `json:"afterCommit,omitempty"`
	// Identifies the before commit SHA for the 'base_ref_force_pushed' event.
	BeforeCommit *Commit `json:"beforeCommit,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the BaseRefForcePushedEvent object
	Id string `json:"id"`
	// PullRequest referenced by event.
	PullRequest *PullRequest `json:"pullRequest"`
	// Identifies the fully qualified ref name for the 'base_ref_force_pushed' event.
	Ref *Ref `json:"ref,omitempty"`
}

func (*BaseRefForcePushedEvent) isNode() {}

func (*BaseRefForcePushedEvent) isPullRequestTimelineItem() {}

func (*BaseRefForcePushedEvent) isPullRequestTimelineItems() {}

// Represents non-fractional signed whole numeric values. Since the value may
// exceed the size of a 32-bit integer, it's encoded as a string.
type BigInt string

// Represents a Git blame.
type Blame struct {
	// The list of ranges from a Git blame.
	Ranges []BlameRange `json:"ranges"`
}

// Represents a range of information from a Git blame.
type BlameRange struct {
	// Identifies the recency of the change, from 1 (new) to 10 (old). This is
	// calculated as a 2-quantile and determines the length of distance between the
	// median age of all the changes in the file and the recency of the current
	// range's change.
	Age int32 `json:"age"`
	// Identifies the line author
	Commit *Commit `json:"commit"`
	// The ending line for the range
	EndingLine int32 `json:"endingLine"`
	// The starting line for the range
	StartingLine int32 `json:"startingLine"`
}

// Represents a Git blob.
type Blob struct {
	// An abbreviated version of the Git object ID
	AbbreviatedOid string `json:"abbreviatedOid"`
	// Byte size of Blob object
	ByteSize int32 `json:"byteSize"`
	// The HTTP path for this Git object
	CommitResourcePath URI `json:"commitResourcePath"`
	// The HTTP URL for this Git object
	CommitUrl URI `json:"commitUrl"`
	// The Node ID of the Blob object
	Id string `json:"id"`
	// Indicates whether the Blob is binary or text. Returns null if unable to determine the encoding.
	IsBinary *bool `json:"isBinary,omitempty"`
	// Indicates whether the contents is truncated
	IsTruncated bool `json:"isTruncated"`
	// The Git object ID
	Oid GitObjectID `json:"oid"`
	// The Repository the Git object belongs to
	Repository *Repository `json:"repository"`
	// UTF8 text data or null if the Blob is binary
	Text *string `json:"text,omitempty"`
}

func (*Blob) isGitObject() {}

func (*Blob) isNode() {}

// A special type of user which takes actions on behalf of GitHub Apps.
type Bot struct {
	// A URL pointing to the GitHub App's public avatar.
	AvatarUrl URI `json:"avatarUrl"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The Node ID of the Bot object
	Id string `json:"id"`
	// The username of the actor.
	Login string `json:"login"`
	// The HTTP path for this bot
	ResourcePath URI `json:"resourcePath"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The HTTP URL for this bot
	Url URI `json:"url"`
}

func (*Bot) isAssignee() {}

func (*Bot) isAuditEntryActor() {}

func (*Bot) isActor() {}

func (*Bot) isNode() {}

func (*Bot) isUniformResourceLocatable() {}

func (*Bot) isReactor() {}

func (*Bot) isRequestedReviewer() {}

// Types which can be actors for `BranchActorAllowance` objects.
type BranchActorAllowanceActor struct {
	// Underlying value of the GraphQL union
	Value BranchActorAllowanceActorValue `json:"-"`
}

func (base *BranchActorAllowanceActor) UnmarshalJSON(b []byte) error {
	type Raw BranchActorAllowanceActor
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "App":
		base.Value = new(App)
	case "Team":
		base.Value = new(Team)
	case "User":
		base.Value = new(User)
	case "":
		return fmt.Errorf("gqlclient: union BranchActorAllowanceActor: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union BranchActorAllowanceActor: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// BranchActorAllowanceActorValue is one of: App | Team | User
type BranchActorAllowanceActorValue interface {
	isBranchActorAllowanceActor()
}

// Parameters to be used for the branch_name_pattern rule
type BranchNamePatternParameters struct {
	// How this rule will appear to users.
	Name *string `json:"name,omitempty"`
	// If true, the rule will fail if the pattern matches.
	Negate bool `json:"negate"`
	// The operator to use for matching.
	Operator string `json:"operator"`
	// The pattern to match with.
	Pattern string `json:"pattern"`
}

func (*BranchNamePatternParameters) isRuleParameters() {}

// Parameters to be used for the branch_name_pattern rule
type BranchNamePatternParametersInput struct {
	// How this rule will appear to users.
	Name *string `json:"name,omitempty"`
	// If true, the rule will fail if the pattern matches.
	Negate *bool `json:"negate,omitempty"`
	// The operator to use for matching.
	Operator string `json:"operator"`
	// The pattern to match with.
	Pattern string `json:"pattern"`
}

// A branch protection rule.
type BranchProtectionRule struct {
	// Can this branch be deleted.
	AllowsDeletions bool `json:"allowsDeletions"`
	// Are force pushes allowed on this branch.
	AllowsForcePushes bool `json:"allowsForcePushes"`
	// Is branch creation a protected operation.
	BlocksCreations bool `json:"blocksCreations"`
	// A list of conflicts matching branches protection rule and other branch protection rules
	BranchProtectionRuleConflicts *BranchProtectionRuleConflictConnection `json:"branchProtectionRuleConflicts"`
	// A list of actors able to force push for this branch protection rule.
	BypassForcePushAllowances *BypassForcePushAllowanceConnection `json:"bypassForcePushAllowances"`
	// A list of actors able to bypass PRs for this branch protection rule.
	BypassPullRequestAllowances *BypassPullRequestAllowanceConnection `json:"bypassPullRequestAllowances"`
	// The actor who created this branch protection rule.
	Creator *Actor `json:"creator,omitempty"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// Will new commits pushed to matching branches dismiss pull request review approvals.
	DismissesStaleReviews bool `json:"dismissesStaleReviews"`
	// The Node ID of the BranchProtectionRule object
	Id string `json:"id"`
	// Can admins override branch protection.
	IsAdminEnforced bool `json:"isAdminEnforced"`
	// Whether users can pull changes from upstream when the branch is locked. Set to
	// `true` to allow fork syncing. Set to `false` to prevent fork syncing.
	LockAllowsFetchAndMerge bool `json:"lockAllowsFetchAndMerge"`
	// Whether to set the branch as read-only. If this is true, users will not be able to push to the branch.
	LockBranch bool `json:"lockBranch"`
	// Repository refs that are protected by this rule
	MatchingRefs *RefConnection `json:"matchingRefs"`
	// Identifies the protection rule pattern.
	Pattern string `json:"pattern"`
	// A list push allowances for this branch protection rule.
	PushAllowances *PushAllowanceConnection `json:"pushAllowances"`
	// The repository associated with this branch protection rule.
	Repository *Repository `json:"repository,omitempty"`
	// Whether the most recent push must be approved by someone other than the person who pushed it
	RequireLastPushApproval bool `json:"requireLastPushApproval"`
	// Number of approving reviews required to update matching branches.
	RequiredApprovingReviewCount *int32 `json:"requiredApprovingReviewCount,omitempty"`
	// List of required deployment environments that must be deployed successfully to update matching branches
	RequiredDeploymentEnvironments []*string `json:"requiredDeploymentEnvironments,omitempty"`
	// List of required status check contexts that must pass for commits to be accepted to matching branches.
	RequiredStatusCheckContexts []*string `json:"requiredStatusCheckContexts,omitempty"`
	// List of required status checks that must pass for commits to be accepted to matching branches.
	RequiredStatusChecks []RequiredStatusCheckDescription `json:"requiredStatusChecks,omitempty"`
	// Are approving reviews required to update matching branches.
	RequiresApprovingReviews bool `json:"requiresApprovingReviews"`
	// Are reviews from code owners required to update matching branches.
	RequiresCodeOwnerReviews bool `json:"requiresCodeOwnerReviews"`
	// Are commits required to be signed.
	RequiresCommitSignatures bool `json:"requiresCommitSignatures"`
	// Are conversations required to be resolved before merging.
	RequiresConversationResolution bool `json:"requiresConversationResolution"`
	// Does this branch require deployment to specific environments before merging
	RequiresDeployments bool `json:"requiresDeployments"`
	// Are merge commits prohibited from being pushed to this branch.
	RequiresLinearHistory bool `json:"requiresLinearHistory"`
	// Are status checks required to update matching branches.
	RequiresStatusChecks bool `json:"requiresStatusChecks"`
	// Are branches required to be up to date before merging.
	RequiresStrictStatusChecks bool `json:"requiresStrictStatusChecks"`
	// Is pushing to matching branches restricted.
	RestrictsPushes bool `json:"restrictsPushes"`
	// Is dismissal of pull request reviews restricted.
	RestrictsReviewDismissals bool `json:"restrictsReviewDismissals"`
	// A list review dismissal allowances for this branch protection rule.
	ReviewDismissalAllowances *ReviewDismissalAllowanceConnection `json:"reviewDismissalAllowances"`
}

func (*BranchProtectionRule) isNode() {}

// A conflict between two branch protection rules.
type BranchProtectionRuleConflict struct {
	// Identifies the branch protection rule.
	BranchProtectionRule *BranchProtectionRule `json:"branchProtectionRule,omitempty"`
	// Identifies the conflicting branch protection rule.
	ConflictingBranchProtectionRule *BranchProtectionRule `json:"conflictingBranchProtectionRule,omitempty"`
	// Identifies the branch ref that has conflicting rules
	Ref *Ref `json:"ref,omitempty"`
}

// The connection type for BranchProtectionRuleConflict.
type BranchProtectionRuleConflictConnection struct {
	// A list of edges.
	Edges []*BranchProtectionRuleConflictEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*BranchProtectionRuleConflict `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type BranchProtectionRuleConflictEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *BranchProtectionRuleConflict `json:"node,omitempty"`
}

// The connection type for BranchProtectionRule.
type BranchProtectionRuleConnection struct {
	// A list of edges.
	Edges []*BranchProtectionRuleEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*BranchProtectionRule `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type BranchProtectionRuleEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *BranchProtectionRule `json:"node,omitempty"`
}

// Information about a sponsorship to make for a user or organization with a GitHub
// Sponsors profile, as part of sponsoring many users or organizations at once.
type BulkSponsorship struct {
	// The amount to pay to the sponsorable in US dollars. Valid values: 1-12000.
	Amount int32 `json:"amount"`
	// The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given.
	SponsorableId string `json:"sponsorableId,omitempty"`
	// The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given.
	SponsorableLogin *string `json:"sponsorableLogin,omitempty"`
}

// Types that can represent a repository ruleset bypass actor.
type BypassActor struct {
	// Underlying value of the GraphQL union
	Value BypassActorValue `json:"-"`
}

func (base *BypassActor) UnmarshalJSON(b []byte) error {
	type Raw BypassActor
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "App":
		base.Value = new(App)
	case "Team":
		base.Value = new(Team)
	case "":
		return fmt.Errorf("gqlclient: union BypassActor: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union BypassActor: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// BypassActorValue is one of: App | Team
type BypassActorValue interface {
	isBypassActor()
}

// A user, team, or app who has the ability to bypass a force push requirement on a protected branch.
type BypassForcePushAllowance struct {
	// The actor that can force push.
	Actor *BranchActorAllowanceActor `json:"actor,omitempty"`
	// Identifies the branch protection rule associated with the allowed user, team, or app.
	BranchProtectionRule *BranchProtectionRule `json:"branchProtectionRule,omitempty"`
	// The Node ID of the BypassForcePushAllowance object
	Id string `json:"id"`
}

func (*BypassForcePushAllowance) isNode() {}

// The connection type for BypassForcePushAllowance.
type BypassForcePushAllowanceConnection struct {
	// A list of edges.
	Edges []*BypassForcePushAllowanceEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*BypassForcePushAllowance `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type BypassForcePushAllowanceEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *BypassForcePushAllowance `json:"node,omitempty"`
}

// A user, team, or app who has the ability to bypass a pull request requirement on a protected branch.
type BypassPullRequestAllowance struct {
	// The actor that can bypass.
	Actor *BranchActorAllowanceActor `json:"actor,omitempty"`
	// Identifies the branch protection rule associated with the allowed user, team, or app.
	BranchProtectionRule *BranchProtectionRule `json:"branchProtectionRule,omitempty"`
	// The Node ID of the BypassPullRequestAllowance object
	Id string `json:"id"`
}

func (*BypassPullRequestAllowance) isNode() {}

// The connection type for BypassPullRequestAllowance.
type BypassPullRequestAllowanceConnection struct {
	// A list of edges.
	Edges []*BypassPullRequestAllowanceEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*BypassPullRequestAllowance `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type BypassPullRequestAllowanceEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *BypassPullRequestAllowance `json:"node,omitempty"`
}

// The Common Vulnerability Scoring System
type CVSS struct {
	// The CVSS score associated with this advisory
	Score float64 `json:"score"`
	// The CVSS vector string associated with this advisory
	VectorString *string `json:"vectorString,omitempty"`
}

// A common weakness enumeration
type CWE struct {
	// The id of the CWE
	CweId string `json:"cweId"`
	// A detailed description of this CWE
	Description string `json:"description"`
	// The Node ID of the CWE object
	Id string `json:"id"`
	// The name of this CWE
	Name string `json:"name"`
}

func (*CWE) isNode() {}

// The connection type for CWE.
type CWEConnection struct {
	// A list of edges.
	Edges []*CWEEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*CWE `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type CWEEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *CWE `json:"node,omitempty"`
}

// Autogenerated input type of CancelEnterpriseAdminInvitation
type CancelEnterpriseAdminInvitationInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Node ID of the pending enterprise administrator invitation.
	InvitationId string `json:"invitationId"`
}

// Autogenerated return type of CancelEnterpriseAdminInvitation.
type CancelEnterpriseAdminInvitationPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The invitation that was canceled.
	Invitation *EnterpriseAdministratorInvitation `json:"invitation,omitempty"`
	// A message confirming the result of canceling an administrator invitation.
	Message *string `json:"message,omitempty"`
}

// Autogenerated input type of CancelEnterpriseMemberInvitation
type CancelEnterpriseMemberInvitationInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Node ID of the pending enterprise member invitation.
	InvitationId string `json:"invitationId"`
}

// Autogenerated return type of CancelEnterpriseMemberInvitation.
type CancelEnterpriseMemberInvitationPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The invitation that was canceled.
	Invitation *EnterpriseMemberInvitation `json:"invitation,omitempty"`
	// A message confirming the result of canceling an member invitation.
	Message *string `json:"message,omitempty"`
}

// Autogenerated input type of CancelSponsorship
type CancelSponsorshipInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the user or organization who is acting as the sponsor, paying for
	// the sponsorship. Required if sponsorLogin is not given.
	SponsorId string `json:"sponsorId,omitempty"`
	// The username of the user or organization who is acting as the sponsor, paying
	// for the sponsorship. Required if sponsorId is not given.
	SponsorLogin *string `json:"sponsorLogin,omitempty"`
	// The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given.
	SponsorableId string `json:"sponsorableId,omitempty"`
	// The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given.
	SponsorableLogin *string `json:"sponsorableLogin,omitempty"`
}

// Autogenerated return type of CancelSponsorship.
type CancelSponsorshipPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The tier that was being used at the time of cancellation.
	SponsorsTier *SponsorsTier `json:"sponsorsTier,omitempty"`
}

// Autogenerated input type of ChangeUserStatus
type ChangeUserStatusInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The emoji to represent your status. Can either be a native Unicode emoji or an emoji name with colons, e.g., :grinning:.
	Emoji *string `json:"emoji,omitempty"`
	// If set, the user status will not be shown after this date.
	ExpiresAt *DateTime `json:"expiresAt,omitempty"`
	// Whether this status should indicate you are not fully available on GitHub, e.g., you are away.
	LimitedAvailability *bool `json:"limitedAvailability,omitempty"`
	// A short description of your current status.
	Message *string `json:"message,omitempty"`
	// The ID of the organization whose members will be allowed to see the status. If
	// omitted, the status will be publicly visible.
	OrganizationId string `json:"organizationId,omitempty"`
}

// Autogenerated return type of ChangeUserStatus.
type ChangeUserStatusPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Your updated status.
	Status *UserStatus `json:"status,omitempty"`
}

// A single check annotation.
type CheckAnnotation struct {
	// The annotation's severity level.
	AnnotationLevel *CheckAnnotationLevel `json:"annotationLevel,omitempty"`
	// The path to the file that this annotation was made on.
	BlobUrl URI `json:"blobUrl"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The position of this annotation.
	Location *CheckAnnotationSpan `json:"location"`
	// The annotation's message.
	Message string `json:"message"`
	// The path that this annotation was made on.
	Path string `json:"path"`
	// Additional information about the annotation.
	RawDetails *string `json:"rawDetails,omitempty"`
	// The annotation's title
	Title *string `json:"title,omitempty"`
}

// The connection type for CheckAnnotation.
type CheckAnnotationConnection struct {
	// A list of edges.
	Edges []*CheckAnnotationEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*CheckAnnotation `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// Information from a check run analysis to specific lines of code.
type CheckAnnotationData struct {
	// Represents an annotation's information level
	AnnotationLevel CheckAnnotationLevel `json:"annotationLevel"`
	// The location of the annotation
	Location CheckAnnotationRange `json:"location"`
	// A short description of the feedback for these lines of code.
	Message string `json:"message"`
	// The path of the file to add an annotation to.
	Path string `json:"path"`
	// Details about this annotation.
	RawDetails *string `json:"rawDetails,omitempty"`
	// The title that represents the annotation.
	Title *string `json:"title,omitempty"`
}

// An edge in a connection.
type CheckAnnotationEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *CheckAnnotation `json:"node,omitempty"`
}

// Represents an annotation's information level.
type CheckAnnotationLevel string

const (
	// An annotation indicating an inescapable error.
	CheckAnnotationLevelFailure CheckAnnotationLevel = "FAILURE"
	// An annotation indicating some information.
	CheckAnnotationLevelNotice CheckAnnotationLevel = "NOTICE"
	// An annotation indicating an ignorable error.
	CheckAnnotationLevelWarning CheckAnnotationLevel = "WARNING"
)

// A character position in a check annotation.
type CheckAnnotationPosition struct {
	// Column number (1 indexed).
	Column *int32 `json:"column,omitempty"`
	// Line number (1 indexed).
	Line int32 `json:"line"`
}

// Information from a check run analysis to specific lines of code.
type CheckAnnotationRange struct {
	// The ending column of the range.
	EndColumn *int32 `json:"endColumn,omitempty"`
	// The ending line of the range.
	EndLine int32 `json:"endLine"`
	// The starting column of the range.
	StartColumn *int32 `json:"startColumn,omitempty"`
	// The starting line of the range.
	StartLine int32 `json:"startLine"`
}

// An inclusive pair of positions for a check annotation.
type CheckAnnotationSpan struct {
	// End position (inclusive).
	End *CheckAnnotationPosition `json:"end"`
	// Start position (inclusive).
	Start *CheckAnnotationPosition `json:"start"`
}

// The possible states for a check suite or run conclusion.
type CheckConclusionState string

const (
	// The check suite or run requires action.
	CheckConclusionStateActionRequired CheckConclusionState = "ACTION_REQUIRED"
	// The check suite or run has been cancelled.
	CheckConclusionStateCancelled CheckConclusionState = "CANCELLED"
	// The check suite or run has failed.
	CheckConclusionStateFailure CheckConclusionState = "FAILURE"
	// The check suite or run was neutral.
	CheckConclusionStateNeutral CheckConclusionState = "NEUTRAL"
	// The check suite or run was skipped.
	CheckConclusionStateSkipped CheckConclusionState = "SKIPPED"
	// The check suite or run was marked stale by GitHub. Only GitHub can use this conclusion.
	CheckConclusionStateStale CheckConclusionState = "STALE"
	// The check suite or run has failed at startup.
	CheckConclusionStateStartupFailure CheckConclusionState = "STARTUP_FAILURE"
	// The check suite or run has succeeded.
	CheckConclusionStateSuccess CheckConclusionState = "SUCCESS"
	// The check suite or run has timed out.
	CheckConclusionStateTimedOut CheckConclusionState = "TIMED_OUT"
)

// A check run.
type CheckRun struct {
	// The check run's annotations
	Annotations *CheckAnnotationConnection `json:"annotations,omitempty"`
	// The check suite that this run is a part of.
	CheckSuite *CheckSuite `json:"checkSuite"`
	// Identifies the date and time when the check run was completed.
	CompletedAt *DateTime `json:"completedAt,omitempty"`
	// The conclusion of the check run.
	Conclusion *CheckConclusionState `json:"conclusion,omitempty"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The corresponding deployment for this job, if any
	Deployment *Deployment `json:"deployment,omitempty"`
	// The URL from which to find full details of the check run on the integrator's site.
	DetailsUrl *URI `json:"detailsUrl,omitempty"`
	// A reference for the check run on the integrator's system.
	ExternalId *string `json:"externalId,omitempty"`
	// The Node ID of the CheckRun object
	Id string `json:"id"`
	// Whether this is required to pass before merging for a specific pull request.
	IsRequired bool `json:"isRequired"`
	// The name of the check for this check run.
	Name string `json:"name"`
	// Information about a pending deployment, if any, in this check run
	PendingDeploymentRequest *DeploymentRequest `json:"pendingDeploymentRequest,omitempty"`
	// The permalink to the check run summary.
	Permalink URI `json:"permalink"`
	// The repository associated with this check run.
	Repository *Repository `json:"repository"`
	// The HTTP path for this check run.
	ResourcePath URI `json:"resourcePath"`
	// Identifies the date and time when the check run was started.
	StartedAt *DateTime `json:"startedAt,omitempty"`
	// The current status of the check run.
	Status CheckStatusState `json:"status"`
	// The check run's steps
	Steps *CheckStepConnection `json:"steps,omitempty"`
	// A string representing the check run's summary
	Summary *string `json:"summary,omitempty"`
	// A string representing the check run's text
	Text *string `json:"text,omitempty"`
	// A string representing the check run
	Title *string `json:"title,omitempty"`
	// The HTTP URL for this check run.
	Url URI `json:"url"`
}

func (*CheckRun) isNode() {}

func (*CheckRun) isRequirableByPullRequest() {}

func (*CheckRun) isUniformResourceLocatable() {}

func (*CheckRun) isStatusCheckRollupContext() {}

// Possible further actions the integrator can perform.
type CheckRunAction struct {
	// A short explanation of what this action would do.
	Description string `json:"description"`
	// A reference for the action on the integrator's system.
	Identifier string `json:"identifier"`
	// The text to be displayed on a button in the web UI.
	Label string `json:"label"`
}

// The connection type for CheckRun.
type CheckRunConnection struct {
	// A list of edges.
	Edges []*CheckRunEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*CheckRun `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type CheckRunEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *CheckRun `json:"node,omitempty"`
}

// The filters that are available when fetching check runs.
type CheckRunFilter struct {
	// Filters the check runs created by this application ID.
	AppId *int32 `json:"appId,omitempty"`
	// Filters the check runs by this name.
	CheckName *string `json:"checkName,omitempty"`
	// Filters the check runs by this type.
	CheckType *CheckRunType `json:"checkType,omitempty"`
	// Filters the check runs by these conclusions.
	Conclusions []CheckConclusionState `json:"conclusions,omitempty"`
	// Filters the check runs by this status. Superceded by statuses.
	Status *CheckStatusState `json:"status,omitempty"`
	// Filters the check runs by this status. Overrides status.
	Statuses []CheckStatusState `json:"statuses,omitempty"`
}

// Descriptive details about the check run.
type CheckRunOutput struct {
	// The annotations that are made as part of the check run.
	Annotations []CheckAnnotationData `json:"annotations,omitempty"`
	// Images attached to the check run output displayed in the GitHub pull request UI.
	Images []CheckRunOutputImage `json:"images,omitempty"`
	// The summary of the check run (supports Commonmark).
	Summary string `json:"summary"`
	// The details of the check run (supports Commonmark).
	Text *string `json:"text,omitempty"`
	// A title to provide for this check run.
	Title string `json:"title"`
}

// Images attached to the check run output displayed in the GitHub pull request UI.
type CheckRunOutputImage struct {
	// The alternative text for the image.
	Alt string `json:"alt"`
	// A short image description.
	Caption *string `json:"caption,omitempty"`
	// The full URL of the image.
	ImageUrl URI `json:"imageUrl"`
}

// The possible states of a check run in a status rollup.
type CheckRunState string

const (
	// The check run requires action.
	CheckRunStateActionRequired CheckRunState = "ACTION_REQUIRED"
	// The check run has been cancelled.
	CheckRunStateCancelled CheckRunState = "CANCELLED"
	// The check run has been completed.
	CheckRunStateCompleted CheckRunState = "COMPLETED"
	// The check run has failed.
	CheckRunStateFailure CheckRunState = "FAILURE"
	// The check run is in progress.
	CheckRunStateInProgress CheckRunState = "IN_PROGRESS"
	// The check run was neutral.
	CheckRunStateNeutral CheckRunState = "NEUTRAL"
	// The check run is in pending state.
	CheckRunStatePending CheckRunState = "PENDING"
	// The check run has been queued.
	CheckRunStateQueued CheckRunState = "QUEUED"
	// The check run was skipped.
	CheckRunStateSkipped CheckRunState = "SKIPPED"
	// The check run was marked stale by GitHub. Only GitHub can use this conclusion.
	CheckRunStateStale CheckRunState = "STALE"
	// The check run has failed at startup.
	CheckRunStateStartupFailure CheckRunState = "STARTUP_FAILURE"
	// The check run has succeeded.
	CheckRunStateSuccess CheckRunState = "SUCCESS"
	// The check run has timed out.
	CheckRunStateTimedOut CheckRunState = "TIMED_OUT"
	// The check run is in waiting state.
	CheckRunStateWaiting CheckRunState = "WAITING"
)

// Represents a count of the state of a check run.
type CheckRunStateCount struct {
	// The number of check runs with this state.
	Count int32 `json:"count"`
	// The state of a check run.
	State CheckRunState `json:"state"`
}

// The possible types of check runs.
type CheckRunType string

const (
	// Every check run available.
	CheckRunTypeAll CheckRunType = "ALL"
	// The latest check run.
	CheckRunTypeLatest CheckRunType = "LATEST"
)

// The possible states for a check suite or run status.
type CheckStatusState string

const (
	// The check suite or run has been completed.
	CheckStatusStateCompleted CheckStatusState = "COMPLETED"
	// The check suite or run is in progress.
	CheckStatusStateInProgress CheckStatusState = "IN_PROGRESS"
	// The check suite or run is in pending state.
	CheckStatusStatePending CheckStatusState = "PENDING"
	// The check suite or run has been queued.
	CheckStatusStateQueued CheckStatusState = "QUEUED"
	// The check suite or run has been requested.
	CheckStatusStateRequested CheckStatusState = "REQUESTED"
	// The check suite or run is in waiting state.
	CheckStatusStateWaiting CheckStatusState = "WAITING"
)

// A single check step.
type CheckStep struct {
	// Identifies the date and time when the check step was completed.
	CompletedAt *DateTime `json:"completedAt,omitempty"`
	// The conclusion of the check step.
	Conclusion *CheckConclusionState `json:"conclusion,omitempty"`
	// A reference for the check step on the integrator's system.
	ExternalId *string `json:"externalId,omitempty"`
	// The step's name.
	Name string `json:"name"`
	// The index of the step in the list of steps of the parent check run.
	Number int32 `json:"number"`
	// Number of seconds to completion.
	SecondsToCompletion *int32 `json:"secondsToCompletion,omitempty"`
	// Identifies the date and time when the check step was started.
	StartedAt *DateTime `json:"startedAt,omitempty"`
	// The current status of the check step.
	Status CheckStatusState `json:"status"`
}

// The connection type for CheckStep.
type CheckStepConnection struct {
	// A list of edges.
	Edges []*CheckStepEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*CheckStep `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type CheckStepEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *CheckStep `json:"node,omitempty"`
}

// A check suite.
type CheckSuite struct {
	// The GitHub App which created this check suite.
	App *App `json:"app,omitempty"`
	// The name of the branch for this check suite.
	Branch *Ref `json:"branch,omitempty"`
	// The check runs associated with a check suite.
	CheckRuns *CheckRunConnection `json:"checkRuns,omitempty"`
	// The commit for this check suite
	Commit *Commit `json:"commit"`
	// The conclusion of this check suite.
	Conclusion *CheckConclusionState `json:"conclusion,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The user who triggered the check suite.
	Creator *User `json:"creator,omitempty"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The Node ID of the CheckSuite object
	Id string `json:"id"`
	// A list of open pull requests matching the check suite.
	MatchingPullRequests *PullRequestConnection `json:"matchingPullRequests,omitempty"`
	// The push that triggered this check suite.
	Push *Push `json:"push,omitempty"`
	// The repository associated with this check suite.
	Repository *Repository `json:"repository"`
	// The HTTP path for this check suite
	ResourcePath URI `json:"resourcePath"`
	// The status of this check suite.
	Status CheckStatusState `json:"status"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The HTTP URL for this check suite
	Url URI `json:"url"`
	// The workflow run associated with this check suite.
	WorkflowRun *WorkflowRun `json:"workflowRun,omitempty"`
}

func (*CheckSuite) isNode() {}

// The auto-trigger preferences that are available for check suites.
type CheckSuiteAutoTriggerPreference struct {
	// The node ID of the application that owns the check suite.
	AppId string `json:"appId"`
	// Set to `true` to enable automatic creation of CheckSuite events upon pushes to the repository.
	Setting bool `json:"setting"`
}

// The connection type for CheckSuite.
type CheckSuiteConnection struct {
	// A list of edges.
	Edges []*CheckSuiteEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*CheckSuite `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type CheckSuiteEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *CheckSuite `json:"node,omitempty"`
}

// The filters that are available when fetching check suites.
type CheckSuiteFilter struct {
	// Filters the check suites created by this application ID.
	AppId *int32 `json:"appId,omitempty"`
	// Filters the check suites by this name.
	CheckName *string `json:"checkName,omitempty"`
}

// An object which can have its data claimed or claim data from another.
type Claimable struct {
	// Underlying value of the GraphQL union
	Value ClaimableValue `json:"-"`
}

func (base *Claimable) UnmarshalJSON(b []byte) error {
	type Raw Claimable
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Mannequin":
		base.Value = new(Mannequin)
	case "User":
		base.Value = new(User)
	case "":
		return fmt.Errorf("gqlclient: union Claimable: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union Claimable: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// ClaimableValue is one of: Mannequin | User
type ClaimableValue interface {
	isClaimable()
}

// Autogenerated input type of ClearLabelsFromLabelable
type ClearLabelsFromLabelableInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The id of the labelable object to clear the labels from.
	LabelableId string `json:"labelableId"`
}

// Autogenerated return type of ClearLabelsFromLabelable.
type ClearLabelsFromLabelablePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The item that was unlabeled.
	Labelable *Labelable `json:"labelable,omitempty"`
}

// Autogenerated input type of ClearProjectV2ItemFieldValue
type ClearProjectV2ItemFieldValueInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the field to be cleared.
	FieldId string `json:"fieldId"`
	// The ID of the item to be cleared.
	ItemId string `json:"itemId"`
	// The ID of the Project.
	ProjectId string `json:"projectId"`
}

// Autogenerated return type of ClearProjectV2ItemFieldValue.
type ClearProjectV2ItemFieldValuePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The updated item.
	ProjectV2Item *ProjectV2Item `json:"projectV2Item,omitempty"`
}

// Autogenerated input type of CloneProject
type CloneProjectInput struct {
	// The description of the project.
	Body *string `json:"body,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Whether or not to clone the source project's workflows.
	IncludeWorkflows bool `json:"includeWorkflows"`
	// The name of the project.
	Name string `json:"name"`
	// The visibility of the project, defaults to false (private).
	Public *bool `json:"public,omitempty"`
	// The source project to clone.
	SourceId string `json:"sourceId"`
	// The owner ID to create the project under.
	TargetOwnerId string `json:"targetOwnerId"`
}

// Autogenerated return type of CloneProject.
type CloneProjectPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The id of the JobStatus for populating cloned fields.
	JobStatusId *string `json:"jobStatusId,omitempty"`
	// The new cloned project.
	Project *Project `json:"project,omitempty"`
}

// Autogenerated input type of CloneTemplateRepository
type CloneTemplateRepositoryInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// A short description of the new repository.
	Description *string `json:"description,omitempty"`
	// Whether to copy all branches from the template to the new repository. Defaults
	// to copying only the default branch of the template.
	IncludeAllBranches *bool `json:"includeAllBranches,omitempty"`
	// The name of the new repository.
	Name string `json:"name"`
	// The ID of the owner for the new repository.
	OwnerId string `json:"ownerId"`
	// The Node ID of the template repository.
	RepositoryId string `json:"repositoryId"`
	// Indicates the repository's visibility level.
	Visibility RepositoryVisibility `json:"visibility"`
}

// Autogenerated return type of CloneTemplateRepository.
type CloneTemplateRepositoryPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The new repository.
	Repository *Repository `json:"repository,omitempty"`
}

// An object that can be closed
type Closable struct {
	// Indicates if the object is closed (definition of closed may depend on type)
	Closed bool `json:"closed"`
	// Identifies the date and time when the object was closed.
	ClosedAt *DateTime `json:"closedAt,omitempty"`
	// Indicates if the object can be closed by the viewer.
	ViewerCanClose bool `json:"viewerCanClose"`
	// Indicates if the object can be reopened by the viewer.
	ViewerCanReopen bool `json:"viewerCanReopen"`

	// Underlying value of the GraphQL interface
	Value ClosableValue `json:"-"`
}

func (base *Closable) UnmarshalJSON(b []byte) error {
	type Raw Closable
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Discussion":
		base.Value = new(Discussion)
	case "Issue":
		base.Value = new(Issue)
	case "Milestone":
		base.Value = new(Milestone)
	case "Project":
		base.Value = new(Project)
	case "ProjectV2":
		base.Value = new(ProjectV2)
	case "PullRequest":
		base.Value = new(PullRequest)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface Closable: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// ClosableValue is one of: Discussion | Issue | Milestone | Project | ProjectV2 | PullRequest
type ClosableValue interface {
	isClosable()
}

// Autogenerated input type of CloseDiscussion
type CloseDiscussionInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// ID of the discussion to be closed.
	DiscussionId string `json:"discussionId"`
	// The reason why the discussion is being closed.
	Reason *DiscussionCloseReason `json:"reason,omitempty"`
}

// Autogenerated return type of CloseDiscussion.
type CloseDiscussionPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The discussion that was closed.
	Discussion *Discussion `json:"discussion,omitempty"`
}

// Autogenerated input type of CloseIssue
type CloseIssueInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// ID of the issue that this is a duplicate of.
	DuplicateIssueId string `json:"duplicateIssueId,omitempty"`
	// ID of the issue to be closed.
	IssueId string `json:"issueId"`
	// The reason the issue is to be closed.
	StateReason *IssueClosedStateReason `json:"stateReason,omitempty"`
}

// Autogenerated return type of CloseIssue.
type CloseIssuePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The issue that was closed.
	Issue *Issue `json:"issue,omitempty"`
}

// Autogenerated input type of ClosePullRequest
type ClosePullRequestInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// ID of the pull request to be closed.
	PullRequestId string `json:"pullRequestId"`
}

// Autogenerated return type of ClosePullRequest.
type ClosePullRequestPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The pull request that was closed.
	PullRequest *PullRequest `json:"pullRequest,omitempty"`
}

// Represents a 'closed' event on any `Closable`.
type ClosedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Object that was closed.
	Closable *Closable `json:"closable"`
	// Object which triggered the creation of this event.
	Closer *Closer `json:"closer,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the ClosedEvent object
	Id string `json:"id"`
	// The HTTP path for this closed event.
	ResourcePath URI `json:"resourcePath"`
	// The reason the issue state was changed to closed.
	StateReason *IssueStateReason `json:"stateReason,omitempty"`
	// The HTTP URL for this closed event.
	Url URI `json:"url"`
}

func (*ClosedEvent) isNode() {}

func (*ClosedEvent) isUniformResourceLocatable() {}

func (*ClosedEvent) isIssueTimelineItem() {}

func (*ClosedEvent) isIssueTimelineItems() {}

func (*ClosedEvent) isPullRequestTimelineItem() {}

func (*ClosedEvent) isPullRequestTimelineItems() {}

// The object which triggered a `ClosedEvent`.
type Closer struct {
	// Underlying value of the GraphQL union
	Value CloserValue `json:"-"`
}

func (base *Closer) UnmarshalJSON(b []byte) error {
	type Raw Closer
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Commit":
		base.Value = new(Commit)
	case "ProjectV2":
		base.Value = new(ProjectV2)
	case "PullRequest":
		base.Value = new(PullRequest)
	case "":
		return fmt.Errorf("gqlclient: union Closer: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union Closer: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// CloserValue is one of: Commit | ProjectV2 | PullRequest
type CloserValue interface {
	isCloser()
}

// The Code of Conduct for a repository
type CodeOfConduct struct {
	// The body of the Code of Conduct
	Body *string `json:"body,omitempty"`
	// The Node ID of the CodeOfConduct object
	Id string `json:"id"`
	// The key for the Code of Conduct
	Key string `json:"key"`
	// The formal name of the Code of Conduct
	Name string `json:"name"`
	// The HTTP path for this Code of Conduct
	ResourcePath *URI `json:"resourcePath,omitempty"`
	// The HTTP URL for this Code of Conduct
	Url *URI `json:"url,omitempty"`
}

func (*CodeOfConduct) isNode() {}

// Choose which tools must provide code scanning results before the reference is
// updated. When configured, code scanning must be enabled and have results for
// both the commit and the reference being updated.
type CodeScanningParameters struct {
	// Tools that must provide code scanning results for this rule to pass.
	CodeScanningTools []CodeScanningTool `json:"codeScanningTools"`
}

func (*CodeScanningParameters) isRuleParameters() {}

// Choose which tools must provide code scanning results before the reference is
// updated. When configured, code scanning must be enabled and have results for
// both the commit and the reference being updated.
type CodeScanningParametersInput struct {
	// Tools that must provide code scanning results for this rule to pass.
	CodeScanningTools []CodeScanningToolInput `json:"codeScanningTools"`
}

// A tool that must provide code scanning results for this rule to pass.
type CodeScanningTool struct {
	// The severity level at which code scanning results that raise alerts block a
	// reference update. For more information on alert severity levels, see "[About code scanning alerts](${externalDocsUrl}/code-security/code-scanning/managing-code-scanning-alerts/about-code-scanning-alerts#about-alert-severity-and-security-severity-levels)."
	AlertsThreshold string `json:"alertsThreshold"`
	// The severity level at which code scanning results that raise security alerts
	// block a reference update. For more information on security severity levels,
	// see "[About code scanning alerts](${externalDocsUrl}/code-security/code-scanning/managing-code-scanning-alerts/about-code-scanning-alerts#about-alert-severity-and-security-severity-levels)."
	SecurityAlertsThreshold string `json:"securityAlertsThreshold"`
	// The name of a code scanning tool
	Tool string `json:"tool"`
}

// A tool that must provide code scanning results for this rule to pass.
type CodeScanningToolInput struct {
	// The severity level at which code scanning results that raise alerts block a
	// reference update. For more information on alert severity levels, see "[About code scanning alerts](${externalDocsUrl}/code-security/code-scanning/managing-code-scanning-alerts/about-code-scanning-alerts#about-alert-severity-and-security-severity-levels)."
	AlertsThreshold string `json:"alertsThreshold"`
	// The severity level at which code scanning results that raise security alerts
	// block a reference update. For more information on security severity levels,
	// see "[About code scanning alerts](${externalDocsUrl}/code-security/code-scanning/managing-code-scanning-alerts/about-code-scanning-alerts#about-alert-severity-and-security-severity-levels)."
	SecurityAlertsThreshold string `json:"securityAlertsThreshold"`
	// The name of a code scanning tool
	Tool string `json:"tool"`
}

// Collaborators affiliation level with a subject.
type CollaboratorAffiliation string

const (
	// All collaborators the authenticated user can see.
	CollaboratorAffiliationAll CollaboratorAffiliation = "ALL"
	// All collaborators with permissions to an organization-owned subject, regardless of organization membership status.
	CollaboratorAffiliationDirect CollaboratorAffiliation = "DIRECT"
	// All outside collaborators of an organization-owned subject.
	CollaboratorAffiliationOutside CollaboratorAffiliation = "OUTSIDE"
)

// Represents a comment.
type Comment struct {
	// The actor who authored the comment.
	Author *Actor `json:"author,omitempty"`
	// Author's association with the subject of the comment.
	AuthorAssociation CommentAuthorAssociation `json:"authorAssociation"`
	// The body as Markdown.
	Body string `json:"body"`
	// The body rendered to HTML.
	BodyHTML HTML `json:"bodyHTML"`
	// The body rendered to text.
	BodyText string `json:"bodyText"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Check if this comment was created via an email reply.
	CreatedViaEmail bool `json:"createdViaEmail"`
	// The actor who edited the comment.
	Editor *Actor `json:"editor,omitempty"`
	// The Node ID of the Comment object
	Id string `json:"id"`
	// Check if this comment was edited and includes an edit with the creation data
	IncludesCreatedEdit bool `json:"includesCreatedEdit"`
	// The moment the editor made the last edit
	LastEditedAt *DateTime `json:"lastEditedAt,omitempty"`
	// Identifies when the comment was published at.
	PublishedAt *DateTime `json:"publishedAt,omitempty"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// A list of edits to this content.
	UserContentEdits *UserContentEditConnection `json:"userContentEdits,omitempty"`
	// Did the viewer author this comment.
	ViewerDidAuthor bool `json:"viewerDidAuthor"`

	// Underlying value of the GraphQL interface
	Value CommentValue `json:"-"`
}

func (base *Comment) UnmarshalJSON(b []byte) error {
	type Raw Comment
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "CommitComment":
		base.Value = new(CommitComment)
	case "Discussion":
		base.Value = new(Discussion)
	case "DiscussionComment":
		base.Value = new(DiscussionComment)
	case "GistComment":
		base.Value = new(GistComment)
	case "Issue":
		base.Value = new(Issue)
	case "IssueComment":
		base.Value = new(IssueComment)
	case "PullRequest":
		base.Value = new(PullRequest)
	case "PullRequestReview":
		base.Value = new(PullRequestReview)
	case "PullRequestReviewComment":
		base.Value = new(PullRequestReviewComment)
	case "TeamDiscussion":
		base.Value = new(TeamDiscussion)
	case "TeamDiscussionComment":
		base.Value = new(TeamDiscussionComment)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface Comment: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// CommentValue is one of: CommitComment | Discussion | DiscussionComment | GistComment | Issue | IssueComment | PullRequest | PullRequestReview | PullRequestReviewComment | TeamDiscussion | TeamDiscussionComment
type CommentValue interface {
	isComment()
}

// A comment author association with repository.
type CommentAuthorAssociation string

const (
	// Author has been invited to collaborate on the repository.
	CommentAuthorAssociationCollaborator CommentAuthorAssociation = "COLLABORATOR"
	// Author has previously committed to the repository.
	CommentAuthorAssociationContributor CommentAuthorAssociation = "CONTRIBUTOR"
	// Author has not previously committed to GitHub.
	CommentAuthorAssociationFirstTimer CommentAuthorAssociation = "FIRST_TIMER"
	// Author has not previously committed to the repository.
	CommentAuthorAssociationFirstTimeContributor CommentAuthorAssociation = "FIRST_TIME_CONTRIBUTOR"
	// Author is a placeholder for an unclaimed user.
	CommentAuthorAssociationMannequin CommentAuthorAssociation = "MANNEQUIN"
	// Author is a member of the organization that owns the repository.
	CommentAuthorAssociationMember CommentAuthorAssociation = "MEMBER"
	// Author has no association with the repository.
	CommentAuthorAssociationNone CommentAuthorAssociation = "NONE"
	// Author is the owner of the repository.
	CommentAuthorAssociationOwner CommentAuthorAssociation = "OWNER"
)

// The possible errors that will prevent a user from updating a comment.
type CommentCannotUpdateReason string

const (
	// Unable to create comment because repository is archived.
	CommentCannotUpdateReasonArchived CommentCannotUpdateReason = "ARCHIVED"
	// You cannot update this comment
	CommentCannotUpdateReasonDenied CommentCannotUpdateReason = "DENIED"
	// You must be the author or have write access to this repository to update this comment.
	CommentCannotUpdateReasonInsufficientAccess CommentCannotUpdateReason = "INSUFFICIENT_ACCESS"
	// Unable to create comment because issue is locked.
	CommentCannotUpdateReasonLocked CommentCannotUpdateReason = "LOCKED"
	// You must be logged in to update this comment.
	CommentCannotUpdateReasonLoginRequired CommentCannotUpdateReason = "LOGIN_REQUIRED"
	// Repository is under maintenance.
	CommentCannotUpdateReasonMaintenance CommentCannotUpdateReason = "MAINTENANCE"
	// At least one email address must be verified to update this comment.
	CommentCannotUpdateReasonVerifiedEmailRequired CommentCannotUpdateReason = "VERIFIED_EMAIL_REQUIRED"
)

// Represents a 'comment_deleted' event on a given issue or pull request.
type CommentDeletedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The user who authored the deleted comment.
	DeletedCommentAuthor *Actor `json:"deletedCommentAuthor,omitempty"`
	// The Node ID of the CommentDeletedEvent object
	Id string `json:"id"`
}

func (*CommentDeletedEvent) isNode() {}

func (*CommentDeletedEvent) isIssueTimelineItems() {}

func (*CommentDeletedEvent) isPullRequestTimelineItems() {}

// Represents a Git commit.
type Commit struct {
	// An abbreviated version of the Git object ID
	AbbreviatedOid string `json:"abbreviatedOid"`
	// The number of additions in this commit.
	Additions int32 `json:"additions"`
	// The merged Pull Request that introduced the commit to the repository. If the
	// commit is not present in the default branch, additionally returns open Pull
	// Requests associated with the commit
	AssociatedPullRequests *PullRequestConnection `json:"associatedPullRequests,omitempty"`
	// Authorship details of the commit.
	Author *GitActor `json:"author,omitempty"`
	// Check if the committer and the author match.
	AuthoredByCommitter bool `json:"authoredByCommitter"`
	// The datetime when this commit was authored.
	AuthoredDate DateTime `json:"authoredDate"`
	// The list of authors for this commit based on the git author and the Co-authored-by
	// message trailer. The git author will always be first.
	Authors *GitActorConnection `json:"authors"`
	// Fetches `git blame` information.
	Blame *Blame `json:"blame"`
	// We recommend using the `changedFilesIfAvailable` field instead of
	// `changedFiles`, as `changedFiles` will cause your request to return an error
	// if GitHub is unable to calculate the number of changed files.
	ChangedFiles int32 `json:"changedFiles"`
	// The number of changed files in this commit. If GitHub is unable to calculate
	// the number of changed files (for example due to a timeout), this will return
	// `null`. We recommend using this field instead of `changedFiles`.
	ChangedFilesIfAvailable *int32 `json:"changedFilesIfAvailable,omitempty"`
	// The check suites associated with a commit.
	CheckSuites *CheckSuiteConnection `json:"checkSuites,omitempty"`
	// Comments made on the commit.
	Comments *CommitCommentConnection `json:"comments"`
	// The HTTP path for this Git object
	CommitResourcePath URI `json:"commitResourcePath"`
	// The HTTP URL for this Git object
	CommitUrl URI `json:"commitUrl"`
	// The datetime when this commit was committed.
	CommittedDate DateTime `json:"committedDate"`
	// Check if committed via GitHub web UI.
	CommittedViaWeb bool `json:"committedViaWeb"`
	// Committer details of the commit.
	Committer *GitActor `json:"committer,omitempty"`
	// The number of deletions in this commit.
	Deletions int32 `json:"deletions"`
	// The deployments associated with a commit.
	Deployments *DeploymentConnection `json:"deployments,omitempty"`
	// The tree entry representing the file located at the given path.
	File *TreeEntry `json:"file,omitempty"`
	// The linear commit history starting from (and including) this commit, in the same order as `git log`.
	History *CommitHistoryConnection `json:"history"`
	// The Node ID of the Commit object
	Id string `json:"id"`
	// The Git commit message
	Message string `json:"message"`
	// The Git commit message body
	MessageBody string `json:"messageBody"`
	// The commit message body rendered to HTML.
	MessageBodyHTML HTML `json:"messageBodyHTML"`
	// The Git commit message headline
	MessageHeadline string `json:"messageHeadline"`
	// The commit message headline rendered to HTML.
	MessageHeadlineHTML HTML `json:"messageHeadlineHTML"`
	// The Git object ID
	Oid GitObjectID `json:"oid"`
	// The organization this commit was made on behalf of.
	OnBehalfOf *Organization `json:"onBehalfOf,omitempty"`
	// The parents of a commit.
	Parents *CommitConnection `json:"parents"`
	// The datetime when this commit was pushed.
	PushedDate *DateTime `json:"pushedDate,omitempty"`
	// The Repository this commit belongs to
	Repository *Repository `json:"repository"`
	// The HTTP path for this commit
	ResourcePath URI `json:"resourcePath"`
	// Commit signing information, if present.
	Signature *GitSignature `json:"signature,omitempty"`
	// Status information for this commit
	Status *Status `json:"status,omitempty"`
	// Check and Status rollup information for this commit.
	StatusCheckRollup *StatusCheckRollup `json:"statusCheckRollup,omitempty"`
	// Returns a list of all submodules in this repository as of this Commit parsed from the .gitmodules file.
	Submodules *SubmoduleConnection `json:"submodules"`
	// Returns a URL to download a tarball archive for a repository.
	// Note: For private repositories, these links are temporary and expire after five minutes.
	TarballUrl URI `json:"tarballUrl"`
	// Commit's root Tree
	Tree *Tree `json:"tree"`
	// The HTTP path for the tree of this commit
	TreeResourcePath URI `json:"treeResourcePath"`
	// The HTTP URL for the tree of this commit
	TreeUrl URI `json:"treeUrl"`
	// The HTTP URL for this commit
	Url URI `json:"url"`
	// Check if the viewer is able to change their subscription status for the repository.
	ViewerCanSubscribe bool `json:"viewerCanSubscribe"`
	// Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
	ViewerSubscription *SubscriptionState `json:"viewerSubscription,omitempty"`
	// Returns a URL to download a zipball archive for a repository.
	// Note: For private repositories, these links are temporary and expire after five minutes.
	ZipballUrl URI `json:"zipballUrl"`
}

func (*Commit) isCloser() {}

func (*Commit) isGitObject() {}

func (*Commit) isNode() {}

func (*Commit) isSubscribable() {}

func (*Commit) isUniformResourceLocatable() {}

func (*Commit) isIssueTimelineItem() {}

func (*Commit) isPullRequestTimelineItem() {}

// Specifies an author for filtering Git commits.
type CommitAuthor struct {
	// Email addresses to filter by. Commits authored by any of the specified email addresses will be returned.
	Emails []string `json:"emails,omitempty"`
	// ID of a User to filter by. If non-null, only commits authored by this user
	// will be returned. This field takes precedence over emails.
	Id string `json:"id,omitempty"`
}

// Parameters to be used for the commit_author_email_pattern rule
type CommitAuthorEmailPatternParameters struct {
	// How this rule will appear to users.
	Name *string `json:"name,omitempty"`
	// If true, the rule will fail if the pattern matches.
	Negate bool `json:"negate"`
	// The operator to use for matching.
	Operator string `json:"operator"`
	// The pattern to match with.
	Pattern string `json:"pattern"`
}

func (*CommitAuthorEmailPatternParameters) isRuleParameters() {}

// Parameters to be used for the commit_author_email_pattern rule
type CommitAuthorEmailPatternParametersInput struct {
	// How this rule will appear to users.
	Name *string `json:"name,omitempty"`
	// If true, the rule will fail if the pattern matches.
	Negate *bool `json:"negate,omitempty"`
	// The operator to use for matching.
	Operator string `json:"operator"`
	// The pattern to match with.
	Pattern string `json:"pattern"`
}

// Represents a comment on a given Commit.
type CommitComment struct {
	// The actor who authored the comment.
	Author *Actor `json:"author,omitempty"`
	// Author's association with the subject of the comment.
	AuthorAssociation CommentAuthorAssociation `json:"authorAssociation"`
	// Identifies the comment body.
	Body string `json:"body"`
	// The body rendered to HTML.
	BodyHTML HTML `json:"bodyHTML"`
	// The body rendered to text.
	BodyText string `json:"bodyText"`
	// Identifies the commit associated with the comment, if the commit exists.
	Commit *Commit `json:"commit,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Check if this comment was created via an email reply.
	CreatedViaEmail bool `json:"createdViaEmail"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The actor who edited the comment.
	Editor *Actor `json:"editor,omitempty"`
	// The Node ID of the CommitComment object
	Id string `json:"id"`
	// Check if this comment was edited and includes an edit with the creation data
	IncludesCreatedEdit bool `json:"includesCreatedEdit"`
	// Returns whether or not a comment has been minimized.
	IsMinimized bool `json:"isMinimized"`
	// The moment the editor made the last edit
	LastEditedAt *DateTime `json:"lastEditedAt,omitempty"`
	// Returns why the comment was minimized. One of `abuse`, `off-topic`,
	// `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
	// formatting of these values differs from the inputs to the `MinimizeComment` mutation.
	MinimizedReason *string `json:"minimizedReason,omitempty"`
	// Identifies the file path associated with the comment.
	Path *string `json:"path,omitempty"`
	// Identifies the line position associated with the comment.
	Position *int32 `json:"position,omitempty"`
	// Identifies when the comment was published at.
	PublishedAt *DateTime `json:"publishedAt,omitempty"`
	// A list of reactions grouped by content left on the subject.
	ReactionGroups []ReactionGroup `json:"reactionGroups,omitempty"`
	// A list of Reactions left on the Issue.
	Reactions *ReactionConnection `json:"reactions"`
	// The repository associated with this node.
	Repository *Repository `json:"repository"`
	// The HTTP path permalink for this commit comment.
	ResourcePath URI `json:"resourcePath"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The HTTP URL permalink for this commit comment.
	Url URI `json:"url"`
	// A list of edits to this content.
	UserContentEdits *UserContentEditConnection `json:"userContentEdits,omitempty"`
	// Check if the current viewer can delete this object.
	ViewerCanDelete bool `json:"viewerCanDelete"`
	// Check if the current viewer can minimize this object.
	ViewerCanMinimize bool `json:"viewerCanMinimize"`
	// Can user react to this subject
	ViewerCanReact bool `json:"viewerCanReact"`
	// Check if the current viewer can update this object.
	ViewerCanUpdate bool `json:"viewerCanUpdate"`
	// Reasons why the current viewer can not update this comment.
	ViewerCannotUpdateReasons []CommentCannotUpdateReason `json:"viewerCannotUpdateReasons"`
	// Did the viewer author this comment.
	ViewerDidAuthor bool `json:"viewerDidAuthor"`
}

func (*CommitComment) isComment() {}

func (*CommitComment) isDeletable() {}

func (*CommitComment) isMinimizable() {}

func (*CommitComment) isNode() {}

func (*CommitComment) isReactable() {}

func (*CommitComment) isRepositoryNode() {}

func (*CommitComment) isUpdatable() {}

func (*CommitComment) isUpdatableComment() {}

// The connection type for CommitComment.
type CommitCommentConnection struct {
	// A list of edges.
	Edges []*CommitCommentEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*CommitComment `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type CommitCommentEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *CommitComment `json:"node,omitempty"`
}

// A thread of comments on a commit.
type CommitCommentThread struct {
	// The comments that exist in this thread.
	Comments *CommitCommentConnection `json:"comments"`
	// The commit the comments were made on.
	Commit *Commit `json:"commit,omitempty"`
	// The Node ID of the CommitCommentThread object
	Id string `json:"id"`
	// The file the comments were made on.
	Path *string `json:"path,omitempty"`
	// The position in the diff for the commit that the comment was made on.
	Position *int32 `json:"position,omitempty"`
	// The repository associated with this node.
	Repository *Repository `json:"repository"`
}

func (*CommitCommentThread) isNode() {}

func (*CommitCommentThread) isRepositoryNode() {}

func (*CommitCommentThread) isPullRequestTimelineItem() {}

// The connection type for Commit.
type CommitConnection struct {
	// A list of edges.
	Edges []*CommitEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*Commit `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// Ordering options for commit contribution connections.
type CommitContributionOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order commit contributions.
	Field CommitContributionOrderField `json:"field"`
}

// Properties by which commit contribution connections can be ordered.
type CommitContributionOrderField string

const (
	// Order commit contributions by how many commits they represent.
	CommitContributionOrderFieldCommitCount CommitContributionOrderField = "COMMIT_COUNT"
	// Order commit contributions by when they were made.
	CommitContributionOrderFieldOccurredAt CommitContributionOrderField = "OCCURRED_AT"
)

// This aggregates commits made by a user within one repository.
type CommitContributionsByRepository struct {
	// The commit contributions, each representing a day.
	Contributions *CreatedCommitContributionConnection `json:"contributions"`
	// The repository in which the commits were made.
	Repository *Repository `json:"repository"`
	// The HTTP path for the user's commits to the repository in this time range.
	ResourcePath URI `json:"resourcePath"`
	// The HTTP URL for the user's commits to the repository in this time range.
	Url URI `json:"url"`
}

// An edge in a connection.
type CommitEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *Commit `json:"node,omitempty"`
}

// The connection type for Commit.
type CommitHistoryConnection struct {
	// A list of edges.
	Edges []*CommitEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*Commit `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// A message to include with a new commit
type CommitMessage struct {
	// The body of the message.
	Body *string `json:"body,omitempty"`
	// The headline of the message.
	Headline string `json:"headline"`
}

// Parameters to be used for the commit_message_pattern rule
type CommitMessagePatternParameters struct {
	// How this rule will appear to users.
	Name *string `json:"name,omitempty"`
	// If true, the rule will fail if the pattern matches.
	Negate bool `json:"negate"`
	// The operator to use for matching.
	Operator string `json:"operator"`
	// The pattern to match with.
	Pattern string `json:"pattern"`
}

func (*CommitMessagePatternParameters) isRuleParameters() {}

// Parameters to be used for the commit_message_pattern rule
type CommitMessagePatternParametersInput struct {
	// How this rule will appear to users.
	Name *string `json:"name,omitempty"`
	// If true, the rule will fail if the pattern matches.
	Negate *bool `json:"negate,omitempty"`
	// The operator to use for matching.
	Operator string `json:"operator"`
	// The pattern to match with.
	Pattern string `json:"pattern"`
}

// A git ref for a commit to be appended to.
//
// The ref must be a branch, i.e. its fully qualified name must start
// with `refs/heads/` (although the input is not required to be fully
// qualified).
//
// The Ref may be specified by its global node ID or by the
// `repositoryNameWithOwner` and `branchName`.
//
// ### Examples
//
// Specify a branch using a global node ID:
//
//     { "id": "MDM6UmVmMTpyZWZzL2hlYWRzL21haW4=" }
//
// Specify a branch using `repositoryNameWithOwner` and `branchName`:
//
//     {
//       "repositoryNameWithOwner": "github/graphql-client",
//       "branchName": "main"
//     }
type CommittableBranch struct {
	// The unqualified name of the branch to append the commit to.
	BranchName *string `json:"branchName,omitempty"`
	// The Node ID of the Ref to be updated.
	Id string `json:"id,omitempty"`
	// The nameWithOwner of the repository to commit to.
	RepositoryNameWithOwner *string `json:"repositoryNameWithOwner,omitempty"`
}

// Parameters to be used for the committer_email_pattern rule
type CommitterEmailPatternParameters struct {
	// How this rule will appear to users.
	Name *string `json:"name,omitempty"`
	// If true, the rule will fail if the pattern matches.
	Negate bool `json:"negate"`
	// The operator to use for matching.
	Operator string `json:"operator"`
	// The pattern to match with.
	Pattern string `json:"pattern"`
}

func (*CommitterEmailPatternParameters) isRuleParameters() {}

// Parameters to be used for the committer_email_pattern rule
type CommitterEmailPatternParametersInput struct {
	// How this rule will appear to users.
	Name *string `json:"name,omitempty"`
	// If true, the rule will fail if the pattern matches.
	Negate *bool `json:"negate,omitempty"`
	// The operator to use for matching.
	Operator string `json:"operator"`
	// The pattern to match with.
	Pattern string `json:"pattern"`
}

// Represents a comparison between two commit revisions.
type Comparison struct {
	// The number of commits ahead of the base branch.
	AheadBy int32 `json:"aheadBy"`
	// The base revision of this comparison.
	BaseTarget *GitObject `json:"baseTarget"`
	// The number of commits behind the base branch.
	BehindBy int32 `json:"behindBy"`
	// The commits which compose this comparison.
	Commits *ComparisonCommitConnection `json:"commits"`
	// The head revision of this comparison.
	HeadTarget *GitObject `json:"headTarget"`
	// The Node ID of the Comparison object
	Id string `json:"id"`
	// The status of this comparison.
	Status ComparisonStatus `json:"status"`
}

func (*Comparison) isNode() {}

// The connection type for Commit.
type ComparisonCommitConnection struct {
	// The total count of authors and co-authors across all commits.
	AuthorCount int32 `json:"authorCount"`
	// A list of edges.
	Edges []*CommitEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*Commit `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// The status of a git comparison between two refs.
type ComparisonStatus string

const (
	// The head ref is ahead of the base ref.
	ComparisonStatusAhead ComparisonStatus = "AHEAD"
	// The head ref is behind the base ref.
	ComparisonStatusBehind ComparisonStatus = "BEHIND"
	// The head ref is both ahead and behind of the base ref, indicating git history has diverged.
	ComparisonStatusDiverged ComparisonStatus = "DIVERGED"
	// The head ref and base ref are identical.
	ComparisonStatusIdentical ComparisonStatus = "IDENTICAL"
)

// Represents a 'connected' event on a given issue or pull request.
type ConnectedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the ConnectedEvent object
	Id string `json:"id"`
	// Reference originated in a different repository.
	IsCrossRepository bool `json:"isCrossRepository"`
	// Issue or pull request that made the reference.
	Source ReferencedSubject `json:"source"`
	// Issue or pull request which was connected.
	Subject ReferencedSubject `json:"subject"`
}

func (*ConnectedEvent) isNode() {}

func (*ConnectedEvent) isIssueTimelineItems() {}

func (*ConnectedEvent) isPullRequestTimelineItems() {}

// The Contributing Guidelines for a repository.
type ContributingGuidelines struct {
	// The body of the Contributing Guidelines.
	Body *string `json:"body,omitempty"`
	// The HTTP path for the Contributing Guidelines.
	ResourcePath *URI `json:"resourcePath,omitempty"`
	// The HTTP URL for the Contributing Guidelines.
	Url *URI `json:"url,omitempty"`
}

// Represents a contribution a user made on GitHub, such as opening an issue.
type Contribution struct {
	// Whether this contribution is associated with a record you do not have access to. For
	// example, your own 'first issue' contribution may have been made on a repository you can no
	// longer access.
	IsRestricted bool `json:"isRestricted"`
	// When this contribution was made.
	OccurredAt DateTime `json:"occurredAt"`
	// The HTTP path for this contribution.
	ResourcePath URI `json:"resourcePath"`
	// The HTTP URL for this contribution.
	Url URI `json:"url"`
	// The user who made this contribution.
	User *User `json:"user"`

	// Underlying value of the GraphQL interface
	Value ContributionValue `json:"-"`
}

func (base *Contribution) UnmarshalJSON(b []byte) error {
	type Raw Contribution
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "CreatedCommitContribution":
		base.Value = new(CreatedCommitContribution)
	case "CreatedIssueContribution":
		base.Value = new(CreatedIssueContribution)
	case "CreatedPullRequestContribution":
		base.Value = new(CreatedPullRequestContribution)
	case "CreatedPullRequestReviewContribution":
		base.Value = new(CreatedPullRequestReviewContribution)
	case "CreatedRepositoryContribution":
		base.Value = new(CreatedRepositoryContribution)
	case "JoinedGitHubContribution":
		base.Value = new(JoinedGitHubContribution)
	case "RestrictedContribution":
		base.Value = new(RestrictedContribution)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface Contribution: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// ContributionValue is one of: CreatedCommitContribution | CreatedIssueContribution | CreatedPullRequestContribution | CreatedPullRequestReviewContribution | CreatedRepositoryContribution | JoinedGitHubContribution | RestrictedContribution
type ContributionValue interface {
	isContribution()
}

// A calendar of contributions made on GitHub by a user.
type ContributionCalendar struct {
	// A list of hex color codes used in this calendar. The darker the color, the more contributions it represents.
	Colors []string `json:"colors"`
	// Determine if the color set was chosen because it's currently Halloween.
	IsHalloween bool `json:"isHalloween"`
	// A list of the months of contributions in this calendar.
	Months []ContributionCalendarMonth `json:"months"`
	// The count of total contributions in the calendar.
	TotalContributions int32 `json:"totalContributions"`
	// A list of the weeks of contributions in this calendar.
	Weeks []ContributionCalendarWeek `json:"weeks"`
}

// Represents a single day of contributions on GitHub by a user.
type ContributionCalendarDay struct {
	// The hex color code that represents how many contributions were made on this day compared to others in the calendar.
	Color string `json:"color"`
	// How many contributions were made by the user on this day.
	ContributionCount int32 `json:"contributionCount"`
	// Indication of contributions, relative to other days. Can be used to indicate
	// which color to represent this day on a calendar.
	ContributionLevel ContributionLevel `json:"contributionLevel"`
	// The day this square represents.
	Date Date `json:"date"`
	// A number representing which day of the week this square represents, e.g., 1 is Monday.
	Weekday int32 `json:"weekday"`
}

// A month of contributions in a user's contribution graph.
type ContributionCalendarMonth struct {
	// The date of the first day of this month.
	FirstDay Date `json:"firstDay"`
	// The name of the month.
	Name string `json:"name"`
	// How many weeks started in this month.
	TotalWeeks int32 `json:"totalWeeks"`
	// The year the month occurred in.
	Year int32 `json:"year"`
}

// A week of contributions in a user's contribution graph.
type ContributionCalendarWeek struct {
	// The days of contributions in this week.
	ContributionDays []ContributionCalendarDay `json:"contributionDays"`
	// The date of the earliest square in this week.
	FirstDay Date `json:"firstDay"`
}

// Varying levels of contributions from none to many.
type ContributionLevel string

const (
	// Lowest 25% of days of contributions.
	ContributionLevelFirstQuartile ContributionLevel = "FIRST_QUARTILE"
	// Highest 25% of days of contributions. More contributions than the third quartile.
	ContributionLevelFourthQuartile ContributionLevel = "FOURTH_QUARTILE"
	// No contributions occurred.
	ContributionLevelNone ContributionLevel = "NONE"
	// Second lowest 25% of days of contributions. More contributions than the first quartile.
	ContributionLevelSecondQuartile ContributionLevel = "SECOND_QUARTILE"
	// Second highest 25% of days of contributions. More contributions than second quartile, less than the fourth quartile.
	ContributionLevelThirdQuartile ContributionLevel = "THIRD_QUARTILE"
)

// Ordering options for contribution connections.
type ContributionOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
}

// A contributions collection aggregates contributions such as opened issues and commits created by a user.
type ContributionsCollection struct {
	// Commit contributions made by the user, grouped by repository.
	CommitContributionsByRepository []CommitContributionsByRepository `json:"commitContributionsByRepository"`
	// A calendar of this user's contributions on GitHub.
	ContributionCalendar *ContributionCalendar `json:"contributionCalendar"`
	// The years the user has been making contributions with the most recent year first.
	ContributionYears []int32 `json:"contributionYears"`
	// Determine if this collection's time span ends in the current month.
	DoesEndInCurrentMonth bool `json:"doesEndInCurrentMonth"`
	// The date of the first restricted contribution the user made in this time
	// period. Can only be non-null when the user has enabled private contribution counts.
	EarliestRestrictedContributionDate *Date `json:"earliestRestrictedContributionDate,omitempty"`
	// The ending date and time of this collection.
	EndedAt DateTime `json:"endedAt"`
	// The first issue the user opened on GitHub. This will be null if that issue was
	// opened outside the collection's time range and ignoreTimeRange is false. If
	// the issue is not visible but the user has opted to show private contributions,
	// a RestrictedContribution will be returned.
	FirstIssueContribution *CreatedIssueOrRestrictedContribution `json:"firstIssueContribution,omitempty"`
	// The first pull request the user opened on GitHub. This will be null if that
	// pull request was opened outside the collection's time range and
	// ignoreTimeRange is not true. If the pull request is not visible but the user
	// has opted to show private contributions, a RestrictedContribution will be returned.
	FirstPullRequestContribution *CreatedPullRequestOrRestrictedContribution `json:"firstPullRequestContribution,omitempty"`
	// The first repository the user created on GitHub. This will be null if that
	// first repository was created outside the collection's time range and
	// ignoreTimeRange is false. If the repository is not visible, then a
	// RestrictedContribution is returned.
	FirstRepositoryContribution *CreatedRepositoryOrRestrictedContribution `json:"firstRepositoryContribution,omitempty"`
	// Does the user have any more activity in the timeline that occurred prior to the collection's time range?
	HasActivityInThePast bool `json:"hasActivityInThePast"`
	// Determine if there are any contributions in this collection.
	HasAnyContributions bool `json:"hasAnyContributions"`
	// Determine if the user made any contributions in this time frame whose details
	// are not visible because they were made in a private repository. Can only be
	// true if the user enabled private contribution counts.
	HasAnyRestrictedContributions bool `json:"hasAnyRestrictedContributions"`
	// Whether or not the collector's time span is all within the same day.
	IsSingleDay bool `json:"isSingleDay"`
	// A list of issues the user opened.
	IssueContributions *CreatedIssueContributionConnection `json:"issueContributions"`
	// Issue contributions made by the user, grouped by repository.
	IssueContributionsByRepository []IssueContributionsByRepository `json:"issueContributionsByRepository"`
	// When the user signed up for GitHub. This will be null if that sign up date
	// falls outside the collection's time range and ignoreTimeRange is false.
	JoinedGitHubContribution *JoinedGitHubContribution `json:"joinedGitHubContribution,omitempty"`
	// The date of the most recent restricted contribution the user made in this time
	// period. Can only be non-null when the user has enabled private contribution counts.
	LatestRestrictedContributionDate *Date `json:"latestRestrictedContributionDate,omitempty"`
	// When this collection's time range does not include any activity from the user, use this
	// to get a different collection from an earlier time range that does have activity.
	MostRecentCollectionWithActivity *ContributionsCollection `json:"mostRecentCollectionWithActivity,omitempty"`
	// Returns a different contributions collection from an earlier time range than this one
	// that does not have any contributions.
	MostRecentCollectionWithoutActivity *ContributionsCollection `json:"mostRecentCollectionWithoutActivity,omitempty"`
	// The issue the user opened on GitHub that received the most comments in the specified
	// time frame.
	PopularIssueContribution *CreatedIssueContribution `json:"popularIssueContribution,omitempty"`
	// The pull request the user opened on GitHub that received the most comments in the
	// specified time frame.
	PopularPullRequestContribution *CreatedPullRequestContribution `json:"popularPullRequestContribution,omitempty"`
	// Pull request contributions made by the user.
	PullRequestContributions *CreatedPullRequestContributionConnection `json:"pullRequestContributions"`
	// Pull request contributions made by the user, grouped by repository.
	PullRequestContributionsByRepository []PullRequestContributionsByRepository `json:"pullRequestContributionsByRepository"`
	// Pull request review contributions made by the user. Returns the most recently
	// submitted review for each PR reviewed by the user.
	PullRequestReviewContributions *CreatedPullRequestReviewContributionConnection `json:"pullRequestReviewContributions"`
	// Pull request review contributions made by the user, grouped by repository.
	PullRequestReviewContributionsByRepository []PullRequestReviewContributionsByRepository `json:"pullRequestReviewContributionsByRepository"`
	// A list of repositories owned by the user that the user created in this time range.
	RepositoryContributions *CreatedRepositoryContributionConnection `json:"repositoryContributions"`
	// A count of contributions made by the user that the viewer cannot access. Only
	// non-zero when the user has chosen to share their private contribution counts.
	RestrictedContributionsCount int32 `json:"restrictedContributionsCount"`
	// The beginning date and time of this collection.
	StartedAt DateTime `json:"startedAt"`
	// How many commits were made by the user in this time span.
	TotalCommitContributions int32 `json:"totalCommitContributions"`
	// How many issues the user opened.
	TotalIssueContributions int32 `json:"totalIssueContributions"`
	// How many pull requests the user opened.
	TotalPullRequestContributions int32 `json:"totalPullRequestContributions"`
	// How many pull request reviews the user left.
	TotalPullRequestReviewContributions int32 `json:"totalPullRequestReviewContributions"`
	// How many different repositories the user committed to.
	TotalRepositoriesWithContributedCommits int32 `json:"totalRepositoriesWithContributedCommits"`
	// How many different repositories the user opened issues in.
	TotalRepositoriesWithContributedIssues int32 `json:"totalRepositoriesWithContributedIssues"`
	// How many different repositories the user left pull request reviews in.
	TotalRepositoriesWithContributedPullRequestReviews int32 `json:"totalRepositoriesWithContributedPullRequestReviews"`
	// How many different repositories the user opened pull requests in.
	TotalRepositoriesWithContributedPullRequests int32 `json:"totalRepositoriesWithContributedPullRequests"`
	// How many repositories the user created.
	TotalRepositoryContributions int32 `json:"totalRepositoryContributions"`
	// The user who made the contributions in this collection.
	User *User `json:"user"`
}

// Autogenerated input type of ConvertProjectCardNoteToIssue
type ConvertProjectCardNoteToIssueInput struct {
	// The body of the newly created issue.
	Body *string `json:"body,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ProjectCard ID to convert.
	ProjectCardId string `json:"projectCardId"`
	// The ID of the repository to create the issue in.
	RepositoryId string `json:"repositoryId"`
	// The title of the newly created issue. Defaults to the card's note text.
	Title *string `json:"title,omitempty"`
}

// Autogenerated return type of ConvertProjectCardNoteToIssue.
type ConvertProjectCardNoteToIssuePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The updated ProjectCard.
	ProjectCard *ProjectCard `json:"projectCard,omitempty"`
}

// Autogenerated input type of ConvertProjectV2DraftIssueItemToIssue
type ConvertProjectV2DraftIssueItemToIssueInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the draft issue ProjectV2Item to convert.
	ItemId string `json:"itemId"`
	// The ID of the repository to create the issue in.
	RepositoryId string `json:"repositoryId"`
}

// Autogenerated return type of ConvertProjectV2DraftIssueItemToIssue.
type ConvertProjectV2DraftIssueItemToIssuePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The updated project item.
	Item *ProjectV2Item `json:"item,omitempty"`
}

// Autogenerated input type of ConvertPullRequestToDraft
type ConvertPullRequestToDraftInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// ID of the pull request to convert to draft
	PullRequestId string `json:"pullRequestId"`
}

// Autogenerated return type of ConvertPullRequestToDraft.
type ConvertPullRequestToDraftPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The pull request that is now a draft.
	PullRequest *PullRequest `json:"pullRequest,omitempty"`
}

// Represents a 'convert_to_draft' event on a given pull request.
type ConvertToDraftEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the ConvertToDraftEvent object
	Id string `json:"id"`
	// PullRequest referenced by event.
	PullRequest *PullRequest `json:"pullRequest"`
	// The HTTP path for this convert to draft event.
	ResourcePath URI `json:"resourcePath"`
	// The HTTP URL for this convert to draft event.
	Url URI `json:"url"`
}

func (*ConvertToDraftEvent) isNode() {}

func (*ConvertToDraftEvent) isUniformResourceLocatable() {}

func (*ConvertToDraftEvent) isPullRequestTimelineItems() {}

// Represents a 'converted_note_to_issue' event on a given issue or pull request.
type ConvertedNoteToIssueEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The Node ID of the ConvertedNoteToIssueEvent object
	Id string `json:"id"`
	// Project referenced by event.
	Project *Project `json:"project,omitempty"`
	// Project card referenced by this project event.
	ProjectCard *ProjectCard `json:"projectCard,omitempty"`
	// Column name referenced by this project event.
	ProjectColumnName string `json:"projectColumnName"`
}

func (*ConvertedNoteToIssueEvent) isNode() {}

func (*ConvertedNoteToIssueEvent) isIssueTimelineItems() {}

func (*ConvertedNoteToIssueEvent) isPullRequestTimelineItems() {}

// Represents a 'converted_to_discussion' event on a given issue.
type ConvertedToDiscussionEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The discussion that the issue was converted into.
	Discussion *Discussion `json:"discussion,omitempty"`
	// The Node ID of the ConvertedToDiscussionEvent object
	Id string `json:"id"`
}

func (*ConvertedToDiscussionEvent) isNode() {}

func (*ConvertedToDiscussionEvent) isIssueTimelineItems() {}

func (*ConvertedToDiscussionEvent) isPullRequestTimelineItems() {}

// Copilot endpoint information
type CopilotEndpoints struct {
	// Copilot API endpoint
	Api string `json:"api"`
	// Copilot origin tracker endpoint
	OriginTracker string `json:"originTracker"`
	// Copilot proxy endpoint
	Proxy string `json:"proxy"`
	// Copilot telemetry endpoint
	Telemetry string `json:"telemetry"`
}

// Autogenerated input type of CopyProjectV2
type CopyProjectV2Input struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Include draft issues in the new project
	IncludeDraftIssues *bool `json:"includeDraftIssues,omitempty"`
	// The owner ID of the new project.
	OwnerId string `json:"ownerId"`
	// The ID of the source Project to copy.
	ProjectId string `json:"projectId"`
	// The title of the project.
	Title string `json:"title"`
}

// Autogenerated return type of CopyProjectV2.
type CopyProjectV2Payload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The copied project.
	ProjectV2 *ProjectV2 `json:"projectV2,omitempty"`
}

// Autogenerated input type of CreateAttributionInvitation
type CreateAttributionInvitationInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Node ID of the owner scoping the reattributable data.
	OwnerId string `json:"ownerId"`
	// The Node ID of the account owning the data to reattribute.
	SourceId string `json:"sourceId"`
	// The Node ID of the account which may claim the data.
	TargetId string `json:"targetId"`
}

// Autogenerated return type of CreateAttributionInvitation.
type CreateAttributionInvitationPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The owner scoping the reattributable data.
	Owner *Organization `json:"owner,omitempty"`
	// The account owning the data to reattribute.
	Source *Claimable `json:"source,omitempty"`
	// The account which may claim the data.
	Target *Claimable `json:"target,omitempty"`
}

// Autogenerated input type of CreateBranchProtectionRule
type CreateBranchProtectionRuleInput struct {
	// Can this branch be deleted.
	AllowsDeletions *bool `json:"allowsDeletions,omitempty"`
	// Are force pushes allowed on this branch.
	AllowsForcePushes *bool `json:"allowsForcePushes,omitempty"`
	// Is branch creation a protected operation.
	BlocksCreations *bool `json:"blocksCreations,omitempty"`
	// A list of User, Team, or App IDs allowed to bypass force push targeting matching branches.
	BypassForcePushActorIds []string `json:"bypassForcePushActorIds,omitempty"`
	// A list of User, Team, or App IDs allowed to bypass pull requests targeting matching branches.
	BypassPullRequestActorIds []string `json:"bypassPullRequestActorIds,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Will new commits pushed to matching branches dismiss pull request review approvals.
	DismissesStaleReviews *bool `json:"dismissesStaleReviews,omitempty"`
	// Can admins override branch protection.
	IsAdminEnforced *bool `json:"isAdminEnforced,omitempty"`
	// Whether users can pull changes from upstream when the branch is locked. Set to
	// `true` to allow fork syncing. Set to `false` to prevent fork syncing.
	LockAllowsFetchAndMerge *bool `json:"lockAllowsFetchAndMerge,omitempty"`
	// Whether to set the branch as read-only. If this is true, users will not be able to push to the branch.
	LockBranch *bool `json:"lockBranch,omitempty"`
	// The glob-like pattern used to determine matching branches.
	Pattern string `json:"pattern"`
	// A list of User, Team, or App IDs allowed to push to matching branches.
	PushActorIds []string `json:"pushActorIds,omitempty"`
	// The global relay id of the repository in which a new branch protection rule should be created in.
	RepositoryId string `json:"repositoryId"`
	// Whether the most recent push must be approved by someone other than the person who pushed it
	RequireLastPushApproval *bool `json:"requireLastPushApproval,omitempty"`
	// Number of approving reviews required to update matching branches.
	RequiredApprovingReviewCount *int32 `json:"requiredApprovingReviewCount,omitempty"`
	// The list of required deployment environments
	RequiredDeploymentEnvironments []string `json:"requiredDeploymentEnvironments,omitempty"`
	// List of required status check contexts that must pass for commits to be accepted to matching branches.
	RequiredStatusCheckContexts []string `json:"requiredStatusCheckContexts,omitempty"`
	// The list of required status checks
	RequiredStatusChecks []RequiredStatusCheckInput `json:"requiredStatusChecks,omitempty"`
	// Are approving reviews required to update matching branches.
	RequiresApprovingReviews *bool `json:"requiresApprovingReviews,omitempty"`
	// Are reviews from code owners required to update matching branches.
	RequiresCodeOwnerReviews *bool `json:"requiresCodeOwnerReviews,omitempty"`
	// Are commits required to be signed.
	RequiresCommitSignatures *bool `json:"requiresCommitSignatures,omitempty"`
	// Are conversations required to be resolved before merging.
	RequiresConversationResolution *bool `json:"requiresConversationResolution,omitempty"`
	// Are successful deployments required before merging.
	RequiresDeployments *bool `json:"requiresDeployments,omitempty"`
	// Are merge commits prohibited from being pushed to this branch.
	RequiresLinearHistory *bool `json:"requiresLinearHistory,omitempty"`
	// Are status checks required to update matching branches.
	RequiresStatusChecks *bool `json:"requiresStatusChecks,omitempty"`
	// Are branches required to be up to date before merging.
	RequiresStrictStatusChecks *bool `json:"requiresStrictStatusChecks,omitempty"`
	// Is pushing to matching branches restricted.
	RestrictsPushes *bool `json:"restrictsPushes,omitempty"`
	// Is dismissal of pull request reviews restricted.
	RestrictsReviewDismissals *bool `json:"restrictsReviewDismissals,omitempty"`
	// A list of User, Team, or App IDs allowed to dismiss reviews on pull requests targeting matching branches.
	ReviewDismissalActorIds []string `json:"reviewDismissalActorIds,omitempty"`
}

// Autogenerated return type of CreateBranchProtectionRule.
type CreateBranchProtectionRulePayload struct {
	// The newly created BranchProtectionRule.
	BranchProtectionRule *BranchProtectionRule `json:"branchProtectionRule,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
}

// Autogenerated input type of CreateCheckRun
type CreateCheckRunInput struct {
	// Possible further actions the integrator can perform, which a user may trigger.
	Actions []CheckRunAction `json:"actions,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The time that the check run finished.
	CompletedAt *DateTime `json:"completedAt,omitempty"`
	// The final conclusion of the check.
	Conclusion *CheckConclusionState `json:"conclusion,omitempty"`
	// The URL of the integrator's site that has the full details of the check.
	DetailsUrl *URI `json:"detailsUrl,omitempty"`
	// A reference for the run on the integrator's system.
	ExternalId *string `json:"externalId,omitempty"`
	// The SHA of the head commit.
	HeadSha GitObjectID `json:"headSha"`
	// The name of the check.
	Name string `json:"name"`
	// Descriptive details about the run.
	Output *CheckRunOutput `json:"output,omitempty"`
	// The node ID of the repository.
	RepositoryId string `json:"repositoryId"`
	// The time that the check run began.
	StartedAt *DateTime `json:"startedAt,omitempty"`
	// The current status.
	Status *RequestableCheckStatusState `json:"status,omitempty"`
}

// Autogenerated return type of CreateCheckRun.
type CreateCheckRunPayload struct {
	// The newly created check run.
	CheckRun *CheckRun `json:"checkRun,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
}

// Autogenerated input type of CreateCheckSuite
type CreateCheckSuiteInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The SHA of the head commit.
	HeadSha GitObjectID `json:"headSha"`
	// The Node ID of the repository.
	RepositoryId string `json:"repositoryId"`
}

// Autogenerated return type of CreateCheckSuite.
type CreateCheckSuitePayload struct {
	// The newly created check suite.
	CheckSuite *CheckSuite `json:"checkSuite,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
}

// Autogenerated input type of CreateCommitOnBranch
type CreateCommitOnBranchInput struct {
	// The Ref to be updated.  Must be a branch.
	Branch CommittableBranch `json:"branch"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The git commit oid expected at the head of the branch prior to the commit
	ExpectedHeadOid GitObjectID `json:"expectedHeadOid"`
	// A description of changes to files in this commit.
	FileChanges *FileChanges `json:"fileChanges,omitempty"`
	// The commit message the be included with the commit.
	Message CommitMessage `json:"message"`
}

// Autogenerated return type of CreateCommitOnBranch.
type CreateCommitOnBranchPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The new commit.
	Commit *Commit `json:"commit,omitempty"`
	// The ref which has been updated to point to the new commit.
	Ref *Ref `json:"ref,omitempty"`
}

// Autogenerated input type of CreateDeployment
type CreateDeploymentInput struct {
	// Attempt to automatically merge the default branch into the requested ref, defaults to true.
	AutoMerge *bool `json:"autoMerge,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Short description of the deployment.
	Description *string `json:"description,omitempty"`
	// Name for the target deployment environment.
	Environment *string `json:"environment,omitempty"`
	// JSON payload with extra information about the deployment.
	Payload *string `json:"payload,omitempty"`
	// The node ID of the ref to be deployed.
	RefId string `json:"refId"`
	// The node ID of the repository.
	RepositoryId string `json:"repositoryId"`
	// The status contexts to verify against commit status checks. To bypass required
	// contexts, pass an empty array. Defaults to all unique contexts.
	RequiredContexts []string `json:"requiredContexts,omitempty"`
	// Specifies a task to execute.
	Task *string `json:"task,omitempty"`
}

// Autogenerated return type of CreateDeployment.
type CreateDeploymentPayload struct {
	// True if the default branch has been auto-merged into the deployment ref.
	AutoMerged *bool `json:"autoMerged,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The new deployment.
	Deployment *Deployment `json:"deployment,omitempty"`
}

// Autogenerated input type of CreateDeploymentStatus
type CreateDeploymentStatusInput struct {
	// Adds a new inactive status to all non-transient, non-production environment
	// deployments with the same repository and environment name as the created
	// status's deployment.
	AutoInactive *bool `json:"autoInactive,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The node ID of the deployment.
	DeploymentId string `json:"deploymentId"`
	// A short description of the status. Maximum length of 140 characters.
	Description *string `json:"description,omitempty"`
	// If provided, updates the environment of the deploy. Otherwise, does not modify the environment.
	Environment *string `json:"environment,omitempty"`
	// Sets the URL for accessing your environment.
	EnvironmentUrl *string `json:"environmentUrl,omitempty"`
	// The log URL to associate with this status.       This URL should contain
	// output to keep the user updated while the task is running       or serve as
	// historical information for what happened in the deployment.
	LogUrl *string `json:"logUrl,omitempty"`
	// The state of the deployment.
	State DeploymentStatusState `json:"state"`
}

// Autogenerated return type of CreateDeploymentStatus.
type CreateDeploymentStatusPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The new deployment status.
	DeploymentStatus *DeploymentStatus `json:"deploymentStatus,omitempty"`
}

// Autogenerated input type of CreateDiscussion
type CreateDiscussionInput struct {
	// The body of the discussion.
	Body string `json:"body"`
	// The id of the discussion category to associate with this discussion.
	CategoryId string `json:"categoryId"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The id of the repository on which to create the discussion.
	RepositoryId string `json:"repositoryId"`
	// The title of the discussion.
	Title string `json:"title"`
}

// Autogenerated return type of CreateDiscussion.
type CreateDiscussionPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The discussion that was just created.
	Discussion *Discussion `json:"discussion,omitempty"`
}

// Autogenerated input type of CreateEnterpriseOrganization
type CreateEnterpriseOrganizationInput struct {
	// The logins for the administrators of the new organization.
	AdminLogins []string `json:"adminLogins"`
	// The email used for sending billing receipts.
	BillingEmail string `json:"billingEmail"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the enterprise owning the new organization.
	EnterpriseId string `json:"enterpriseId"`
	// The login of the new organization.
	Login string `json:"login"`
	// The profile name of the new organization.
	ProfileName string `json:"profileName"`
}

// Autogenerated return type of CreateEnterpriseOrganization.
type CreateEnterpriseOrganizationPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The enterprise that owns the created organization.
	Enterprise *Enterprise `json:"enterprise,omitempty"`
	// The organization that was created.
	Organization *Organization `json:"organization,omitempty"`
}

// Autogenerated input type of CreateEnvironment
type CreateEnvironmentInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The name of the environment.
	Name string `json:"name"`
	// The node ID of the repository.
	RepositoryId string `json:"repositoryId"`
}

// Autogenerated return type of CreateEnvironment.
type CreateEnvironmentPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The new or existing environment.
	Environment *Environment `json:"environment,omitempty"`
}

// Autogenerated input type of CreateIpAllowListEntry
type CreateIpAllowListEntryInput struct {
	// An IP address or range of addresses in CIDR notation.
	AllowListValue string `json:"allowListValue"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Whether the IP allow list entry is active when an IP allow list is enabled.
	IsActive bool `json:"isActive"`
	// An optional name for the IP allow list entry.
	Name *string `json:"name,omitempty"`
	// The ID of the owner for which to create the new IP allow list entry.
	OwnerId string `json:"ownerId"`
}

// Autogenerated return type of CreateIpAllowListEntry.
type CreateIpAllowListEntryPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The IP allow list entry that was created.
	IpAllowListEntry *IpAllowListEntry `json:"ipAllowListEntry,omitempty"`
}

// Autogenerated input type of CreateIssue
type CreateIssueInput struct {
	// The Node ID of assignees for this issue.
	AssigneeIds []string `json:"assigneeIds,omitempty"`
	// The body for the issue description.
	Body *string `json:"body,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The name of an issue template in the repository, assigns labels and assignees from the template to the issue
	IssueTemplate *string `json:"issueTemplate,omitempty"`
	// The Node ID of the issue type for this issue
	IssueTypeId string `json:"issueTypeId,omitempty"`
	// An array of Node IDs of labels for this issue.
	LabelIds []string `json:"labelIds,omitempty"`
	// The Node ID of the milestone for this issue.
	MilestoneId string `json:"milestoneId,omitempty"`
	// The Node ID of the parent issue to add this new issue to
	ParentIssueId string `json:"parentIssueId,omitempty"`
	// An array of Node IDs for projects associated with this issue.
	ProjectIds []string `json:"projectIds,omitempty"`
	// The Node ID of the repository.
	RepositoryId string `json:"repositoryId"`
	// The title for the issue.
	Title string `json:"title"`
}

// Autogenerated return type of CreateIssue.
type CreateIssuePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The new issue.
	Issue *Issue `json:"issue,omitempty"`
}

// Autogenerated input type of CreateIssueType
type CreateIssueTypeInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Color for the issue type
	Color *IssueTypeColor `json:"color,omitempty"`
	// Description of the new issue type
	Description *string `json:"description,omitempty"`
	// Whether or not the issue type is enabled on the org level
	IsEnabled bool `json:"isEnabled"`
	// Name of the new issue type
	Name string `json:"name"`
	// The ID for the organization on which the issue type is created
	OwnerId string `json:"ownerId"`
}

// Autogenerated return type of CreateIssueType.
type CreateIssueTypePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The newly created issue type
	IssueType *IssueType `json:"issueType,omitempty"`
}

// Autogenerated input type of CreateLabel
type CreateLabelInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// A 6 character hex code, without the leading #, identifying the color of the label.
	Color string `json:"color"`
	// A brief description of the label, such as its purpose.
	Description *string `json:"description,omitempty"`
	// The name of the label.
	Name string `json:"name"`
	// The Node ID of the repository.
	RepositoryId string `json:"repositoryId"`
}

// Autogenerated return type of CreateLabel.
type CreateLabelPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The new label.
	Label *Label `json:"label,omitempty"`
}

// Autogenerated input type of CreateLinkedBranch
type CreateLinkedBranchInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// ID of the issue to link to.
	IssueId string `json:"issueId"`
	// The name of the new branch. Defaults to issue number and title.
	Name *string `json:"name,omitempty"`
	// The commit SHA to base the new branch on.
	Oid GitObjectID `json:"oid"`
	// ID of the repository to create the branch in. Defaults to the issue repository.
	RepositoryId string `json:"repositoryId,omitempty"`
}

// Autogenerated return type of CreateLinkedBranch.
type CreateLinkedBranchPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The issue that was linked to.
	Issue *Issue `json:"issue,omitempty"`
	// The new branch issue reference.
	LinkedBranch *LinkedBranch `json:"linkedBranch,omitempty"`
}

// Autogenerated input type of CreateMigrationSource
type CreateMigrationSourceInput struct {
	// The migration source access token.
	AccessToken *string `json:"accessToken,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The GitHub personal access token of the user importing to the target repository.
	GithubPat *string `json:"githubPat,omitempty"`
	// The migration source name.
	Name string `json:"name"`
	// The ID of the organization that will own the migration source.
	OwnerId string `json:"ownerId"`
	// The migration source type.
	Type MigrationSourceType `json:"type"`
	// The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`.
	Url *string `json:"url,omitempty"`
}

// Autogenerated return type of CreateMigrationSource.
type CreateMigrationSourcePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The created migration source.
	MigrationSource *MigrationSource `json:"migrationSource,omitempty"`
}

// Autogenerated input type of CreateProject
type CreateProjectInput struct {
	// The description of project.
	Body *string `json:"body,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The name of project.
	Name string `json:"name"`
	// The owner ID to create the project under.
	OwnerId string `json:"ownerId"`
	// A list of repository IDs to create as linked repositories for the project
	RepositoryIds []string `json:"repositoryIds,omitempty"`
	// The name of the GitHub-provided template.
	Template *ProjectTemplate `json:"template,omitempty"`
}

// Autogenerated return type of CreateProject.
type CreateProjectPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The new project.
	Project *Project `json:"project,omitempty"`
}

// Autogenerated input type of CreateProjectV2Field
type CreateProjectV2FieldInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The data type of the field.
	DataType ProjectV2CustomFieldType `json:"dataType"`
	// Configuration for an iteration field.
	IterationConfiguration *ProjectV2IterationFieldConfigurationInput `json:"iterationConfiguration,omitempty"`
	// The name of the field.
	Name string `json:"name"`
	// The ID of the Project to create the field in.
	ProjectId string `json:"projectId"`
	// Options for a single select field. At least one value is required if data_type is SINGLE_SELECT
	SingleSelectOptions []ProjectV2SingleSelectFieldOptionInput `json:"singleSelectOptions,omitempty"`
}

// Autogenerated return type of CreateProjectV2Field.
type CreateProjectV2FieldPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The new field.
	ProjectV2Field *ProjectV2FieldConfiguration `json:"projectV2Field,omitempty"`
}

// Autogenerated input type of CreateProjectV2
type CreateProjectV2Input struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The owner ID to create the project under.
	OwnerId string `json:"ownerId"`
	// The repository to link the project to.
	RepositoryId string `json:"repositoryId,omitempty"`
	// The team to link the project to. The team will be granted read permissions.
	TeamId string `json:"teamId,omitempty"`
	// The title of the project.
	Title string `json:"title"`
}

// Autogenerated return type of CreateProjectV2.
type CreateProjectV2Payload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The new project.
	ProjectV2 *ProjectV2 `json:"projectV2,omitempty"`
}

// Autogenerated input type of CreateProjectV2StatusUpdate
type CreateProjectV2StatusUpdateInput struct {
	// The body of the status update.
	Body *string `json:"body,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the Project to create the status update in.
	ProjectId string `json:"projectId"`
	// The start date of the status update.
	StartDate *Date `json:"startDate,omitempty"`
	// The status of the status update.
	Status *ProjectV2StatusUpdateStatus `json:"status,omitempty"`
	// The target date of the status update.
	TargetDate *Date `json:"targetDate,omitempty"`
}

// Autogenerated return type of CreateProjectV2StatusUpdate.
type CreateProjectV2StatusUpdatePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The status update updated in the project.
	StatusUpdate *ProjectV2StatusUpdate `json:"statusUpdate,omitempty"`
}

// Autogenerated input type of CreatePullRequest
type CreatePullRequestInput struct {
	// The name of the branch you want your changes pulled into. This should be an existing branch
	// on the current repository. You cannot update the base branch on a pull request to point
	// to another repository.
	BaseRefName string `json:"baseRefName"`
	// The contents of the pull request.
	Body *string `json:"body,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Indicates whether this pull request should be a draft.
	Draft *bool `json:"draft,omitempty"`
	// The name of the branch where your changes are implemented. For cross-repository pull requests
	// in the same network, namespace `head_ref_name` with a user like this: `username:branch`.
	HeadRefName string `json:"headRefName"`
	// The Node ID of the head repository.
	HeadRepositoryId string `json:"headRepositoryId,omitempty"`
	// Indicates whether maintainers can modify the pull request.
	MaintainerCanModify *bool `json:"maintainerCanModify,omitempty"`
	// The Node ID of the repository.
	RepositoryId string `json:"repositoryId"`
	// The title of the pull request.
	Title string `json:"title"`
}

// Autogenerated return type of CreatePullRequest.
type CreatePullRequestPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The new pull request.
	PullRequest *PullRequest `json:"pullRequest,omitempty"`
}

// Autogenerated input type of CreateRef
type CreateRefInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The fully qualified name of the new Ref (ie: `refs/heads/my_new_branch`).
	Name string `json:"name"`
	// The GitObjectID that the new Ref shall target. Must point to a commit.
	Oid GitObjectID `json:"oid"`
	// The Node ID of the Repository to create the Ref in.
	RepositoryId string `json:"repositoryId"`
}

// Autogenerated return type of CreateRef.
type CreateRefPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The newly created ref.
	Ref *Ref `json:"ref,omitempty"`
}

// Autogenerated input type of CreateRepository
type CreateRepositoryInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// A short description of the new repository.
	Description *string `json:"description,omitempty"`
	// Indicates if the repository should have the issues feature enabled.
	HasIssuesEnabled *bool `json:"hasIssuesEnabled,omitempty"`
	// Indicates if the repository should have the wiki feature enabled.
	HasWikiEnabled *bool `json:"hasWikiEnabled,omitempty"`
	// The URL for a web page about this repository.
	HomepageUrl *URI `json:"homepageUrl,omitempty"`
	// The name of the new repository.
	Name string `json:"name"`
	// The ID of the owner for the new repository.
	OwnerId string `json:"ownerId,omitempty"`
	// When an organization is specified as the owner, this ID identifies the team
	// that should be granted access to the new repository.
	TeamId string `json:"teamId,omitempty"`
	// Whether this repository should be marked as a template such that anyone who
	// can access it can create new repositories with the same files and directory structure.
	Template *bool `json:"template,omitempty"`
	// Indicates the repository's visibility level.
	Visibility RepositoryVisibility `json:"visibility"`
}

// Autogenerated return type of CreateRepository.
type CreateRepositoryPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The new repository.
	Repository *Repository `json:"repository,omitempty"`
}

// Autogenerated input type of CreateRepositoryRuleset
type CreateRepositoryRulesetInput struct {
	// A list of actors that are allowed to bypass rules in this ruleset.
	BypassActors []RepositoryRulesetBypassActorInput `json:"bypassActors,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The set of conditions for this ruleset
	Conditions RepositoryRuleConditionsInput `json:"conditions"`
	// The enforcement level for this ruleset
	Enforcement RuleEnforcement `json:"enforcement"`
	// The name of the ruleset.
	Name string `json:"name"`
	// The list of rules for this ruleset
	Rules []RepositoryRuleInput `json:"rules,omitempty"`
	// The global relay id of the source in which a new ruleset should be created in.
	SourceId string `json:"sourceId"`
	// The target of the ruleset.
	Target *RepositoryRulesetTarget `json:"target,omitempty"`
}

// Autogenerated return type of CreateRepositoryRuleset.
type CreateRepositoryRulesetPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The newly created Ruleset.
	Ruleset *RepositoryRuleset `json:"ruleset,omitempty"`
}

// Autogenerated input type of CreateSponsorsListing
type CreateSponsorsListingInput struct {
	// The country or region where the sponsorable's bank account is located.
	// Required if fiscalHostLogin is not specified, ignored when fiscalHostLogin is specified.
	BillingCountryOrRegionCode *SponsorsCountryOrRegionCode `json:"billingCountryOrRegionCode,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The email address we should use to contact you about the GitHub Sponsors
	// profile being created. This will not be shared publicly. Must be a verified
	// email address already on your GitHub account. Only relevant when the
	// sponsorable is yourself. Defaults to your primary email address on file if omitted.
	ContactEmail *string `json:"contactEmail,omitempty"`
	// The username of the supported fiscal host's GitHub organization, if you want
	// to receive sponsorship payouts through a fiscal host rather than directly to a
	// bank account. For example, 'Open-Source-Collective' for Open Source Collective
	// or 'numfocus' for numFOCUS. Case insensitive. See https://docs.github.com/sponsors/receiving-sponsorships-through-github-sponsors/using-a-fiscal-host-to-receive-github-sponsors-payouts
	// for more information.
	FiscalHostLogin *string `json:"fiscalHostLogin,omitempty"`
	// The URL for your profile page on the fiscal host's website, e.g.,
	// https://opencollective.com/babel or https://numfocus.org/project/bokeh.
	// Required if fiscalHostLogin is specified.
	FiscallyHostedProjectProfileUrl *string `json:"fiscallyHostedProjectProfileUrl,omitempty"`
	// Provide an introduction to serve as the main focus that appears on your GitHub
	// Sponsors profile. It's a great opportunity to help potential sponsors learn
	// more about you, your work, and why their sponsorship is important to you.
	// GitHub-flavored Markdown is supported.
	FullDescription *string `json:"fullDescription,omitempty"`
	// The country or region where the sponsorable resides. This is for tax purposes.
	// Required if the sponsorable is yourself, ignored when sponsorableLogin
	// specifies an organization.
	ResidenceCountryOrRegionCode *SponsorsCountryOrRegionCode `json:"residenceCountryOrRegionCode,omitempty"`
	// The username of the organization to create a GitHub Sponsors profile for, if
	// desired. Defaults to creating a GitHub Sponsors profile for the authenticated
	// user if omitted.
	SponsorableLogin *string `json:"sponsorableLogin,omitempty"`
}

// Autogenerated return type of CreateSponsorsListing.
type CreateSponsorsListingPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The new GitHub Sponsors profile.
	SponsorsListing *SponsorsListing `json:"sponsorsListing,omitempty"`
}

// Autogenerated input type of CreateSponsorsTier
type CreateSponsorsTierInput struct {
	// The value of the new tier in US dollars. Valid values: 1-12000.
	Amount int32 `json:"amount"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// A description of what this tier is, what perks sponsors might receive, what a sponsorship at this tier means for you, etc.
	Description string `json:"description"`
	// Whether sponsorships using this tier should happen monthly/yearly or just once.
	IsRecurring *bool `json:"isRecurring,omitempty"`
	// Whether to make the tier available immediately for sponsors to choose.
	// Defaults to creating a draft tier that will not be publicly visible.
	Publish *bool `json:"publish,omitempty"`
	// Optional ID of the private repository that sponsors at this tier should gain
	// read-only access to. Must be owned by an organization.
	RepositoryId string `json:"repositoryId,omitempty"`
	// Optional name of the private repository that sponsors at this tier should gain
	// read-only access to. Must be owned by an organization. Necessary if
	// repositoryOwnerLogin is given. Will be ignored if repositoryId is given.
	RepositoryName *string `json:"repositoryName,omitempty"`
	// Optional login of the organization owner of the private repository that
	// sponsors at this tier should gain read-only access to. Necessary if
	// repositoryName is given. Will be ignored if repositoryId is given.
	RepositoryOwnerLogin *string `json:"repositoryOwnerLogin,omitempty"`
	// The ID of the user or organization who owns the GitHub Sponsors profile.
	// Defaults to the current user if omitted and sponsorableLogin is not given.
	SponsorableId string `json:"sponsorableId,omitempty"`
	// The username of the user or organization who owns the GitHub Sponsors profile.
	// Defaults to the current user if omitted and sponsorableId is not given.
	SponsorableLogin *string `json:"sponsorableLogin,omitempty"`
	// Optional message new sponsors at this tier will receive.
	WelcomeMessage *string `json:"welcomeMessage,omitempty"`
}

// Autogenerated return type of CreateSponsorsTier.
type CreateSponsorsTierPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The new tier.
	SponsorsTier *SponsorsTier `json:"sponsorsTier,omitempty"`
}

// Autogenerated input type of CreateSponsorship
type CreateSponsorshipInput struct {
	// The amount to pay to the sponsorable in US dollars. Required if a tierId is not specified. Valid values: 1-12000.
	Amount *int32 `json:"amount,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Whether the sponsorship should happen monthly/yearly or just this one time. Required if a tierId is not specified.
	IsRecurring *bool `json:"isRecurring,omitempty"`
	// Specify whether others should be able to see that the sponsor is sponsoring
	// the sponsorable. Public visibility still does not reveal which tier is used.
	PrivacyLevel *SponsorshipPrivacy `json:"privacyLevel,omitempty"`
	// Whether the sponsor should receive email updates from the sponsorable.
	ReceiveEmails *bool `json:"receiveEmails,omitempty"`
	// The ID of the user or organization who is acting as the sponsor, paying for
	// the sponsorship. Required if sponsorLogin is not given.
	SponsorId string `json:"sponsorId,omitempty"`
	// The username of the user or organization who is acting as the sponsor, paying
	// for the sponsorship. Required if sponsorId is not given.
	SponsorLogin *string `json:"sponsorLogin,omitempty"`
	// The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given.
	SponsorableId string `json:"sponsorableId,omitempty"`
	// The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given.
	SponsorableLogin *string `json:"sponsorableLogin,omitempty"`
	// The ID of one of sponsorable's existing tiers to sponsor at. Required if amount is not specified.
	TierId string `json:"tierId,omitempty"`
}

// Autogenerated return type of CreateSponsorship.
type CreateSponsorshipPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The sponsorship that was started.
	Sponsorship *Sponsorship `json:"sponsorship,omitempty"`
}

// Autogenerated input type of CreateSponsorships
type CreateSponsorshipsInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Specify whether others should be able to see that the sponsor is sponsoring
	// the sponsorables. Public visibility still does not reveal the dollar value of
	// the sponsorship.
	PrivacyLevel *SponsorshipPrivacy `json:"privacyLevel,omitempty"`
	// Whether the sponsor should receive email updates from the sponsorables.
	ReceiveEmails *bool `json:"receiveEmails,omitempty"`
	// Whether the sponsorships created should continue each billing cycle for the
	// sponsor (monthly or annually), versus lasting only a single month. Defaults to
	// one-time sponsorships.
	Recurring *bool `json:"recurring,omitempty"`
	// The username of the user or organization who is acting as the sponsor, paying for the sponsorships.
	SponsorLogin string `json:"sponsorLogin"`
	// The list of maintainers to sponsor and for how much apiece.
	Sponsorships []BulkSponsorship `json:"sponsorships"`
}

// Autogenerated return type of CreateSponsorships.
type CreateSponsorshipsPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The users and organizations who received a sponsorship.
	Sponsorables []Sponsorable `json:"sponsorables,omitempty"`
}

// Autogenerated input type of CreateTeamDiscussionComment
type CreateTeamDiscussionCommentInput struct {
	// The content of the comment. This field is required.
	//
	// **Upcoming Change on 2024-07-01 UTC**
	// **Description:** `body` will be removed. Follow the guide at
	// https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
	// find a suitable replacement.
	// **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
	Body *string `json:"body,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the discussion to which the comment belongs. This field is required.
	//
	// **Upcoming Change on 2024-07-01 UTC**
	// **Description:** `discussionId` will be removed. Follow the guide at
	// https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
	// find a suitable replacement.
	// **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
	DiscussionId string `json:"discussionId,omitempty"`
}

// Autogenerated return type of CreateTeamDiscussionComment.
type CreateTeamDiscussionCommentPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The new comment.
	TeamDiscussionComment *TeamDiscussionComment `json:"teamDiscussionComment,omitempty"`
}

// Autogenerated input type of CreateTeamDiscussion
type CreateTeamDiscussionInput struct {
	// The content of the discussion. This field is required.
	//
	// **Upcoming Change on 2024-07-01 UTC**
	// **Description:** `body` will be removed. Follow the guide at
	// https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
	// find a suitable replacement.
	// **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
	Body *string `json:"body,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// If true, restricts the visibility of this discussion to team members and
	// organization owners. If false or not specified, allows any organization member
	// to view this discussion.
	//
	// **Upcoming Change on 2024-07-01 UTC**
	// **Description:** `private` will be removed. Follow the guide at
	// https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
	// find a suitable replacement.
	// **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
	Private *bool `json:"private,omitempty"`
	// The ID of the team to which the discussion belongs. This field is required.
	//
	// **Upcoming Change on 2024-07-01 UTC**
	// **Description:** `teamId` will be removed. Follow the guide at
	// https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
	// find a suitable replacement.
	// **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
	TeamId string `json:"teamId,omitempty"`
	// The title of the discussion. This field is required.
	//
	// **Upcoming Change on 2024-07-01 UTC**
	// **Description:** `title` will be removed. Follow the guide at
	// https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
	// find a suitable replacement.
	// **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
	Title *string `json:"title,omitempty"`
}

// Autogenerated return type of CreateTeamDiscussion.
type CreateTeamDiscussionPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The new discussion.
	TeamDiscussion *TeamDiscussion `json:"teamDiscussion,omitempty"`
}

// Autogenerated input type of CreateUserList
type CreateUserListInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// A description of the list
	Description *string `json:"description,omitempty"`
	// Whether or not the list is private
	IsPrivate *bool `json:"isPrivate,omitempty"`
	// The name of the new list
	Name string `json:"name"`
}

// Autogenerated return type of CreateUserList.
type CreateUserListPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The list that was just created
	List *UserList `json:"list,omitempty"`
	// The user who created the list
	Viewer *User `json:"viewer,omitempty"`
}

// Represents the contribution a user made by committing to a repository.
type CreatedCommitContribution struct {
	// How many commits were made on this day to this repository by the user.
	CommitCount int32 `json:"commitCount"`
	// Whether this contribution is associated with a record you do not have access to. For
	// example, your own 'first issue' contribution may have been made on a repository you can no
	// longer access.
	IsRestricted bool `json:"isRestricted"`
	// When this contribution was made.
	OccurredAt DateTime `json:"occurredAt"`
	// The repository the user made a commit in.
	Repository *Repository `json:"repository"`
	// The HTTP path for this contribution.
	ResourcePath URI `json:"resourcePath"`
	// The HTTP URL for this contribution.
	Url URI `json:"url"`
	// The user who made this contribution.
	User *User `json:"user"`
}

func (*CreatedCommitContribution) isContribution() {}

// The connection type for CreatedCommitContribution.
type CreatedCommitContributionConnection struct {
	// A list of edges.
	Edges []*CreatedCommitContributionEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*CreatedCommitContribution `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of commits across days and repositories in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type CreatedCommitContributionEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *CreatedCommitContribution `json:"node,omitempty"`
}

// Represents the contribution a user made on GitHub by opening an issue.
type CreatedIssueContribution struct {
	// Whether this contribution is associated with a record you do not have access to. For
	// example, your own 'first issue' contribution may have been made on a repository you can no
	// longer access.
	IsRestricted bool `json:"isRestricted"`
	// The issue that was opened.
	Issue *Issue `json:"issue"`
	// When this contribution was made.
	OccurredAt DateTime `json:"occurredAt"`
	// The HTTP path for this contribution.
	ResourcePath URI `json:"resourcePath"`
	// The HTTP URL for this contribution.
	Url URI `json:"url"`
	// The user who made this contribution.
	User *User `json:"user"`
}

func (*CreatedIssueContribution) isContribution() {}

func (*CreatedIssueContribution) isCreatedIssueOrRestrictedContribution() {}

// The connection type for CreatedIssueContribution.
type CreatedIssueContributionConnection struct {
	// A list of edges.
	Edges []*CreatedIssueContributionEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*CreatedIssueContribution `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type CreatedIssueContributionEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *CreatedIssueContribution `json:"node,omitempty"`
}

// Represents either a issue the viewer can access or a restricted contribution.
type CreatedIssueOrRestrictedContribution struct {
	// Underlying value of the GraphQL union
	Value CreatedIssueOrRestrictedContributionValue `json:"-"`
}

func (base *CreatedIssueOrRestrictedContribution) UnmarshalJSON(b []byte) error {
	type Raw CreatedIssueOrRestrictedContribution
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "CreatedIssueContribution":
		base.Value = new(CreatedIssueContribution)
	case "RestrictedContribution":
		base.Value = new(RestrictedContribution)
	case "":
		return fmt.Errorf("gqlclient: union CreatedIssueOrRestrictedContribution: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union CreatedIssueOrRestrictedContribution: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// CreatedIssueOrRestrictedContributionValue is one of: CreatedIssueContribution | RestrictedContribution
type CreatedIssueOrRestrictedContributionValue interface {
	isCreatedIssueOrRestrictedContribution()
}

// Represents the contribution a user made on GitHub by opening a pull request.
type CreatedPullRequestContribution struct {
	// Whether this contribution is associated with a record you do not have access to. For
	// example, your own 'first issue' contribution may have been made on a repository you can no
	// longer access.
	IsRestricted bool `json:"isRestricted"`
	// When this contribution was made.
	OccurredAt DateTime `json:"occurredAt"`
	// The pull request that was opened.
	PullRequest *PullRequest `json:"pullRequest"`
	// The HTTP path for this contribution.
	ResourcePath URI `json:"resourcePath"`
	// The HTTP URL for this contribution.
	Url URI `json:"url"`
	// The user who made this contribution.
	User *User `json:"user"`
}

func (*CreatedPullRequestContribution) isContribution() {}

func (*CreatedPullRequestContribution) isCreatedPullRequestOrRestrictedContribution() {}

// The connection type for CreatedPullRequestContribution.
type CreatedPullRequestContributionConnection struct {
	// A list of edges.
	Edges []*CreatedPullRequestContributionEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*CreatedPullRequestContribution `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type CreatedPullRequestContributionEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *CreatedPullRequestContribution `json:"node,omitempty"`
}

// Represents either a pull request the viewer can access or a restricted contribution.
type CreatedPullRequestOrRestrictedContribution struct {
	// Underlying value of the GraphQL union
	Value CreatedPullRequestOrRestrictedContributionValue `json:"-"`
}

func (base *CreatedPullRequestOrRestrictedContribution) UnmarshalJSON(b []byte) error {
	type Raw CreatedPullRequestOrRestrictedContribution
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "CreatedPullRequestContribution":
		base.Value = new(CreatedPullRequestContribution)
	case "RestrictedContribution":
		base.Value = new(RestrictedContribution)
	case "":
		return fmt.Errorf("gqlclient: union CreatedPullRequestOrRestrictedContribution: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union CreatedPullRequestOrRestrictedContribution: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// CreatedPullRequestOrRestrictedContributionValue is one of: CreatedPullRequestContribution | RestrictedContribution
type CreatedPullRequestOrRestrictedContributionValue interface {
	isCreatedPullRequestOrRestrictedContribution()
}

// Represents the contribution a user made by leaving a review on a pull request.
type CreatedPullRequestReviewContribution struct {
	// Whether this contribution is associated with a record you do not have access to. For
	// example, your own 'first issue' contribution may have been made on a repository you can no
	// longer access.
	IsRestricted bool `json:"isRestricted"`
	// When this contribution was made.
	OccurredAt DateTime `json:"occurredAt"`
	// The pull request the user reviewed.
	PullRequest *PullRequest `json:"pullRequest"`
	// The review the user left on the pull request.
	PullRequestReview *PullRequestReview `json:"pullRequestReview"`
	// The repository containing the pull request that the user reviewed.
	Repository *Repository `json:"repository"`
	// The HTTP path for this contribution.
	ResourcePath URI `json:"resourcePath"`
	// The HTTP URL for this contribution.
	Url URI `json:"url"`
	// The user who made this contribution.
	User *User `json:"user"`
}

func (*CreatedPullRequestReviewContribution) isContribution() {}

// The connection type for CreatedPullRequestReviewContribution.
type CreatedPullRequestReviewContributionConnection struct {
	// A list of edges.
	Edges []*CreatedPullRequestReviewContributionEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*CreatedPullRequestReviewContribution `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type CreatedPullRequestReviewContributionEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *CreatedPullRequestReviewContribution `json:"node,omitempty"`
}

// Represents the contribution a user made on GitHub by creating a repository.
type CreatedRepositoryContribution struct {
	// Whether this contribution is associated with a record you do not have access to. For
	// example, your own 'first issue' contribution may have been made on a repository you can no
	// longer access.
	IsRestricted bool `json:"isRestricted"`
	// When this contribution was made.
	OccurredAt DateTime `json:"occurredAt"`
	// The repository that was created.
	Repository *Repository `json:"repository"`
	// The HTTP path for this contribution.
	ResourcePath URI `json:"resourcePath"`
	// The HTTP URL for this contribution.
	Url URI `json:"url"`
	// The user who made this contribution.
	User *User `json:"user"`
}

func (*CreatedRepositoryContribution) isContribution() {}

func (*CreatedRepositoryContribution) isCreatedRepositoryOrRestrictedContribution() {}

// The connection type for CreatedRepositoryContribution.
type CreatedRepositoryContributionConnection struct {
	// A list of edges.
	Edges []*CreatedRepositoryContributionEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*CreatedRepositoryContribution `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type CreatedRepositoryContributionEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *CreatedRepositoryContribution `json:"node,omitempty"`
}

// Represents either a repository the viewer can access or a restricted contribution.
type CreatedRepositoryOrRestrictedContribution struct {
	// Underlying value of the GraphQL union
	Value CreatedRepositoryOrRestrictedContributionValue `json:"-"`
}

func (base *CreatedRepositoryOrRestrictedContribution) UnmarshalJSON(b []byte) error {
	type Raw CreatedRepositoryOrRestrictedContribution
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "CreatedRepositoryContribution":
		base.Value = new(CreatedRepositoryContribution)
	case "RestrictedContribution":
		base.Value = new(RestrictedContribution)
	case "":
		return fmt.Errorf("gqlclient: union CreatedRepositoryOrRestrictedContribution: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union CreatedRepositoryOrRestrictedContribution: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// CreatedRepositoryOrRestrictedContributionValue is one of: CreatedRepositoryContribution | RestrictedContribution
type CreatedRepositoryOrRestrictedContributionValue interface {
	isCreatedRepositoryOrRestrictedContribution()
}

// Represents a mention made by one issue or pull request to another.
type CrossReferencedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the CrossReferencedEvent object
	Id string `json:"id"`
	// Reference originated in a different repository.
	IsCrossRepository bool `json:"isCrossRepository"`
	// Identifies when the reference was made.
	ReferencedAt DateTime `json:"referencedAt"`
	// The HTTP path for this pull request.
	ResourcePath URI `json:"resourcePath"`
	// Issue or pull request that made the reference.
	Source ReferencedSubject `json:"source"`
	// Issue or pull request to which the reference was made.
	Target ReferencedSubject `json:"target"`
	// The HTTP URL for this pull request.
	Url URI `json:"url"`
	// Checks if the target will be closed when the source is merged.
	WillCloseTarget bool `json:"willCloseTarget"`
}

func (*CrossReferencedEvent) isNode() {}

func (*CrossReferencedEvent) isUniformResourceLocatable() {}

func (*CrossReferencedEvent) isIssueTimelineItem() {}

func (*CrossReferencedEvent) isIssueTimelineItems() {}

func (*CrossReferencedEvent) isPullRequestTimelineItem() {}

func (*CrossReferencedEvent) isPullRequestTimelineItems() {}

// The Common Vulnerability Scoring System
type CvssSeverities struct {
	// The CVSS v3 severity associated with this advisory
	CvssV3 *CVSS `json:"cvssV3,omitempty"`
	// The CVSS v4 severity associated with this advisory
	CvssV4 *CVSS `json:"cvssV4,omitempty"`
}

// An ISO-8601 encoded date string.
type Date string

// An ISO-8601 encoded UTC date string.
type DateTime string

// Autogenerated input type of DeclineTopicSuggestion
type DeclineTopicSuggestionInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The name of the suggested topic.
	//
	// **Upcoming Change on 2024-04-01 UTC**
	// **Description:** `name` will be removed.
	// **Reason:** Suggested topics are no longer supported
	Name *string `json:"name,omitempty"`
	// The reason why the suggested topic is declined.
	//
	// **Upcoming Change on 2024-04-01 UTC**
	// **Description:** `reason` will be removed.
	// **Reason:** Suggested topics are no longer supported
	Reason *TopicSuggestionDeclineReason `json:"reason,omitempty"`
	// The Node ID of the repository.
	//
	// **Upcoming Change on 2024-04-01 UTC**
	// **Description:** `repositoryId` will be removed.
	// **Reason:** Suggested topics are no longer supported
	RepositoryId string `json:"repositoryId,omitempty"`
}

// Autogenerated return type of DeclineTopicSuggestion.
type DeclineTopicSuggestionPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The declined topic.
	Topic *Topic `json:"topic,omitempty"`
}

// The possible base permissions for repositories.
type DefaultRepositoryPermissionField string

const (
	// Can read, write, and administrate repos by default
	DefaultRepositoryPermissionFieldAdmin DefaultRepositoryPermissionField = "ADMIN"
	// No access
	DefaultRepositoryPermissionFieldNone DefaultRepositoryPermissionField = "NONE"
	// Can read repos by default
	DefaultRepositoryPermissionFieldRead DefaultRepositoryPermissionField = "READ"
	// Can read and write repos by default
	DefaultRepositoryPermissionFieldWrite DefaultRepositoryPermissionField = "WRITE"
)

// Entities that can be deleted.
type Deletable struct {
	// Check if the current viewer can delete this object.
	ViewerCanDelete bool `json:"viewerCanDelete"`

	// Underlying value of the GraphQL interface
	Value DeletableValue `json:"-"`
}

func (base *Deletable) UnmarshalJSON(b []byte) error {
	type Raw Deletable
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "CommitComment":
		base.Value = new(CommitComment)
	case "Discussion":
		base.Value = new(Discussion)
	case "DiscussionComment":
		base.Value = new(DiscussionComment)
	case "GistComment":
		base.Value = new(GistComment)
	case "Issue":
		base.Value = new(Issue)
	case "IssueComment":
		base.Value = new(IssueComment)
	case "PullRequestReview":
		base.Value = new(PullRequestReview)
	case "PullRequestReviewComment":
		base.Value = new(PullRequestReviewComment)
	case "TeamDiscussion":
		base.Value = new(TeamDiscussion)
	case "TeamDiscussionComment":
		base.Value = new(TeamDiscussionComment)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface Deletable: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// DeletableValue is one of: CommitComment | Discussion | DiscussionComment | GistComment | Issue | IssueComment | PullRequestReview | PullRequestReviewComment | TeamDiscussion | TeamDiscussionComment
type DeletableValue interface {
	isDeletable()
}

// Autogenerated input type of DeleteBranchProtectionRule
type DeleteBranchProtectionRuleInput struct {
	// The global relay id of the branch protection rule to be deleted.
	BranchProtectionRuleId string `json:"branchProtectionRuleId"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
}

// Autogenerated return type of DeleteBranchProtectionRule.
type DeleteBranchProtectionRulePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
}

// Autogenerated input type of DeleteDeployment
type DeleteDeploymentInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Node ID of the deployment to be deleted.
	Id string `json:"id"`
}

// Autogenerated return type of DeleteDeployment.
type DeleteDeploymentPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
}

// Autogenerated input type of DeleteDiscussionComment
type DeleteDiscussionCommentInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Node id of the discussion comment to delete.
	Id string `json:"id"`
}

// Autogenerated return type of DeleteDiscussionComment.
type DeleteDiscussionCommentPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The discussion comment that was just deleted.
	Comment *DiscussionComment `json:"comment,omitempty"`
}

// Autogenerated input type of DeleteDiscussion
type DeleteDiscussionInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The id of the discussion to delete.
	Id string `json:"id"`
}

// Autogenerated return type of DeleteDiscussion.
type DeleteDiscussionPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The discussion that was just deleted.
	Discussion *Discussion `json:"discussion,omitempty"`
}

// Autogenerated input type of DeleteEnvironment
type DeleteEnvironmentInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Node ID of the environment to be deleted.
	Id string `json:"id"`
}

// Autogenerated return type of DeleteEnvironment.
type DeleteEnvironmentPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
}

// Autogenerated input type of DeleteIpAllowListEntry
type DeleteIpAllowListEntryInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the IP allow list entry to delete.
	IpAllowListEntryId string `json:"ipAllowListEntryId"`
}

// Autogenerated return type of DeleteIpAllowListEntry.
type DeleteIpAllowListEntryPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The IP allow list entry that was deleted.
	IpAllowListEntry *IpAllowListEntry `json:"ipAllowListEntry,omitempty"`
}

// Autogenerated input type of DeleteIssueComment
type DeleteIssueCommentInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the comment to delete.
	Id string `json:"id"`
}

// Autogenerated return type of DeleteIssueComment.
type DeleteIssueCommentPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
}

// Autogenerated input type of DeleteIssue
type DeleteIssueInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the issue to delete.
	IssueId string `json:"issueId"`
}

// Autogenerated return type of DeleteIssue.
type DeleteIssuePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The repository the issue belonged to
	Repository *Repository `json:"repository,omitempty"`
}

// Autogenerated input type of DeleteIssueType
type DeleteIssueTypeInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the issue type to delete
	IssueTypeId string `json:"issueTypeId"`
}

// Autogenerated return type of DeleteIssueType.
type DeleteIssueTypePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the deleted issue type
	DeletedIssueTypeId string `json:"deletedIssueTypeId,omitempty"`
}

// Autogenerated input type of DeleteLabel
type DeleteLabelInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Node ID of the label to be deleted.
	Id string `json:"id"`
}

// Autogenerated return type of DeleteLabel.
type DeleteLabelPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
}

// Autogenerated input type of DeleteLinkedBranch
type DeleteLinkedBranchInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the linked branch
	LinkedBranchId string `json:"linkedBranchId"`
}

// Autogenerated return type of DeleteLinkedBranch.
type DeleteLinkedBranchPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The issue the linked branch was unlinked from.
	Issue *Issue `json:"issue,omitempty"`
}

// Autogenerated input type of DeletePackageVersion
type DeletePackageVersionInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the package version to be deleted.
	PackageVersionId string `json:"packageVersionId"`
}

// Autogenerated return type of DeletePackageVersion.
type DeletePackageVersionPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Whether or not the operation succeeded.
	Success *bool `json:"success,omitempty"`
}

// Autogenerated input type of DeleteProjectCard
type DeleteProjectCardInput struct {
	// The id of the card to delete.
	CardId string `json:"cardId"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
}

// Autogenerated return type of DeleteProjectCard.
type DeleteProjectCardPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The column the deleted card was in.
	Column *ProjectColumn `json:"column,omitempty"`
	// The deleted card ID.
	DeletedCardId string `json:"deletedCardId,omitempty"`
}

// Autogenerated input type of DeleteProjectColumn
type DeleteProjectColumnInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The id of the column to delete.
	ColumnId string `json:"columnId"`
}

// Autogenerated return type of DeleteProjectColumn.
type DeleteProjectColumnPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The deleted column ID.
	DeletedColumnId string `json:"deletedColumnId,omitempty"`
	// The project the deleted column was in.
	Project *Project `json:"project,omitempty"`
}

// Autogenerated input type of DeleteProject
type DeleteProjectInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Project ID to update.
	ProjectId string `json:"projectId"`
}

// Autogenerated return type of DeleteProject.
type DeleteProjectPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The repository or organization the project was removed from.
	Owner *ProjectOwner `json:"owner,omitempty"`
}

// Autogenerated input type of DeleteProjectV2Field
type DeleteProjectV2FieldInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the field to delete.
	FieldId string `json:"fieldId"`
}

// Autogenerated return type of DeleteProjectV2Field.
type DeleteProjectV2FieldPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The deleted field.
	ProjectV2Field *ProjectV2FieldConfiguration `json:"projectV2Field,omitempty"`
}

// Autogenerated input type of DeleteProjectV2
type DeleteProjectV2Input struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the Project to delete.
	ProjectId string `json:"projectId"`
}

// Autogenerated input type of DeleteProjectV2Item
type DeleteProjectV2ItemInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the item to be removed.
	ItemId string `json:"itemId"`
	// The ID of the Project from which the item should be removed.
	ProjectId string `json:"projectId"`
}

// Autogenerated return type of DeleteProjectV2Item.
type DeleteProjectV2ItemPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the deleted item.
	DeletedItemId string `json:"deletedItemId,omitempty"`
}

// Autogenerated return type of DeleteProjectV2.
type DeleteProjectV2Payload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The deleted Project.
	ProjectV2 *ProjectV2 `json:"projectV2,omitempty"`
}

// Autogenerated input type of DeleteProjectV2StatusUpdate
type DeleteProjectV2StatusUpdateInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the status update to be removed.
	StatusUpdateId string `json:"statusUpdateId"`
}

// Autogenerated return type of DeleteProjectV2StatusUpdate.
type DeleteProjectV2StatusUpdatePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the deleted status update.
	DeletedStatusUpdateId string `json:"deletedStatusUpdateId,omitempty"`
	// The project the deleted status update was in.
	ProjectV2 *ProjectV2 `json:"projectV2,omitempty"`
}

// Autogenerated input type of DeleteProjectV2Workflow
type DeleteProjectV2WorkflowInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the workflow to be removed.
	WorkflowId string `json:"workflowId"`
}

// Autogenerated return type of DeleteProjectV2Workflow.
type DeleteProjectV2WorkflowPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the deleted workflow.
	DeletedWorkflowId string `json:"deletedWorkflowId,omitempty"`
	// The project the deleted workflow was in.
	ProjectV2 *ProjectV2 `json:"projectV2,omitempty"`
}

// Autogenerated input type of DeletePullRequestReviewComment
type DeletePullRequestReviewCommentInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the comment to delete.
	Id string `json:"id"`
}

// Autogenerated return type of DeletePullRequestReviewComment.
type DeletePullRequestReviewCommentPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The pull request review the deleted comment belonged to.
	PullRequestReview *PullRequestReview `json:"pullRequestReview,omitempty"`
	// The deleted pull request review comment.
	PullRequestReviewComment *PullRequestReviewComment `json:"pullRequestReviewComment,omitempty"`
}

// Autogenerated input type of DeletePullRequestReview
type DeletePullRequestReviewInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Node ID of the pull request review to delete.
	PullRequestReviewId string `json:"pullRequestReviewId"`
}

// Autogenerated return type of DeletePullRequestReview.
type DeletePullRequestReviewPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The deleted pull request review.
	PullRequestReview *PullRequestReview `json:"pullRequestReview,omitempty"`
}

// Autogenerated input type of DeleteRef
type DeleteRefInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Node ID of the Ref to be deleted.
	RefId string `json:"refId"`
}

// Autogenerated return type of DeleteRef.
type DeleteRefPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
}

// Autogenerated input type of DeleteRepositoryRuleset
type DeleteRepositoryRulesetInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The global relay id of the repository ruleset to be deleted.
	RepositoryRulesetId string `json:"repositoryRulesetId"`
}

// Autogenerated return type of DeleteRepositoryRuleset.
type DeleteRepositoryRulesetPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
}

// Autogenerated input type of DeleteTeamDiscussionComment
type DeleteTeamDiscussionCommentInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the comment to delete.
	Id string `json:"id"`
}

// Autogenerated return type of DeleteTeamDiscussionComment.
type DeleteTeamDiscussionCommentPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
}

// Autogenerated input type of DeleteTeamDiscussion
type DeleteTeamDiscussionInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The discussion ID to delete.
	Id string `json:"id"`
}

// Autogenerated return type of DeleteTeamDiscussion.
type DeleteTeamDiscussionPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
}

// Autogenerated input type of DeleteUserList
type DeleteUserListInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the list to delete.
	ListId string `json:"listId"`
}

// Autogenerated return type of DeleteUserList.
type DeleteUserListPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The owner of the list that will be deleted
	User *User `json:"user,omitempty"`
}

// Autogenerated input type of DeleteVerifiableDomain
type DeleteVerifiableDomainInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the verifiable domain to delete.
	Id string `json:"id"`
}

// Autogenerated return type of DeleteVerifiableDomain.
type DeleteVerifiableDomainPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The owning account from which the domain was deleted.
	Owner *VerifiableDomainOwner `json:"owner,omitempty"`
}

// Represents a 'demilestoned' event on a given issue or pull request.
type DemilestonedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the DemilestonedEvent object
	Id string `json:"id"`
	// Identifies the milestone title associated with the 'demilestoned' event.
	MilestoneTitle string `json:"milestoneTitle"`
	// Object referenced by event.
	Subject MilestoneItem `json:"subject"`
}

func (*DemilestonedEvent) isNode() {}

func (*DemilestonedEvent) isIssueTimelineItem() {}

func (*DemilestonedEvent) isIssueTimelineItems() {}

func (*DemilestonedEvent) isPullRequestTimelineItem() {}

func (*DemilestonedEvent) isPullRequestTimelineItems() {}

// A Dependabot Update for a dependency in a repository
type DependabotUpdate struct {
	// The error from a dependency update
	Error *DependabotUpdateError `json:"error,omitempty"`
	// The associated pull request
	PullRequest *PullRequest `json:"pullRequest,omitempty"`
	// The repository associated with this node.
	Repository *Repository `json:"repository"`
}

func (*DependabotUpdate) isRepositoryNode() {}

// An error produced from a Dependabot Update
type DependabotUpdateError struct {
	// The body of the error
	Body string `json:"body"`
	// The error code
	ErrorType string `json:"errorType"`
	// The title of the error
	Title string `json:"title"`
}

// A dependency manifest entry
type DependencyGraphDependency struct {
	// Does the dependency itself have dependencies?
	HasDependencies bool `json:"hasDependencies"`
	// The original name of the package, as it appears in the manifest.
	PackageLabel string `json:"packageLabel"`
	// The dependency package manager
	PackageManager *string `json:"packageManager,omitempty"`
	// The name of the package in the canonical form used by the package manager.
	PackageName string `json:"packageName"`
	// Public preview: The dependency package URL
	PackageUrl *URI `json:"packageUrl,omitempty"`
	// Public preview: The relationship of the dependency. Can be direct, transitive, or unknown
	Relationship string `json:"relationship"`
	// The repository containing the package
	Repository *Repository `json:"repository,omitempty"`
	// The dependency version requirements
	Requirements string `json:"requirements"`
}

// The connection type for DependencyGraphDependency.
type DependencyGraphDependencyConnection struct {
	// A list of edges.
	Edges []*DependencyGraphDependencyEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*DependencyGraphDependency `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type DependencyGraphDependencyEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *DependencyGraphDependency `json:"node,omitempty"`
}

// The possible ecosystems of a dependency graph package.
type DependencyGraphEcosystem string

const (
	// GitHub Actions
	DependencyGraphEcosystemActions DependencyGraphEcosystem = "ACTIONS"
	// PHP packages hosted at packagist.org
	DependencyGraphEcosystemComposer DependencyGraphEcosystem = "COMPOSER"
	// Go modules
	DependencyGraphEcosystemGo DependencyGraphEcosystem = "GO"
	// Java artifacts hosted at the Maven central repository
	DependencyGraphEcosystemMaven DependencyGraphEcosystem = "MAVEN"
	// JavaScript packages hosted at npmjs.com
	DependencyGraphEcosystemNpm DependencyGraphEcosystem = "NPM"
	// .NET packages hosted at the NuGet Gallery
	DependencyGraphEcosystemNuget DependencyGraphEcosystem = "NUGET"
	// Python packages hosted at PyPI.org
	DependencyGraphEcosystemPip DependencyGraphEcosystem = "PIP"
	// Dart packages hosted at pub.dev
	DependencyGraphEcosystemPub DependencyGraphEcosystem = "PUB"
	// Ruby gems hosted at RubyGems.org
	DependencyGraphEcosystemRubygems DependencyGraphEcosystem = "RUBYGEMS"
	// Rust crates
	DependencyGraphEcosystemRust DependencyGraphEcosystem = "RUST"
	// Swift packages
	DependencyGraphEcosystemSwift DependencyGraphEcosystem = "SWIFT"
)

// Dependency manifest for a repository
type DependencyGraphManifest struct {
	// Path to view the manifest file blob
	BlobPath string `json:"blobPath"`
	// A list of manifest dependencies
	Dependencies *DependencyGraphDependencyConnection `json:"dependencies,omitempty"`
	// The number of dependencies listed in the manifest
	DependenciesCount *int32 `json:"dependenciesCount,omitempty"`
	// Is the manifest too big to parse?
	ExceedsMaxSize bool `json:"exceedsMaxSize"`
	// Fully qualified manifest filename
	Filename string `json:"filename"`
	// The Node ID of the DependencyGraphManifest object
	Id string `json:"id"`
	// Were we able to parse the manifest?
	Parseable bool `json:"parseable"`
	// The repository containing the manifest
	Repository *Repository `json:"repository"`
}

func (*DependencyGraphManifest) isNode() {}

// The connection type for DependencyGraphManifest.
type DependencyGraphManifestConnection struct {
	// A list of edges.
	Edges []*DependencyGraphManifestEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*DependencyGraphManifest `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type DependencyGraphManifestEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *DependencyGraphManifest `json:"node,omitempty"`
}

// A repository deploy key.
type DeployKey struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Whether or not the deploy key is enabled by policy at the Enterprise or Organization level.
	Enabled bool `json:"enabled"`
	// The Node ID of the DeployKey object
	Id string `json:"id"`
	// The deploy key.
	Key string `json:"key"`
	// Whether or not the deploy key is read only.
	ReadOnly bool `json:"readOnly"`
	// The deploy key title.
	Title string `json:"title"`
	// Whether or not the deploy key has been verified.
	Verified bool `json:"verified"`
}

func (*DeployKey) isNode() {}

// The connection type for DeployKey.
type DeployKeyConnection struct {
	// A list of edges.
	Edges []*DeployKeyEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*DeployKey `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type DeployKeyEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *DeployKey `json:"node,omitempty"`
}

// Represents a 'deployed' event on a given pull request.
type DeployedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The deployment associated with the 'deployed' event.
	Deployment *Deployment `json:"deployment"`
	// The Node ID of the DeployedEvent object
	Id string `json:"id"`
	// PullRequest referenced by event.
	PullRequest *PullRequest `json:"pullRequest"`
	// The ref associated with the 'deployed' event.
	Ref *Ref `json:"ref,omitempty"`
}

func (*DeployedEvent) isNode() {}

func (*DeployedEvent) isPullRequestTimelineItem() {}

func (*DeployedEvent) isPullRequestTimelineItems() {}

// Represents triggered deployment instance.
type Deployment struct {
	// Identifies the commit sha of the deployment.
	Commit *Commit `json:"commit,omitempty"`
	// Identifies the oid of the deployment commit, even if the commit has been deleted.
	CommitOid string `json:"commitOid"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the actor who triggered the deployment.
	Creator *Actor `json:"creator"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The deployment description.
	Description *string `json:"description,omitempty"`
	// The latest environment to which this deployment was made.
	Environment *string `json:"environment,omitempty"`
	// The Node ID of the Deployment object
	Id string `json:"id"`
	// The latest environment to which this deployment was made.
	LatestEnvironment *string `json:"latestEnvironment,omitempty"`
	// The latest status of this deployment.
	LatestStatus *DeploymentStatus `json:"latestStatus,omitempty"`
	// The original environment to which this deployment was made.
	OriginalEnvironment *string `json:"originalEnvironment,omitempty"`
	// Extra information that a deployment system might need.
	Payload *string `json:"payload,omitempty"`
	// Identifies the Ref of the deployment, if the deployment was created by ref.
	Ref *Ref `json:"ref,omitempty"`
	// Identifies the repository associated with the deployment.
	Repository *Repository `json:"repository"`
	// The current state of the deployment.
	State *DeploymentState `json:"state,omitempty"`
	// A list of statuses associated with the deployment.
	Statuses *DeploymentStatusConnection `json:"statuses,omitempty"`
	// The deployment task.
	Task *string `json:"task,omitempty"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
}

func (*Deployment) isNode() {}

// The connection type for Deployment.
type DeploymentConnection struct {
	// A list of edges.
	Edges []*DeploymentEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*Deployment `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type DeploymentEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *Deployment `json:"node,omitempty"`
}

// Represents a 'deployment_environment_changed' event on a given pull request.
type DeploymentEnvironmentChangedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The deployment status that updated the deployment environment.
	DeploymentStatus *DeploymentStatus `json:"deploymentStatus"`
	// The Node ID of the DeploymentEnvironmentChangedEvent object
	Id string `json:"id"`
	// PullRequest referenced by event.
	PullRequest *PullRequest `json:"pullRequest"`
}

func (*DeploymentEnvironmentChangedEvent) isNode() {}

func (*DeploymentEnvironmentChangedEvent) isPullRequestTimelineItem() {}

func (*DeploymentEnvironmentChangedEvent) isPullRequestTimelineItems() {}

// Ordering options for deployment connections
type DeploymentOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order deployments by.
	Field DeploymentOrderField `json:"field"`
}

// Properties by which deployment connections can be ordered.
type DeploymentOrderField string

const (
	// Order collection by creation time
	DeploymentOrderFieldCreatedAt DeploymentOrderField = "CREATED_AT"
)

// A protection rule.
type DeploymentProtectionRule struct {
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// Whether deployments to this environment can be approved by the user who created the deployment.
	PreventSelfReview *bool `json:"preventSelfReview,omitempty"`
	// The teams or users that can review the deployment
	Reviewers *DeploymentReviewerConnection `json:"reviewers"`
	// The timeout in minutes for this protection rule.
	Timeout int32 `json:"timeout"`
	// The type of protection rule.
	Type DeploymentProtectionRuleType `json:"type"`
}

// The connection type for DeploymentProtectionRule.
type DeploymentProtectionRuleConnection struct {
	// A list of edges.
	Edges []*DeploymentProtectionRuleEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*DeploymentProtectionRule `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type DeploymentProtectionRuleEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *DeploymentProtectionRule `json:"node,omitempty"`
}

// The possible protection rule types.
type DeploymentProtectionRuleType string

const (
	// Branch policy
	DeploymentProtectionRuleTypeBranchPolicy DeploymentProtectionRuleType = "BRANCH_POLICY"
	// Required reviewers
	DeploymentProtectionRuleTypeRequiredReviewers DeploymentProtectionRuleType = "REQUIRED_REVIEWERS"
	// Wait timer
	DeploymentProtectionRuleTypeWaitTimer DeploymentProtectionRuleType = "WAIT_TIMER"
)

// A request to deploy a workflow run to an environment.
type DeploymentRequest struct {
	// Whether or not the current user can approve the deployment
	CurrentUserCanApprove bool `json:"currentUserCanApprove"`
	// The target environment of the deployment
	Environment *Environment `json:"environment"`
	// The teams or users that can review the deployment
	Reviewers *DeploymentReviewerConnection `json:"reviewers"`
	// The wait timer in minutes configured in the environment
	WaitTimer int32 `json:"waitTimer"`
	// The wait timer in minutes configured in the environment
	WaitTimerStartedAt *DateTime `json:"waitTimerStartedAt,omitempty"`
}

// The connection type for DeploymentRequest.
type DeploymentRequestConnection struct {
	// A list of edges.
	Edges []*DeploymentRequestEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*DeploymentRequest `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type DeploymentRequestEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *DeploymentRequest `json:"node,omitempty"`
}

// A deployment review.
type DeploymentReview struct {
	// The comment the user left.
	Comment string `json:"comment"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The environments approved or rejected
	Environments *EnvironmentConnection `json:"environments"`
	// The Node ID of the DeploymentReview object
	Id string `json:"id"`
	// The decision of the user.
	State DeploymentReviewState `json:"state"`
	// The user that reviewed the deployment.
	User *User `json:"user"`
}

func (*DeploymentReview) isNode() {}

// The connection type for DeploymentReview.
type DeploymentReviewConnection struct {
	// A list of edges.
	Edges []*DeploymentReviewEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*DeploymentReview `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type DeploymentReviewEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *DeploymentReview `json:"node,omitempty"`
}

// The possible states for a deployment review.
type DeploymentReviewState string

const (
	// The deployment was approved.
	DeploymentReviewStateApproved DeploymentReviewState = "APPROVED"
	// The deployment was rejected.
	DeploymentReviewStateRejected DeploymentReviewState = "REJECTED"
)

// Users and teams.
type DeploymentReviewer struct {
	// Underlying value of the GraphQL union
	Value DeploymentReviewerValue `json:"-"`
}

func (base *DeploymentReviewer) UnmarshalJSON(b []byte) error {
	type Raw DeploymentReviewer
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Team":
		base.Value = new(Team)
	case "User":
		base.Value = new(User)
	case "":
		return fmt.Errorf("gqlclient: union DeploymentReviewer: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union DeploymentReviewer: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// DeploymentReviewerValue is one of: Team | User
type DeploymentReviewerValue interface {
	isDeploymentReviewer()
}

// The connection type for DeploymentReviewer.
type DeploymentReviewerConnection struct {
	// A list of edges.
	Edges []*DeploymentReviewerEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*DeploymentReviewer `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type DeploymentReviewerEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *DeploymentReviewer `json:"node,omitempty"`
}

// The possible states in which a deployment can be.
type DeploymentState string

const (
	// The pending deployment was not updated after 30 minutes.
	DeploymentStateAbandoned DeploymentState = "ABANDONED"
	// The deployment is currently active.
	DeploymentStateActive DeploymentState = "ACTIVE"
	// An inactive transient deployment.
	DeploymentStateDestroyed DeploymentState = "DESTROYED"
	// The deployment experienced an error.
	DeploymentStateError DeploymentState = "ERROR"
	// The deployment has failed.
	DeploymentStateFailure DeploymentState = "FAILURE"
	// The deployment is inactive.
	DeploymentStateInactive DeploymentState = "INACTIVE"
	// The deployment is in progress.
	DeploymentStateInProgress DeploymentState = "IN_PROGRESS"
	// The deployment is pending.
	DeploymentStatePending DeploymentState = "PENDING"
	// The deployment has queued
	DeploymentStateQueued DeploymentState = "QUEUED"
	// The deployment was successful.
	DeploymentStateSuccess DeploymentState = "SUCCESS"
	// The deployment is waiting.
	DeploymentStateWaiting DeploymentState = "WAITING"
)

// Describes the status of a given deployment attempt.
type DeploymentStatus struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the actor who triggered the deployment.
	Creator *Actor `json:"creator"`
	// Identifies the deployment associated with status.
	Deployment *Deployment `json:"deployment"`
	// Identifies the description of the deployment.
	Description *string `json:"description,omitempty"`
	// Identifies the environment of the deployment at the time of this deployment status
	Environment *string `json:"environment,omitempty"`
	// Identifies the environment URL of the deployment.
	EnvironmentUrl *URI `json:"environmentUrl,omitempty"`
	// The Node ID of the DeploymentStatus object
	Id string `json:"id"`
	// Identifies the log URL of the deployment.
	LogUrl *URI `json:"logUrl,omitempty"`
	// Identifies the current state of the deployment.
	State DeploymentStatusState `json:"state"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
}

func (*DeploymentStatus) isNode() {}

// The connection type for DeploymentStatus.
type DeploymentStatusConnection struct {
	// A list of edges.
	Edges []*DeploymentStatusEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*DeploymentStatus `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type DeploymentStatusEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *DeploymentStatus `json:"node,omitempty"`
}

// The possible states for a deployment status.
type DeploymentStatusState string

const (
	// The deployment experienced an error.
	DeploymentStatusStateError DeploymentStatusState = "ERROR"
	// The deployment has failed.
	DeploymentStatusStateFailure DeploymentStatusState = "FAILURE"
	// The deployment is inactive.
	DeploymentStatusStateInactive DeploymentStatusState = "INACTIVE"
	// The deployment is in progress.
	DeploymentStatusStateInProgress DeploymentStatusState = "IN_PROGRESS"
	// The deployment is pending.
	DeploymentStatusStatePending DeploymentStatusState = "PENDING"
	// The deployment is queued
	DeploymentStatusStateQueued DeploymentStatusState = "QUEUED"
	// The deployment was successful.
	DeploymentStatusStateSuccess DeploymentStatusState = "SUCCESS"
	// The deployment is waiting.
	DeploymentStatusStateWaiting DeploymentStatusState = "WAITING"
)

// Autogenerated input type of DequeuePullRequest
type DequeuePullRequestInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the pull request to be dequeued.
	Id string `json:"id"`
}

// Autogenerated return type of DequeuePullRequest.
type DequeuePullRequestPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The merge queue entry of the dequeued pull request.
	MergeQueueEntry *MergeQueueEntry `json:"mergeQueueEntry,omitempty"`
}

// The possible sides of a diff.
type DiffSide string

const (
	// The left side of the diff.
	DiffSideLeft DiffSide = "LEFT"
	// The right side of the diff.
	DiffSideRight DiffSide = "RIGHT"
)

// Autogenerated input type of DisablePullRequestAutoMerge
type DisablePullRequestAutoMergeInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// ID of the pull request to disable auto merge on.
	PullRequestId string `json:"pullRequestId"`
}

// Autogenerated return type of DisablePullRequestAutoMerge.
type DisablePullRequestAutoMergePayload struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The pull request auto merge was disabled on.
	PullRequest *PullRequest `json:"pullRequest,omitempty"`
}

// Represents a 'disconnected' event on a given issue or pull request.
type DisconnectedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the DisconnectedEvent object
	Id string `json:"id"`
	// Reference originated in a different repository.
	IsCrossRepository bool `json:"isCrossRepository"`
	// Issue or pull request from which the issue was disconnected.
	Source ReferencedSubject `json:"source"`
	// Issue or pull request which was disconnected.
	Subject ReferencedSubject `json:"subject"`
}

func (*DisconnectedEvent) isNode() {}

func (*DisconnectedEvent) isIssueTimelineItems() {}

func (*DisconnectedEvent) isPullRequestTimelineItems() {}

// A discussion in a repository.
type Discussion struct {
	// Reason that the conversation was locked.
	ActiveLockReason *LockReason `json:"activeLockReason,omitempty"`
	// The comment chosen as this discussion's answer, if any.
	Answer *DiscussionComment `json:"answer,omitempty"`
	// The time when a user chose this discussion's answer, if answered.
	AnswerChosenAt *DateTime `json:"answerChosenAt,omitempty"`
	// The user who chose this discussion's answer, if answered.
	AnswerChosenBy *Actor `json:"answerChosenBy,omitempty"`
	// The actor who authored the comment.
	Author *Actor `json:"author,omitempty"`
	// Author's association with the subject of the comment.
	AuthorAssociation CommentAuthorAssociation `json:"authorAssociation"`
	// The main text of the discussion post.
	Body string `json:"body"`
	// The body rendered to HTML.
	BodyHTML HTML `json:"bodyHTML"`
	// The body rendered to text.
	BodyText string `json:"bodyText"`
	// The category for this discussion.
	Category *DiscussionCategory `json:"category"`
	// Indicates if the object is closed (definition of closed may depend on type)
	Closed bool `json:"closed"`
	// Identifies the date and time when the object was closed.
	ClosedAt *DateTime `json:"closedAt,omitempty"`
	// The replies to the discussion.
	Comments *DiscussionCommentConnection `json:"comments"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Check if this comment was created via an email reply.
	CreatedViaEmail bool `json:"createdViaEmail"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The actor who edited the comment.
	Editor *Actor `json:"editor,omitempty"`
	// The Node ID of the Discussion object
	Id string `json:"id"`
	// Check if this comment was edited and includes an edit with the creation data
	IncludesCreatedEdit bool `json:"includesCreatedEdit"`
	// Only return answered/unanswered discussions
	IsAnswered *bool `json:"isAnswered,omitempty"`
	// A list of labels associated with the object.
	Labels *LabelConnection `json:"labels,omitempty"`
	// The moment the editor made the last edit
	LastEditedAt *DateTime `json:"lastEditedAt,omitempty"`
	// `true` if the object is locked
	Locked bool `json:"locked"`
	// The number identifying this discussion within the repository.
	Number int32 `json:"number"`
	// The poll associated with this discussion, if one exists.
	Poll *DiscussionPoll `json:"poll,omitempty"`
	// Identifies when the comment was published at.
	PublishedAt *DateTime `json:"publishedAt,omitempty"`
	// A list of reactions grouped by content left on the subject.
	ReactionGroups []ReactionGroup `json:"reactionGroups,omitempty"`
	// A list of Reactions left on the Issue.
	Reactions *ReactionConnection `json:"reactions"`
	// The repository associated with this node.
	Repository *Repository `json:"repository"`
	// The path for this discussion.
	ResourcePath URI `json:"resourcePath"`
	// Identifies the reason for the discussion's state.
	StateReason *DiscussionStateReason `json:"stateReason,omitempty"`
	// The title of this discussion.
	Title string `json:"title"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// Number of upvotes that this subject has received.
	UpvoteCount int32 `json:"upvoteCount"`
	// The URL for this discussion.
	Url URI `json:"url"`
	// A list of edits to this content.
	UserContentEdits *UserContentEditConnection `json:"userContentEdits,omitempty"`
	// Indicates if the object can be closed by the viewer.
	ViewerCanClose bool `json:"viewerCanClose"`
	// Check if the current viewer can delete this object.
	ViewerCanDelete bool `json:"viewerCanDelete"`
	// Indicates if the viewer can edit labels for this object.
	ViewerCanLabel bool `json:"viewerCanLabel"`
	// Can user react to this subject
	ViewerCanReact bool `json:"viewerCanReact"`
	// Indicates if the object can be reopened by the viewer.
	ViewerCanReopen bool `json:"viewerCanReopen"`
	// Check if the viewer is able to change their subscription status for the repository.
	ViewerCanSubscribe bool `json:"viewerCanSubscribe"`
	// Check if the current viewer can update this object.
	ViewerCanUpdate bool `json:"viewerCanUpdate"`
	// Whether or not the current user can add or remove an upvote on this subject.
	ViewerCanUpvote bool `json:"viewerCanUpvote"`
	// Did the viewer author this comment.
	ViewerDidAuthor bool `json:"viewerDidAuthor"`
	// Whether or not the current user has already upvoted this subject.
	ViewerHasUpvoted bool `json:"viewerHasUpvoted"`
	// Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
	ViewerSubscription *SubscriptionState `json:"viewerSubscription,omitempty"`
}

func (*Discussion) isClosable() {}

func (*Discussion) isComment() {}

func (*Discussion) isDeletable() {}

func (*Discussion) isLabelable() {}

func (*Discussion) isLockable() {}

func (*Discussion) isNode() {}

func (*Discussion) isReactable() {}

func (*Discussion) isRepositoryNode() {}

func (*Discussion) isSubscribable() {}

func (*Discussion) isUpdatable() {}

func (*Discussion) isVotable() {}

func (*Discussion) isSearchResultItem() {}

// A category for discussions in a repository.
type DiscussionCategory struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// A description of this category.
	Description *string `json:"description,omitempty"`
	// An emoji representing this category.
	Emoji string `json:"emoji"`
	// This category's emoji rendered as HTML.
	EmojiHTML HTML `json:"emojiHTML"`
	// The Node ID of the DiscussionCategory object
	Id string `json:"id"`
	// Whether or not discussions in this category support choosing an answer with the markDiscussionCommentAsAnswer mutation.
	IsAnswerable bool `json:"isAnswerable"`
	// The name of this category.
	Name string `json:"name"`
	// The repository associated with this node.
	Repository *Repository `json:"repository"`
	// The slug of this category.
	Slug string `json:"slug"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
}

func (*DiscussionCategory) isNode() {}

func (*DiscussionCategory) isRepositoryNode() {}

// The connection type for DiscussionCategory.
type DiscussionCategoryConnection struct {
	// A list of edges.
	Edges []*DiscussionCategoryEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*DiscussionCategory `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type DiscussionCategoryEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *DiscussionCategory `json:"node,omitempty"`
}

// The possible reasons for closing a discussion.
type DiscussionCloseReason string

const (
	// The discussion is a duplicate of another
	DiscussionCloseReasonDuplicate DiscussionCloseReason = "DUPLICATE"
	// The discussion is no longer relevant
	DiscussionCloseReasonOutdated DiscussionCloseReason = "OUTDATED"
	// The discussion has been resolved
	DiscussionCloseReasonResolved DiscussionCloseReason = "RESOLVED"
)

// A comment on a discussion.
type DiscussionComment struct {
	// The actor who authored the comment.
	Author *Actor `json:"author,omitempty"`
	// Author's association with the subject of the comment.
	AuthorAssociation CommentAuthorAssociation `json:"authorAssociation"`
	// The body as Markdown.
	Body string `json:"body"`
	// The body rendered to HTML.
	BodyHTML HTML `json:"bodyHTML"`
	// The body rendered to text.
	BodyText string `json:"bodyText"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Check if this comment was created via an email reply.
	CreatedViaEmail bool `json:"createdViaEmail"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The time when this replied-to comment was deleted
	DeletedAt *DateTime `json:"deletedAt,omitempty"`
	// The discussion this comment was created in
	Discussion *Discussion `json:"discussion,omitempty"`
	// The actor who edited the comment.
	Editor *Actor `json:"editor,omitempty"`
	// The Node ID of the DiscussionComment object
	Id string `json:"id"`
	// Check if this comment was edited and includes an edit with the creation data
	IncludesCreatedEdit bool `json:"includesCreatedEdit"`
	// Has this comment been chosen as the answer of its discussion?
	IsAnswer bool `json:"isAnswer"`
	// Returns whether or not a comment has been minimized.
	IsMinimized bool `json:"isMinimized"`
	// The moment the editor made the last edit
	LastEditedAt *DateTime `json:"lastEditedAt,omitempty"`
	// Returns why the comment was minimized. One of `abuse`, `off-topic`,
	// `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
	// formatting of these values differs from the inputs to the `MinimizeComment` mutation.
	MinimizedReason *string `json:"minimizedReason,omitempty"`
	// Identifies when the comment was published at.
	PublishedAt *DateTime `json:"publishedAt,omitempty"`
	// A list of reactions grouped by content left on the subject.
	ReactionGroups []ReactionGroup `json:"reactionGroups,omitempty"`
	// A list of Reactions left on the Issue.
	Reactions *ReactionConnection `json:"reactions"`
	// The threaded replies to this comment.
	Replies *DiscussionCommentConnection `json:"replies"`
	// The discussion comment this comment is a reply to
	ReplyTo *DiscussionComment `json:"replyTo,omitempty"`
	// The path for this discussion comment.
	ResourcePath URI `json:"resourcePath"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// Number of upvotes that this subject has received.
	UpvoteCount int32 `json:"upvoteCount"`
	// The URL for this discussion comment.
	Url URI `json:"url"`
	// A list of edits to this content.
	UserContentEdits *UserContentEditConnection `json:"userContentEdits,omitempty"`
	// Check if the current viewer can delete this object.
	ViewerCanDelete bool `json:"viewerCanDelete"`
	// Can the current user mark this comment as an answer?
	ViewerCanMarkAsAnswer bool `json:"viewerCanMarkAsAnswer"`
	// Check if the current viewer can minimize this object.
	ViewerCanMinimize bool `json:"viewerCanMinimize"`
	// Can user react to this subject
	ViewerCanReact bool `json:"viewerCanReact"`
	// Can the current user unmark this comment as an answer?
	ViewerCanUnmarkAsAnswer bool `json:"viewerCanUnmarkAsAnswer"`
	// Check if the current viewer can update this object.
	ViewerCanUpdate bool `json:"viewerCanUpdate"`
	// Whether or not the current user can add or remove an upvote on this subject.
	ViewerCanUpvote bool `json:"viewerCanUpvote"`
	// Reasons why the current viewer can not update this comment.
	ViewerCannotUpdateReasons []CommentCannotUpdateReason `json:"viewerCannotUpdateReasons"`
	// Did the viewer author this comment.
	ViewerDidAuthor bool `json:"viewerDidAuthor"`
	// Whether or not the current user has already upvoted this subject.
	ViewerHasUpvoted bool `json:"viewerHasUpvoted"`
}

func (*DiscussionComment) isComment() {}

func (*DiscussionComment) isDeletable() {}

func (*DiscussionComment) isMinimizable() {}

func (*DiscussionComment) isNode() {}

func (*DiscussionComment) isReactable() {}

func (*DiscussionComment) isUpdatable() {}

func (*DiscussionComment) isUpdatableComment() {}

func (*DiscussionComment) isVotable() {}

// The connection type for DiscussionComment.
type DiscussionCommentConnection struct {
	// A list of edges.
	Edges []*DiscussionCommentEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*DiscussionComment `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type DiscussionCommentEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *DiscussionComment `json:"node,omitempty"`
}

// The connection type for Discussion.
type DiscussionConnection struct {
	// A list of edges.
	Edges []*DiscussionEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*Discussion `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type DiscussionEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *Discussion `json:"node,omitempty"`
}

// Ways in which lists of discussions can be ordered upon return.
type DiscussionOrder struct {
	// The direction in which to order discussions by the specified field.
	Direction OrderDirection `json:"direction"`
	// The field by which to order discussions.
	Field DiscussionOrderField `json:"field"`
}

// Properties by which discussion connections can be ordered.
type DiscussionOrderField string

const (
	// Order discussions by creation time.
	DiscussionOrderFieldCreatedAt DiscussionOrderField = "CREATED_AT"
	// Order discussions by most recent modification time.
	DiscussionOrderFieldUpdatedAt DiscussionOrderField = "UPDATED_AT"
)

// A poll for a discussion.
type DiscussionPoll struct {
	// The discussion that this poll belongs to.
	Discussion *Discussion `json:"discussion,omitempty"`
	// The Node ID of the DiscussionPoll object
	Id string `json:"id"`
	// The options for this poll.
	Options *DiscussionPollOptionConnection `json:"options,omitempty"`
	// The question that is being asked by this poll.
	Question string `json:"question"`
	// The total number of votes that have been cast for this poll.
	TotalVoteCount int32 `json:"totalVoteCount"`
	// Indicates if the viewer has permission to vote in this poll.
	ViewerCanVote bool `json:"viewerCanVote"`
	// Indicates if the viewer has voted for any option in this poll.
	ViewerHasVoted bool `json:"viewerHasVoted"`
}

func (*DiscussionPoll) isNode() {}

// An option for a discussion poll.
type DiscussionPollOption struct {
	// The Node ID of the DiscussionPollOption object
	Id string `json:"id"`
	// The text for this option.
	Option string `json:"option"`
	// The discussion poll that this option belongs to.
	Poll *DiscussionPoll `json:"poll,omitempty"`
	// The total number of votes that have been cast for this option.
	TotalVoteCount int32 `json:"totalVoteCount"`
	// Indicates if the viewer has voted for this option in the poll.
	ViewerHasVoted bool `json:"viewerHasVoted"`
}

func (*DiscussionPollOption) isNode() {}

// The connection type for DiscussionPollOption.
type DiscussionPollOptionConnection struct {
	// A list of edges.
	Edges []*DiscussionPollOptionEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*DiscussionPollOption `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type DiscussionPollOptionEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *DiscussionPollOption `json:"node,omitempty"`
}

// Ordering options for discussion poll option connections.
type DiscussionPollOptionOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order poll options by.
	Field DiscussionPollOptionOrderField `json:"field"`
}

// Properties by which discussion poll option connections can be ordered.
type DiscussionPollOptionOrderField string

const (
	// Order poll options by the order that the poll author specified when creating the poll.
	DiscussionPollOptionOrderFieldAuthoredOrder DiscussionPollOptionOrderField = "AUTHORED_ORDER"
	// Order poll options by the number of votes it has.
	DiscussionPollOptionOrderFieldVoteCount DiscussionPollOptionOrderField = "VOTE_COUNT"
)

// The possible states of a discussion.
type DiscussionState string

const (
	// A discussion that has been closed
	DiscussionStateClosed DiscussionState = "CLOSED"
	// A discussion that is open
	DiscussionStateOpen DiscussionState = "OPEN"
)

// The possible state reasons of a discussion.
type DiscussionStateReason string

const (
	// The discussion is a duplicate of another
	DiscussionStateReasonDuplicate DiscussionStateReason = "DUPLICATE"
	// The discussion is no longer relevant
	DiscussionStateReasonOutdated DiscussionStateReason = "OUTDATED"
	// The discussion was reopened
	DiscussionStateReasonReopened DiscussionStateReason = "REOPENED"
	// The discussion has been resolved
	DiscussionStateReasonResolved DiscussionStateReason = "RESOLVED"
)

// Autogenerated input type of DismissPullRequestReview
type DismissPullRequestReviewInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The contents of the pull request review dismissal message.
	Message string `json:"message"`
	// The Node ID of the pull request review to modify.
	PullRequestReviewId string `json:"pullRequestReviewId"`
}

// Autogenerated return type of DismissPullRequestReview.
type DismissPullRequestReviewPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The dismissed pull request review.
	PullRequestReview *PullRequestReview `json:"pullRequestReview,omitempty"`
}

// The possible reasons that a Dependabot alert was dismissed.
type DismissReason string

const (
	// A fix has already been started
	DismissReasonFixStarted DismissReason = "FIX_STARTED"
	// This alert is inaccurate or incorrect
	DismissReasonInaccurate DismissReason = "INACCURATE"
	// Vulnerable code is not actually used
	DismissReasonNotUsed DismissReason = "NOT_USED"
	// No bandwidth to fix this
	DismissReasonNoBandwidth DismissReason = "NO_BANDWIDTH"
	// Risk is tolerable to this project
	DismissReasonTolerableRisk DismissReason = "TOLERABLE_RISK"
)

// Autogenerated input type of DismissRepositoryVulnerabilityAlert
type DismissRepositoryVulnerabilityAlertInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The reason the Dependabot alert is being dismissed.
	DismissReason DismissReason `json:"dismissReason"`
	// The Dependabot alert ID to dismiss.
	RepositoryVulnerabilityAlertId string `json:"repositoryVulnerabilityAlertId"`
}

// Autogenerated return type of DismissRepositoryVulnerabilityAlert.
type DismissRepositoryVulnerabilityAlertPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Dependabot alert that was dismissed
	RepositoryVulnerabilityAlert *RepositoryVulnerabilityAlert `json:"repositoryVulnerabilityAlert,omitempty"`
}

// A draft issue within a project.
type DraftIssue struct {
	// A list of users to assigned to this draft issue.
	Assignees *UserConnection `json:"assignees"`
	// The body of the draft issue.
	Body string `json:"body"`
	// The body of the draft issue rendered to HTML.
	BodyHTML HTML `json:"bodyHTML"`
	// The body of the draft issue rendered to text.
	BodyText string `json:"bodyText"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The actor who created this draft issue.
	Creator *Actor `json:"creator,omitempty"`
	// The Node ID of the DraftIssue object
	Id string `json:"id"`
	// List of items linked with the draft issue (currently draft issue can be linked to only one item).
	ProjectV2Items *ProjectV2ItemConnection `json:"projectV2Items"`
	// Projects that link to this draft issue (currently draft issue can be linked to only one project).
	ProjectsV2 *ProjectV2Connection `json:"projectsV2"`
	// The title of the draft issue
	Title string `json:"title"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
}

func (*DraftIssue) isNode() {}

func (*DraftIssue) isProjectV2ItemContent() {}

// Specifies a review comment to be left with a Pull Request Review.
type DraftPullRequestReviewComment struct {
	// Body of the comment to leave.
	Body string `json:"body"`
	// Path to the file being commented on.
	Path string `json:"path"`
	// Position in the file to leave a comment on.
	Position int32 `json:"position"`
}

// Specifies a review comment thread to be left with a Pull Request Review.
type DraftPullRequestReviewThread struct {
	// Body of the comment to leave.
	Body string `json:"body"`
	// The line of the blob to which the thread refers. The end of the line range for multi-line comments.
	Line int32 `json:"line"`
	// Path to the file being commented on.
	Path string `json:"path"`
	// The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range.
	Side *DiffSide `json:"side,omitempty"`
	// The first line of the range to which the comment refers.
	StartLine *int32 `json:"startLine,omitempty"`
	// The side of the diff on which the start line resides.
	StartSide *DiffSide `json:"startSide,omitempty"`
}

// The Exploit Prediction Scoring System
type EPSS struct {
	// The EPSS percentage represents the likelihood of a CVE being exploited.
	Percentage *float64 `json:"percentage,omitempty"`
	// The EPSS percentile represents the relative rank of the CVE's likelihood of being exploited compared to other CVEs.
	Percentile *float64 `json:"percentile,omitempty"`
}

// Autogenerated input type of EnablePullRequestAutoMerge
type EnablePullRequestAutoMergeInput struct {
	// The email address to associate with this merge.
	AuthorEmail *string `json:"authorEmail,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Commit body to use for the commit when the PR is mergable; if omitted, a
	// default message will be used. NOTE: when merging with a merge queue any input
	// value for commit message is ignored.
	CommitBody *string `json:"commitBody,omitempty"`
	// Commit headline to use for the commit when the PR is mergable; if omitted, a
	// default message will be used. NOTE: when merging with a merge queue any input
	// value for commit headline is ignored.
	CommitHeadline *string `json:"commitHeadline,omitempty"`
	// The expected head OID of the pull request.
	ExpectedHeadOid *GitObjectID `json:"expectedHeadOid,omitempty"`
	// The merge method to use. If omitted, defaults to `MERGE`. NOTE: when merging
	// with a merge queue any input value for merge method is ignored.
	MergeMethod *PullRequestMergeMethod `json:"mergeMethod,omitempty"`
	// ID of the pull request to enable auto-merge on.
	PullRequestId string `json:"pullRequestId"`
}

// Autogenerated return type of EnablePullRequestAutoMerge.
type EnablePullRequestAutoMergePayload struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The pull request auto-merge was enabled on.
	PullRequest *PullRequest `json:"pullRequest,omitempty"`
}

// Autogenerated input type of EnqueuePullRequest
type EnqueuePullRequestInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The expected head OID of the pull request.
	ExpectedHeadOid *GitObjectID `json:"expectedHeadOid,omitempty"`
	// Add the pull request to the front of the queue.
	Jump *bool `json:"jump,omitempty"`
	// The ID of the pull request to enqueue.
	PullRequestId string `json:"pullRequestId"`
}

// Autogenerated return type of EnqueuePullRequest.
type EnqueuePullRequestPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The merge queue entry for the enqueued pull request.
	MergeQueueEntry *MergeQueueEntry `json:"mergeQueueEntry,omitempty"`
}

// An account to manage multiple organizations with consolidated policy and billing.
type Enterprise struct {
	// The announcement banner set on this enterprise, if any. Only visible to members of the enterprise.
	AnnouncementBanner *AnnouncementBanner `json:"announcementBanner,omitempty"`
	// A URL pointing to the enterprise's public avatar.
	AvatarUrl URI `json:"avatarUrl"`
	// The enterprise's billing email.
	BillingEmail *string `json:"billingEmail,omitempty"`
	// Enterprise billing informationvisible to enterprise billing managers.
	BillingInfo *EnterpriseBillingInfo `json:"billingInfo,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The description of the enterprise.
	Description *string `json:"description,omitempty"`
	// The description of the enterprise as HTML.
	DescriptionHTML HTML `json:"descriptionHTML"`
	// The Node ID of the Enterprise object
	Id string `json:"id"`
	// The location of the enterprise.
	Location *string `json:"location,omitempty"`
	// A list of users who are members of this enterprise.
	Members *EnterpriseMemberConnection `json:"members"`
	// The name of the enterprise.
	Name string `json:"name"`
	// A list of organizations that belong to this enterprise.
	Organizations *OrganizationConnection `json:"organizations"`
	// Enterprise information visible to enterprise owners or enterprise owners'
	// personal access tokens (classic) with read:enterprise or admin:enterprise scope.
	OwnerInfo *EnterpriseOwnerInfo `json:"ownerInfo,omitempty"`
	// The raw content of the enterprise README.
	Readme *string `json:"readme,omitempty"`
	// The content of the enterprise README as HTML.
	ReadmeHTML HTML `json:"readmeHTML"`
	// The HTTP path for this enterprise.
	ResourcePath URI `json:"resourcePath"`
	// Returns a single ruleset from the current enterprise by ID.
	Ruleset *RepositoryRuleset `json:"ruleset,omitempty"`
	// A list of rulesets for this enterprise.
	Rulesets *RepositoryRulesetConnection `json:"rulesets,omitempty"`
	// The URL-friendly identifier for the enterprise.
	Slug string `json:"slug"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The HTTP URL for this enterprise.
	Url URI `json:"url"`
	// A list of repositories that belong to users. Only available for enterprises with Enterprise Managed Users.
	UserNamespaceRepositories *UserNamespaceRepositoryConnection `json:"userNamespaceRepositories"`
	// Is the current viewer an admin of this enterprise?
	ViewerIsAdmin bool `json:"viewerIsAdmin"`
	// The URL of the enterprise website.
	WebsiteUrl *URI `json:"websiteUrl,omitempty"`
}

func (*Enterprise) isNode() {}

func (*Enterprise) isIpAllowListOwner() {}

func (*Enterprise) isRuleSource() {}

func (*Enterprise) isVerifiableDomainOwner() {}

// The connection type for User.
type EnterpriseAdministratorConnection struct {
	// A list of edges.
	Edges []*EnterpriseAdministratorEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*User `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// A User who is an administrator of an enterprise.
type EnterpriseAdministratorEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *User `json:"node,omitempty"`
	// The role of the administrator.
	Role EnterpriseAdministratorRole `json:"role"`
}

// An invitation for a user to become an owner or billing manager of an enterprise.
type EnterpriseAdministratorInvitation struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The email of the person who was invited to the enterprise.
	Email *string `json:"email,omitempty"`
	// The enterprise the invitation is for.
	Enterprise *Enterprise `json:"enterprise"`
	// The Node ID of the EnterpriseAdministratorInvitation object
	Id string `json:"id"`
	// The user who was invited to the enterprise.
	Invitee *User `json:"invitee,omitempty"`
	// The user who created the invitation.
	Inviter *User `json:"inviter,omitempty"`
	// The invitee's pending role in the enterprise (owner or billing_manager).
	Role EnterpriseAdministratorRole `json:"role"`
}

func (*EnterpriseAdministratorInvitation) isNode() {}

// The connection type for EnterpriseAdministratorInvitation.
type EnterpriseAdministratorInvitationConnection struct {
	// A list of edges.
	Edges []*EnterpriseAdministratorInvitationEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*EnterpriseAdministratorInvitation `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type EnterpriseAdministratorInvitationEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *EnterpriseAdministratorInvitation `json:"node,omitempty"`
}

// Ordering options for enterprise administrator invitation connections
type EnterpriseAdministratorInvitationOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order enterprise administrator invitations by.
	Field EnterpriseAdministratorInvitationOrderField `json:"field"`
}

// Properties by which enterprise administrator invitation connections can be ordered.
type EnterpriseAdministratorInvitationOrderField string

const (
	// Order enterprise administrator member invitations by creation time
	EnterpriseAdministratorInvitationOrderFieldCreatedAt EnterpriseAdministratorInvitationOrderField = "CREATED_AT"
)

// The possible administrator roles in an enterprise account.
type EnterpriseAdministratorRole string

const (
	// Represents a billing manager of the enterprise account.
	EnterpriseAdministratorRoleBillingManager EnterpriseAdministratorRole = "BILLING_MANAGER"
	// Represents an owner of the enterprise account.
	EnterpriseAdministratorRoleOwner EnterpriseAdministratorRole = "OWNER"
	// Unaffiliated member of the enterprise account without an admin role.
	EnterpriseAdministratorRoleUnaffiliated EnterpriseAdministratorRole = "UNAFFILIATED"
)

// The possible values for the enterprise allow private repository forking policy value.
type EnterpriseAllowPrivateRepositoryForkingPolicyValue string

const (
	// Members can fork a repository to an organization within this enterprise.
	EnterpriseAllowPrivateRepositoryForkingPolicyValueEnterpriseOrganizations EnterpriseAllowPrivateRepositoryForkingPolicyValue = "ENTERPRISE_ORGANIZATIONS"
	// Members can fork a repository to their enterprise-managed user account or an organization inside this enterprise.
	EnterpriseAllowPrivateRepositoryForkingPolicyValueEnterpriseOrganizationsUserAccounts EnterpriseAllowPrivateRepositoryForkingPolicyValue = "ENTERPRISE_ORGANIZATIONS_USER_ACCOUNTS"
	// Members can fork a repository to their user account or an organization, either inside or outside of this enterprise.
	EnterpriseAllowPrivateRepositoryForkingPolicyValueEverywhere EnterpriseAllowPrivateRepositoryForkingPolicyValue = "EVERYWHERE"
	// Members can fork a repository only within the same organization (intra-org).
	EnterpriseAllowPrivateRepositoryForkingPolicyValueSameOrganization EnterpriseAllowPrivateRepositoryForkingPolicyValue = "SAME_ORGANIZATION"
	// Members can fork a repository to their user account or within the same organization.
	EnterpriseAllowPrivateRepositoryForkingPolicyValueSameOrganizationUserAccounts EnterpriseAllowPrivateRepositoryForkingPolicyValue = "SAME_ORGANIZATION_USER_ACCOUNTS"
	// Members can fork a repository to their user account.
	EnterpriseAllowPrivateRepositoryForkingPolicyValueUserAccounts EnterpriseAllowPrivateRepositoryForkingPolicyValue = "USER_ACCOUNTS"
)

// Metadata for an audit entry containing enterprise account information.
type EnterpriseAuditEntryData struct {
	// The HTTP path for this enterprise.
	EnterpriseResourcePath *URI `json:"enterpriseResourcePath,omitempty"`
	// The slug of the enterprise.
	EnterpriseSlug *string `json:"enterpriseSlug,omitempty"`
	// The HTTP URL for this enterprise.
	EnterpriseUrl *URI `json:"enterpriseUrl,omitempty"`

	// Underlying value of the GraphQL interface
	Value EnterpriseAuditEntryDataValue `json:"-"`
}

func (base *EnterpriseAuditEntryData) UnmarshalJSON(b []byte) error {
	type Raw EnterpriseAuditEntryData
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "MembersCanDeleteReposClearAuditEntry":
		base.Value = new(MembersCanDeleteReposClearAuditEntry)
	case "MembersCanDeleteReposDisableAuditEntry":
		base.Value = new(MembersCanDeleteReposDisableAuditEntry)
	case "MembersCanDeleteReposEnableAuditEntry":
		base.Value = new(MembersCanDeleteReposEnableAuditEntry)
	case "OrgInviteToBusinessAuditEntry":
		base.Value = new(OrgInviteToBusinessAuditEntry)
	case "PrivateRepositoryForkingDisableAuditEntry":
		base.Value = new(PrivateRepositoryForkingDisableAuditEntry)
	case "PrivateRepositoryForkingEnableAuditEntry":
		base.Value = new(PrivateRepositoryForkingEnableAuditEntry)
	case "RepositoryVisibilityChangeDisableAuditEntry":
		base.Value = new(RepositoryVisibilityChangeDisableAuditEntry)
	case "RepositoryVisibilityChangeEnableAuditEntry":
		base.Value = new(RepositoryVisibilityChangeEnableAuditEntry)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface EnterpriseAuditEntryData: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// EnterpriseAuditEntryDataValue is one of: MembersCanDeleteReposClearAuditEntry | MembersCanDeleteReposDisableAuditEntry | MembersCanDeleteReposEnableAuditEntry | OrgInviteToBusinessAuditEntry | PrivateRepositoryForkingDisableAuditEntry | PrivateRepositoryForkingEnableAuditEntry | RepositoryVisibilityChangeDisableAuditEntry | RepositoryVisibilityChangeEnableAuditEntry
type EnterpriseAuditEntryDataValue interface {
	isEnterpriseAuditEntryData()
}

// Enterprise billing information visible to enterprise billing managers and owners.
type EnterpriseBillingInfo struct {
	// The number of licenseable users/emails across the enterprise.
	AllLicensableUsersCount int32 `json:"allLicensableUsersCount"`
	// The number of data packs used by all organizations owned by the enterprise.
	AssetPacks int32 `json:"assetPacks"`
	// The bandwidth quota in GB for all organizations owned by the enterprise.
	BandwidthQuota float64 `json:"bandwidthQuota"`
	// The bandwidth usage in GB for all organizations owned by the enterprise.
	BandwidthUsage float64 `json:"bandwidthUsage"`
	// The bandwidth usage as a percentage of the bandwidth quota.
	BandwidthUsagePercentage int32 `json:"bandwidthUsagePercentage"`
	// The storage quota in GB for all organizations owned by the enterprise.
	StorageQuota float64 `json:"storageQuota"`
	// The storage usage in GB for all organizations owned by the enterprise.
	StorageUsage float64 `json:"storageUsage"`
	// The storage usage as a percentage of the storage quota.
	StorageUsagePercentage int32 `json:"storageUsagePercentage"`
	// The number of available licenses across all owned organizations based on the unique number of billable users.
	TotalAvailableLicenses int32 `json:"totalAvailableLicenses"`
	// The total number of licenses allocated.
	TotalLicenses int32 `json:"totalLicenses"`
}

// The connection type for Enterprise.
type EnterpriseConnection struct {
	// A list of edges.
	Edges []*EnterpriseEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*Enterprise `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// The possible values for the enterprise base repository permission setting.
type EnterpriseDefaultRepositoryPermissionSettingValue string

const (
	// Organization members will be able to clone, pull, push, and add new collaborators to all organization repositories.
	EnterpriseDefaultRepositoryPermissionSettingValueAdmin EnterpriseDefaultRepositoryPermissionSettingValue = "ADMIN"
	// Organization members will only be able to clone and pull public repositories.
	EnterpriseDefaultRepositoryPermissionSettingValueNone EnterpriseDefaultRepositoryPermissionSettingValue = "NONE"
	// Organizations in the enterprise choose base repository permissions for their members.
	EnterpriseDefaultRepositoryPermissionSettingValueNoPolicy EnterpriseDefaultRepositoryPermissionSettingValue = "NO_POLICY"
	// Organization members will be able to clone and pull all organization repositories.
	EnterpriseDefaultRepositoryPermissionSettingValueRead EnterpriseDefaultRepositoryPermissionSettingValue = "READ"
	// Organization members will be able to clone, pull, and push all organization repositories.
	EnterpriseDefaultRepositoryPermissionSettingValueWrite EnterpriseDefaultRepositoryPermissionSettingValue = "WRITE"
)

// The possible values for an enabled/no policy enterprise setting.
type EnterpriseDisallowedMethodsSettingValue string

const (
	// The setting prevents insecure 2FA methods from being used by members of the enterprise.
	EnterpriseDisallowedMethodsSettingValueInsecure EnterpriseDisallowedMethodsSettingValue = "INSECURE"
	// There is no policy set for preventing insecure 2FA methods from being used by members of the enterprise.
	EnterpriseDisallowedMethodsSettingValueNoPolicy EnterpriseDisallowedMethodsSettingValue = "NO_POLICY"
)

// An edge in a connection.
type EnterpriseEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *Enterprise `json:"node,omitempty"`
}

// The possible values for an enabled/disabled enterprise setting.
type EnterpriseEnabledDisabledSettingValue string

const (
	// The setting is disabled for organizations in the enterprise.
	EnterpriseEnabledDisabledSettingValueDisabled EnterpriseEnabledDisabledSettingValue = "DISABLED"
	// The setting is enabled for organizations in the enterprise.
	EnterpriseEnabledDisabledSettingValueEnabled EnterpriseEnabledDisabledSettingValue = "ENABLED"
	// There is no policy set for organizations in the enterprise.
	EnterpriseEnabledDisabledSettingValueNoPolicy EnterpriseEnabledDisabledSettingValue = "NO_POLICY"
)

// The possible values for an enabled/no policy enterprise setting.
type EnterpriseEnabledSettingValue string

const (
	// The setting is enabled for organizations in the enterprise.
	EnterpriseEnabledSettingValueEnabled EnterpriseEnabledSettingValue = "ENABLED"
	// There is no policy set for organizations in the enterprise.
	EnterpriseEnabledSettingValueNoPolicy EnterpriseEnabledSettingValue = "NO_POLICY"
)

// The connection type for OrganizationInvitation.
type EnterpriseFailedInvitationConnection struct {
	// A list of edges.
	Edges []*EnterpriseFailedInvitationEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*OrganizationInvitation `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
	// Identifies the total count of unique users in the connection.
	TotalUniqueUserCount int32 `json:"totalUniqueUserCount"`
}

// A failed invitation to be a member in an enterprise organization.
type EnterpriseFailedInvitationEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *OrganizationInvitation `json:"node,omitempty"`
}

// An identity provider configured to provision identities for an enterprise.
// Visible to enterprise owners or enterprise owners' personal access tokens
// (classic) with read:enterprise or admin:enterprise scope.
type EnterpriseIdentityProvider struct {
	// The digest algorithm used to sign SAML requests for the identity provider.
	DigestMethod *SamlDigestAlgorithm `json:"digestMethod,omitempty"`
	// The enterprise this identity provider belongs to.
	Enterprise *Enterprise `json:"enterprise,omitempty"`
	// ExternalIdentities provisioned by this identity provider.
	ExternalIdentities *ExternalIdentityConnection `json:"externalIdentities"`
	// The Node ID of the EnterpriseIdentityProvider object
	Id string `json:"id"`
	// The x509 certificate used by the identity provider to sign assertions and responses.
	IdpCertificate *X509Certificate `json:"idpCertificate,omitempty"`
	// The Issuer Entity ID for the SAML identity provider.
	Issuer *string `json:"issuer,omitempty"`
	// Recovery codes that can be used by admins to access the enterprise if the identity provider is unavailable.
	RecoveryCodes []string `json:"recoveryCodes,omitempty"`
	// The signature algorithm used to sign SAML requests for the identity provider.
	SignatureMethod *SamlSignatureAlgorithm `json:"signatureMethod,omitempty"`
	// The URL endpoint for the identity provider's SAML SSO.
	SsoUrl *URI `json:"ssoUrl,omitempty"`
}

func (*EnterpriseIdentityProvider) isNode() {}

// An object that is a member of an enterprise.
type EnterpriseMember struct {
	// Underlying value of the GraphQL union
	Value EnterpriseMemberValue `json:"-"`
}

func (base *EnterpriseMember) UnmarshalJSON(b []byte) error {
	type Raw EnterpriseMember
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "EnterpriseUserAccount":
		base.Value = new(EnterpriseUserAccount)
	case "User":
		base.Value = new(User)
	case "":
		return fmt.Errorf("gqlclient: union EnterpriseMember: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union EnterpriseMember: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// EnterpriseMemberValue is one of: EnterpriseUserAccount | User
type EnterpriseMemberValue interface {
	isEnterpriseMember()
}

// The connection type for EnterpriseMember.
type EnterpriseMemberConnection struct {
	// A list of edges.
	Edges []*EnterpriseMemberEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*EnterpriseMember `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// A User who is a member of an enterprise through one or more organizations.
type EnterpriseMemberEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *EnterpriseMember `json:"node,omitempty"`
}

// An invitation for a user to become an unaffiliated member of an enterprise.
type EnterpriseMemberInvitation struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The email of the person who was invited to the enterprise.
	Email *string `json:"email,omitempty"`
	// The enterprise the invitation is for.
	Enterprise *Enterprise `json:"enterprise"`
	// The Node ID of the EnterpriseMemberInvitation object
	Id string `json:"id"`
	// The user who was invited to the enterprise.
	Invitee *User `json:"invitee,omitempty"`
	// The user who created the invitation.
	Inviter *User `json:"inviter,omitempty"`
}

func (*EnterpriseMemberInvitation) isNode() {}

// The connection type for EnterpriseMemberInvitation.
type EnterpriseMemberInvitationConnection struct {
	// A list of edges.
	Edges []*EnterpriseMemberInvitationEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*EnterpriseMemberInvitation `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type EnterpriseMemberInvitationEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *EnterpriseMemberInvitation `json:"node,omitempty"`
}

// Ordering options for enterprise administrator invitation connections
type EnterpriseMemberInvitationOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order enterprise member invitations by.
	Field EnterpriseMemberInvitationOrderField `json:"field"`
}

// Properties by which enterprise member invitation connections can be ordered.
type EnterpriseMemberInvitationOrderField string

const (
	// Order enterprise member invitations by creation time
	EnterpriseMemberInvitationOrderFieldCreatedAt EnterpriseMemberInvitationOrderField = "CREATED_AT"
)

// Ordering options for enterprise member connections.
type EnterpriseMemberOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order enterprise members by.
	Field EnterpriseMemberOrderField `json:"field"`
}

// Properties by which enterprise member connections can be ordered.
type EnterpriseMemberOrderField string

const (
	// Order enterprise members by creation time
	EnterpriseMemberOrderFieldCreatedAt EnterpriseMemberOrderField = "CREATED_AT"
	// Order enterprise members by login
	EnterpriseMemberOrderFieldLogin EnterpriseMemberOrderField = "LOGIN"
)

// The possible values for the enterprise members can create repositories setting.
type EnterpriseMembersCanCreateRepositoriesSettingValue string

const (
	// Members will be able to create public and private repositories.
	EnterpriseMembersCanCreateRepositoriesSettingValueAll EnterpriseMembersCanCreateRepositoriesSettingValue = "ALL"
	// Members will not be able to create public or private repositories.
	EnterpriseMembersCanCreateRepositoriesSettingValueDisabled EnterpriseMembersCanCreateRepositoriesSettingValue = "DISABLED"
	// Organization owners choose whether to allow members to create repositories.
	EnterpriseMembersCanCreateRepositoriesSettingValueNoPolicy EnterpriseMembersCanCreateRepositoriesSettingValue = "NO_POLICY"
	// Members will be able to create only private repositories.
	EnterpriseMembersCanCreateRepositoriesSettingValuePrivate EnterpriseMembersCanCreateRepositoriesSettingValue = "PRIVATE"
	// Members will be able to create only public repositories.
	EnterpriseMembersCanCreateRepositoriesSettingValuePublic EnterpriseMembersCanCreateRepositoriesSettingValue = "PUBLIC"
)

// The possible values for the members can make purchases setting.
type EnterpriseMembersCanMakePurchasesSettingValue string

const (
	// The setting is disabled for organizations in the enterprise.
	EnterpriseMembersCanMakePurchasesSettingValueDisabled EnterpriseMembersCanMakePurchasesSettingValue = "DISABLED"
	// The setting is enabled for organizations in the enterprise.
	EnterpriseMembersCanMakePurchasesSettingValueEnabled EnterpriseMembersCanMakePurchasesSettingValue = "ENABLED"
)

// The possible values we have for filtering Platform::Objects::User#enterprises.
type EnterpriseMembershipType string

const (
	// Returns all enterprises in which the user is an admin.
	EnterpriseMembershipTypeAdmin EnterpriseMembershipType = "ADMIN"
	// Returns all enterprises in which the user is a member, admin, or billing manager.
	EnterpriseMembershipTypeAll EnterpriseMembershipType = "ALL"
	// Returns all enterprises in which the user is a billing manager.
	EnterpriseMembershipTypeBillingManager EnterpriseMembershipType = "BILLING_MANAGER"
	// Returns all enterprises in which the user is a member of an org that is owned by the enterprise.
	EnterpriseMembershipTypeOrgMembership EnterpriseMembershipType = "ORG_MEMBERSHIP"
)

// Ordering options for enterprises.
type EnterpriseOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order enterprises by.
	Field EnterpriseOrderField `json:"field"`
}

// Properties by which enterprise connections can be ordered.
type EnterpriseOrderField string

const (
	// Order enterprises by name
	EnterpriseOrderFieldName EnterpriseOrderField = "NAME"
)

// The connection type for Organization.
type EnterpriseOrganizationMembershipConnection struct {
	// A list of edges.
	Edges []*EnterpriseOrganizationMembershipEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*Organization `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An enterprise organization that a user is a member of.
type EnterpriseOrganizationMembershipEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *Organization `json:"node,omitempty"`
	// The role of the user in the enterprise membership.
	Role EnterpriseUserAccountMembershipRole `json:"role"`
}

// The connection type for User.
type EnterpriseOutsideCollaboratorConnection struct {
	// A list of edges.
	Edges []*EnterpriseOutsideCollaboratorEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*User `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// A User who is an outside collaborator of an enterprise through one or more organizations.
type EnterpriseOutsideCollaboratorEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *User `json:"node,omitempty"`
	// The enterprise organization repositories this user is a member of.
	Repositories *EnterpriseRepositoryInfoConnection `json:"repositories"`
}

// Enterprise information visible to enterprise owners or enterprise owners'
// personal access tokens (classic) with read:enterprise or admin:enterprise scope.
type EnterpriseOwnerInfo struct {
	// A list of all of the administrators for this enterprise.
	Admins *EnterpriseAdministratorConnection `json:"admins"`
	// A list of users in the enterprise who currently have two-factor authentication disabled.
	AffiliatedUsersWithTwoFactorDisabled *UserConnection `json:"affiliatedUsersWithTwoFactorDisabled"`
	// Whether or not affiliated users with two-factor authentication disabled exist in the enterprise.
	AffiliatedUsersWithTwoFactorDisabledExist bool `json:"affiliatedUsersWithTwoFactorDisabledExist"`
	// The setting value for whether private repository forking is enabled for repositories in organizations in this enterprise.
	AllowPrivateRepositoryForkingSetting EnterpriseEnabledDisabledSettingValue `json:"allowPrivateRepositoryForkingSetting"`
	// A list of enterprise organizations configured with the provided private repository forking setting value.
	AllowPrivateRepositoryForkingSettingOrganizations *OrganizationConnection `json:"allowPrivateRepositoryForkingSettingOrganizations"`
	// The value for the allow private repository forking policy on the enterprise.
	AllowPrivateRepositoryForkingSettingPolicyValue *EnterpriseAllowPrivateRepositoryForkingPolicyValue `json:"allowPrivateRepositoryForkingSettingPolicyValue,omitempty"`
	// The setting value for base repository permissions for organizations in this enterprise.
	DefaultRepositoryPermissionSetting EnterpriseDefaultRepositoryPermissionSettingValue `json:"defaultRepositoryPermissionSetting"`
	// A list of enterprise organizations configured with the provided base repository permission.
	DefaultRepositoryPermissionSettingOrganizations *OrganizationConnection `json:"defaultRepositoryPermissionSettingOrganizations"`
	// A list of domains owned by the enterprise. Visible to enterprise owners or
	// enterprise owners' personal access tokens (classic) with admin:enterprise scope.
	Domains *VerifiableDomainConnection `json:"domains"`
	// Enterprise Server installations owned by the enterprise.
	EnterpriseServerInstallations *EnterpriseServerInstallationConnection `json:"enterpriseServerInstallations"`
	// A list of failed invitations in the enterprise.
	FailedInvitations *EnterpriseFailedInvitationConnection `json:"failedInvitations"`
	// The setting value for whether the enterprise has an IP allow list enabled.
	IpAllowListEnabledSetting IpAllowListEnabledSettingValue `json:"ipAllowListEnabledSetting"`
	// The IP addresses that are allowed to access resources owned by the enterprise.
	// Visible to enterprise owners or enterprise owners' personal access tokens
	// (classic) with admin:enterprise scope.
	IpAllowListEntries *IpAllowListEntryConnection `json:"ipAllowListEntries"`
	// The setting value for whether the enterprise has IP allow list configuration for installed GitHub Apps enabled.
	IpAllowListForInstalledAppsEnabledSetting IpAllowListForInstalledAppsEnabledSettingValue `json:"ipAllowListForInstalledAppsEnabledSetting"`
	// Whether or not the base repository permission is currently being updated.
	IsUpdatingDefaultRepositoryPermission bool `json:"isUpdatingDefaultRepositoryPermission"`
	// Whether the two-factor authentication requirement is currently being enforced.
	IsUpdatingTwoFactorRequirement bool `json:"isUpdatingTwoFactorRequirement"`
	// The setting value for whether organization members with admin permissions on a
	// repository can change repository visibility.
	MembersCanChangeRepositoryVisibilitySetting EnterpriseEnabledDisabledSettingValue `json:"membersCanChangeRepositoryVisibilitySetting"`
	// A list of enterprise organizations configured with the provided can change repository visibility setting value.
	MembersCanChangeRepositoryVisibilitySettingOrganizations *OrganizationConnection `json:"membersCanChangeRepositoryVisibilitySettingOrganizations"`
	// The setting value for whether members of organizations in the enterprise can create internal repositories.
	MembersCanCreateInternalRepositoriesSetting *bool `json:"membersCanCreateInternalRepositoriesSetting,omitempty"`
	// The setting value for whether members of organizations in the enterprise can create private repositories.
	MembersCanCreatePrivateRepositoriesSetting *bool `json:"membersCanCreatePrivateRepositoriesSetting,omitempty"`
	// The setting value for whether members of organizations in the enterprise can create public repositories.
	MembersCanCreatePublicRepositoriesSetting *bool `json:"membersCanCreatePublicRepositoriesSetting,omitempty"`
	// The setting value for whether members of organizations in the enterprise can create repositories.
	MembersCanCreateRepositoriesSetting *EnterpriseMembersCanCreateRepositoriesSettingValue `json:"membersCanCreateRepositoriesSetting,omitempty"`
	// A list of enterprise organizations configured with the provided repository creation setting value.
	MembersCanCreateRepositoriesSettingOrganizations *OrganizationConnection `json:"membersCanCreateRepositoriesSettingOrganizations"`
	// The setting value for whether members with admin permissions for repositories can delete issues.
	MembersCanDeleteIssuesSetting EnterpriseEnabledDisabledSettingValue `json:"membersCanDeleteIssuesSetting"`
	// A list of enterprise organizations configured with the provided members can delete issues setting value.
	MembersCanDeleteIssuesSettingOrganizations *OrganizationConnection `json:"membersCanDeleteIssuesSettingOrganizations"`
	// The setting value for whether members with admin permissions for repositories can delete or transfer repositories.
	MembersCanDeleteRepositoriesSetting EnterpriseEnabledDisabledSettingValue `json:"membersCanDeleteRepositoriesSetting"`
	// A list of enterprise organizations configured with the provided members can delete repositories setting value.
	MembersCanDeleteRepositoriesSettingOrganizations *OrganizationConnection `json:"membersCanDeleteRepositoriesSettingOrganizations"`
	// The setting value for whether members of organizations in the enterprise can invite outside collaborators.
	MembersCanInviteCollaboratorsSetting EnterpriseEnabledDisabledSettingValue `json:"membersCanInviteCollaboratorsSetting"`
	// A list of enterprise organizations configured with the provided members can invite collaborators setting value.
	MembersCanInviteCollaboratorsSettingOrganizations *OrganizationConnection `json:"membersCanInviteCollaboratorsSettingOrganizations"`
	// Indicates whether members of this enterprise's organizations can purchase additional services for those organizations.
	MembersCanMakePurchasesSetting EnterpriseMembersCanMakePurchasesSettingValue `json:"membersCanMakePurchasesSetting"`
	// The setting value for whether members with admin permissions for repositories can update protected branches.
	MembersCanUpdateProtectedBranchesSetting EnterpriseEnabledDisabledSettingValue `json:"membersCanUpdateProtectedBranchesSetting"`
	// A list of enterprise organizations configured with the provided members can update protected branches setting value.
	MembersCanUpdateProtectedBranchesSettingOrganizations *OrganizationConnection `json:"membersCanUpdateProtectedBranchesSettingOrganizations"`
	// The setting value for whether members can view dependency insights.
	MembersCanViewDependencyInsightsSetting EnterpriseEnabledDisabledSettingValue `json:"membersCanViewDependencyInsightsSetting"`
	// A list of enterprise organizations configured with the provided members can view dependency insights setting value.
	MembersCanViewDependencyInsightsSettingOrganizations *OrganizationConnection `json:"membersCanViewDependencyInsightsSettingOrganizations"`
	// Indicates if email notification delivery for this enterprise is restricted to verified or approved domains.
	NotificationDeliveryRestrictionEnabledSetting NotificationRestrictionSettingValue `json:"notificationDeliveryRestrictionEnabledSetting"`
	// The OIDC Identity Provider for the enterprise.
	OidcProvider *OIDCProvider `json:"oidcProvider,omitempty"`
	// The setting value for whether organization projects are enabled for organizations in this enterprise.
	OrganizationProjectsSetting EnterpriseEnabledDisabledSettingValue `json:"organizationProjectsSetting"`
	// A list of enterprise organizations configured with the provided organization projects setting value.
	OrganizationProjectsSettingOrganizations *OrganizationConnection `json:"organizationProjectsSettingOrganizations"`
	// A list of outside collaborators across the repositories in the enterprise.
	OutsideCollaborators *EnterpriseOutsideCollaboratorConnection `json:"outsideCollaborators"`
	// A list of pending administrator invitations for the enterprise.
	PendingAdminInvitations *EnterpriseAdministratorInvitationConnection `json:"pendingAdminInvitations"`
	// A list of pending collaborator invitations across the repositories in the enterprise.
	PendingCollaboratorInvitations *RepositoryInvitationConnection `json:"pendingCollaboratorInvitations"`
	// A list of pending member invitations for organizations in the enterprise.
	PendingMemberInvitations *EnterprisePendingMemberInvitationConnection `json:"pendingMemberInvitations"`
	// A list of pending unaffiliated member invitations for the enterprise.
	PendingUnaffiliatedMemberInvitations *EnterpriseMemberInvitationConnection `json:"pendingUnaffiliatedMemberInvitations"`
	// The setting value for whether deploy keys are enabled for repositories in organizations in this enterprise.
	RepositoryDeployKeySetting EnterpriseEnabledDisabledSettingValue `json:"repositoryDeployKeySetting"`
	// A list of enterprise organizations configured with the provided deploy keys setting value.
	RepositoryDeployKeySettingOrganizations *OrganizationConnection `json:"repositoryDeployKeySettingOrganizations"`
	// The setting value for whether repository projects are enabled in this enterprise.
	RepositoryProjectsSetting EnterpriseEnabledDisabledSettingValue `json:"repositoryProjectsSetting"`
	// A list of enterprise organizations configured with the provided repository projects setting value.
	RepositoryProjectsSettingOrganizations *OrganizationConnection `json:"repositoryProjectsSettingOrganizations"`
	// The SAML Identity Provider for the enterprise.
	SamlIdentityProvider *EnterpriseIdentityProvider `json:"samlIdentityProvider,omitempty"`
	// A list of enterprise organizations configured with the SAML single sign-on setting value.
	SamlIdentityProviderSettingOrganizations *OrganizationConnection `json:"samlIdentityProviderSettingOrganizations"`
	// A list of members with a support entitlement.
	SupportEntitlements *EnterpriseMemberConnection `json:"supportEntitlements"`
	// The setting value for whether team discussions are enabled for organizations in this enterprise.
	TeamDiscussionsSetting EnterpriseEnabledDisabledSettingValue `json:"teamDiscussionsSetting"`
	// A list of enterprise organizations configured with the provided team discussions setting value.
	TeamDiscussionsSettingOrganizations *OrganizationConnection `json:"teamDiscussionsSettingOrganizations"`
	// The setting value for what methods of two-factor authentication the enterprise prevents its users from having.
	TwoFactorDisallowedMethodsSetting EnterpriseDisallowedMethodsSettingValue `json:"twoFactorDisallowedMethodsSetting"`
	// The setting value for whether the enterprise requires two-factor authentication for its organizations and users.
	TwoFactorRequiredSetting EnterpriseEnabledSettingValue `json:"twoFactorRequiredSetting"`
	// A list of enterprise organizations configured with the two-factor authentication setting value.
	TwoFactorRequiredSettingOrganizations *OrganizationConnection `json:"twoFactorRequiredSettingOrganizations"`
}

// The connection type for OrganizationInvitation.
type EnterprisePendingMemberInvitationConnection struct {
	// A list of edges.
	Edges []*EnterprisePendingMemberInvitationEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*OrganizationInvitation `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
	// Identifies the total count of unique users in the connection.
	TotalUniqueUserCount int32 `json:"totalUniqueUserCount"`
}

// An invitation to be a member in an enterprise organization.
type EnterprisePendingMemberInvitationEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *OrganizationInvitation `json:"node,omitempty"`
}

// A subset of repository information queryable from an enterprise.
type EnterpriseRepositoryInfo struct {
	// The Node ID of the EnterpriseRepositoryInfo object
	Id string `json:"id"`
	// Identifies if the repository is private or internal.
	IsPrivate bool `json:"isPrivate"`
	// The repository's name.
	Name string `json:"name"`
	// The repository's name with owner.
	NameWithOwner string `json:"nameWithOwner"`
}

func (*EnterpriseRepositoryInfo) isNode() {}

// The connection type for EnterpriseRepositoryInfo.
type EnterpriseRepositoryInfoConnection struct {
	// A list of edges.
	Edges []*EnterpriseRepositoryInfoEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*EnterpriseRepositoryInfo `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type EnterpriseRepositoryInfoEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *EnterpriseRepositoryInfo `json:"node,omitempty"`
}

// An Enterprise Server installation.
type EnterpriseServerInstallation struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The customer name to which the Enterprise Server installation belongs.
	CustomerName string `json:"customerName"`
	// The host name of the Enterprise Server installation.
	HostName string `json:"hostName"`
	// The Node ID of the EnterpriseServerInstallation object
	Id string `json:"id"`
	// Whether or not the installation is connected to an Enterprise Server installation via GitHub Connect.
	IsConnected bool `json:"isConnected"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// User accounts on this Enterprise Server installation.
	UserAccounts *EnterpriseServerUserAccountConnection `json:"userAccounts"`
	// User accounts uploads for the Enterprise Server installation.
	UserAccountsUploads *EnterpriseServerUserAccountsUploadConnection `json:"userAccountsUploads"`
}

func (*EnterpriseServerInstallation) isNode() {}

// The connection type for EnterpriseServerInstallation.
type EnterpriseServerInstallationConnection struct {
	// A list of edges.
	Edges []*EnterpriseServerInstallationEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*EnterpriseServerInstallation `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type EnterpriseServerInstallationEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *EnterpriseServerInstallation `json:"node,omitempty"`
}

// The connection type for EnterpriseServerInstallation.
type EnterpriseServerInstallationMembershipConnection struct {
	// A list of edges.
	Edges []*EnterpriseServerInstallationMembershipEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*EnterpriseServerInstallation `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An Enterprise Server installation that a user is a member of.
type EnterpriseServerInstallationMembershipEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *EnterpriseServerInstallation `json:"node,omitempty"`
	// The role of the user in the enterprise membership.
	Role EnterpriseUserAccountMembershipRole `json:"role"`
}

// Ordering options for Enterprise Server installation connections.
type EnterpriseServerInstallationOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order Enterprise Server installations by.
	Field EnterpriseServerInstallationOrderField `json:"field"`
}

// Properties by which Enterprise Server installation connections can be ordered.
type EnterpriseServerInstallationOrderField string

const (
	// Order Enterprise Server installations by creation time
	EnterpriseServerInstallationOrderFieldCreatedAt EnterpriseServerInstallationOrderField = "CREATED_AT"
	// Order Enterprise Server installations by customer name
	EnterpriseServerInstallationOrderFieldCustomerName EnterpriseServerInstallationOrderField = "CUSTOMER_NAME"
	// Order Enterprise Server installations by host name
	EnterpriseServerInstallationOrderFieldHostName EnterpriseServerInstallationOrderField = "HOST_NAME"
)

// A user account on an Enterprise Server installation.
type EnterpriseServerUserAccount struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// User emails belonging to this user account.
	Emails *EnterpriseServerUserAccountEmailConnection `json:"emails"`
	// The Enterprise Server installation on which this user account exists.
	EnterpriseServerInstallation *EnterpriseServerInstallation `json:"enterpriseServerInstallation"`
	// The Node ID of the EnterpriseServerUserAccount object
	Id string `json:"id"`
	// Whether the user account is a site administrator on the Enterprise Server installation.
	IsSiteAdmin bool `json:"isSiteAdmin"`
	// The login of the user account on the Enterprise Server installation.
	Login string `json:"login"`
	// The profile name of the user account on the Enterprise Server installation.
	ProfileName *string `json:"profileName,omitempty"`
	// The date and time when the user account was created on the Enterprise Server installation.
	RemoteCreatedAt DateTime `json:"remoteCreatedAt"`
	// The ID of the user account on the Enterprise Server installation.
	RemoteUserId int32 `json:"remoteUserId"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
}

func (*EnterpriseServerUserAccount) isNode() {}

// The connection type for EnterpriseServerUserAccount.
type EnterpriseServerUserAccountConnection struct {
	// A list of edges.
	Edges []*EnterpriseServerUserAccountEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*EnterpriseServerUserAccount `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type EnterpriseServerUserAccountEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *EnterpriseServerUserAccount `json:"node,omitempty"`
}

// An email belonging to a user account on an Enterprise Server installation.
type EnterpriseServerUserAccountEmail struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The email address.
	Email string `json:"email"`
	// The Node ID of the EnterpriseServerUserAccountEmail object
	Id string `json:"id"`
	// Indicates whether this is the primary email of the associated user account.
	IsPrimary bool `json:"isPrimary"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The user account to which the email belongs.
	UserAccount *EnterpriseServerUserAccount `json:"userAccount"`
}

func (*EnterpriseServerUserAccountEmail) isNode() {}

// The connection type for EnterpriseServerUserAccountEmail.
type EnterpriseServerUserAccountEmailConnection struct {
	// A list of edges.
	Edges []*EnterpriseServerUserAccountEmailEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*EnterpriseServerUserAccountEmail `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type EnterpriseServerUserAccountEmailEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *EnterpriseServerUserAccountEmail `json:"node,omitempty"`
}

// Ordering options for Enterprise Server user account email connections.
type EnterpriseServerUserAccountEmailOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order emails by.
	Field EnterpriseServerUserAccountEmailOrderField `json:"field"`
}

// Properties by which Enterprise Server user account email connections can be ordered.
type EnterpriseServerUserAccountEmailOrderField string

const (
	// Order emails by email
	EnterpriseServerUserAccountEmailOrderFieldEmail EnterpriseServerUserAccountEmailOrderField = "EMAIL"
)

// Ordering options for Enterprise Server user account connections.
type EnterpriseServerUserAccountOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order user accounts by.
	Field EnterpriseServerUserAccountOrderField `json:"field"`
}

// Properties by which Enterprise Server user account connections can be ordered.
type EnterpriseServerUserAccountOrderField string

const (
	// Order user accounts by login
	EnterpriseServerUserAccountOrderFieldLogin EnterpriseServerUserAccountOrderField = "LOGIN"
	// Order user accounts by creation time on the Enterprise Server installation
	EnterpriseServerUserAccountOrderFieldRemoteCreatedAt EnterpriseServerUserAccountOrderField = "REMOTE_CREATED_AT"
)

// A user accounts upload from an Enterprise Server installation.
type EnterpriseServerUserAccountsUpload struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The enterprise to which this upload belongs.
	Enterprise *Enterprise `json:"enterprise"`
	// The Enterprise Server installation for which this upload was generated.
	EnterpriseServerInstallation *EnterpriseServerInstallation `json:"enterpriseServerInstallation"`
	// The Node ID of the EnterpriseServerUserAccountsUpload object
	Id string `json:"id"`
	// The name of the file uploaded.
	Name string `json:"name"`
	// The synchronization state of the upload
	SyncState EnterpriseServerUserAccountsUploadSyncState `json:"syncState"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
}

func (*EnterpriseServerUserAccountsUpload) isNode() {}

// The connection type for EnterpriseServerUserAccountsUpload.
type EnterpriseServerUserAccountsUploadConnection struct {
	// A list of edges.
	Edges []*EnterpriseServerUserAccountsUploadEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*EnterpriseServerUserAccountsUpload `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type EnterpriseServerUserAccountsUploadEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *EnterpriseServerUserAccountsUpload `json:"node,omitempty"`
}

// Ordering options for Enterprise Server user accounts upload connections.
type EnterpriseServerUserAccountsUploadOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order user accounts uploads by.
	Field EnterpriseServerUserAccountsUploadOrderField `json:"field"`
}

// Properties by which Enterprise Server user accounts upload connections can be ordered.
type EnterpriseServerUserAccountsUploadOrderField string

const (
	// Order user accounts uploads by creation time
	EnterpriseServerUserAccountsUploadOrderFieldCreatedAt EnterpriseServerUserAccountsUploadOrderField = "CREATED_AT"
)

// Synchronization state of the Enterprise Server user accounts upload
type EnterpriseServerUserAccountsUploadSyncState string

const (
	// The synchronization of the upload failed.
	EnterpriseServerUserAccountsUploadSyncStateFailure EnterpriseServerUserAccountsUploadSyncState = "FAILURE"
	// The synchronization of the upload is pending.
	EnterpriseServerUserAccountsUploadSyncStatePending EnterpriseServerUserAccountsUploadSyncState = "PENDING"
	// The synchronization of the upload succeeded.
	EnterpriseServerUserAccountsUploadSyncStateSuccess EnterpriseServerUserAccountsUploadSyncState = "SUCCESS"
)

// An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations.
type EnterpriseUserAccount struct {
	// A URL pointing to the enterprise user account's public avatar.
	AvatarUrl URI `json:"avatarUrl"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The enterprise in which this user account exists.
	Enterprise *Enterprise `json:"enterprise"`
	// A list of Enterprise Server installations this user is a member of.
	EnterpriseInstallations *EnterpriseServerInstallationMembershipConnection `json:"enterpriseInstallations"`
	// The Node ID of the EnterpriseUserAccount object
	Id string `json:"id"`
	// An identifier for the enterprise user account, a login or email address
	Login string `json:"login"`
	// The name of the enterprise user account
	Name *string `json:"name,omitempty"`
	// A list of enterprise organizations this user is a member of.
	Organizations *EnterpriseOrganizationMembershipConnection `json:"organizations"`
	// The HTTP path for this user.
	ResourcePath URI `json:"resourcePath"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The HTTP URL for this user.
	Url URI `json:"url"`
	// The user within the enterprise.
	User *User `json:"user,omitempty"`
}

func (*EnterpriseUserAccount) isEnterpriseMember() {}

func (*EnterpriseUserAccount) isActor() {}

func (*EnterpriseUserAccount) isNode() {}

// The possible roles for enterprise membership.
type EnterpriseUserAccountMembershipRole string

const (
	// The user is a member of an organization in the enterprise.
	EnterpriseUserAccountMembershipRoleMember EnterpriseUserAccountMembershipRole = "MEMBER"
	// The user is an owner of an organization in the enterprise.
	EnterpriseUserAccountMembershipRoleOwner EnterpriseUserAccountMembershipRole = "OWNER"
	// The user is not an owner of the enterprise, and not a member or owner of any
	// organizations in the enterprise; only for EMU-enabled enterprises.
	EnterpriseUserAccountMembershipRoleUnaffiliated EnterpriseUserAccountMembershipRole = "UNAFFILIATED"
)

// The possible GitHub Enterprise deployments where this user can exist.
type EnterpriseUserDeployment string

const (
	// The user is part of a GitHub Enterprise Cloud deployment.
	EnterpriseUserDeploymentCloud EnterpriseUserDeployment = "CLOUD"
	// The user is part of a GitHub Enterprise Server deployment.
	EnterpriseUserDeploymentServer EnterpriseUserDeployment = "SERVER"
)

// An environment.
type Environment struct {
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The Node ID of the Environment object
	Id string `json:"id"`
	// Indicates whether or not this environment is currently pinned to the repository
	IsPinned *bool `json:"isPinned,omitempty"`
	// The latest completed deployment with status success, failure, or error if it exists
	LatestCompletedDeployment *Deployment `json:"latestCompletedDeployment,omitempty"`
	// The name of the environment
	Name string `json:"name"`
	// The position of the environment if it is pinned, null if it is not pinned
	PinnedPosition *int32 `json:"pinnedPosition,omitempty"`
	// The protection rules defined for this environment
	ProtectionRules *DeploymentProtectionRuleConnection `json:"protectionRules"`
}

func (*Environment) isNode() {}

// The connection type for Environment.
type EnvironmentConnection struct {
	// A list of edges.
	Edges []*EnvironmentEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*Environment `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type EnvironmentEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *Environment `json:"node,omitempty"`
}

// Properties by which environments connections can be ordered
type EnvironmentOrderField string

const (
	// Order environments by name.
	EnvironmentOrderFieldName EnvironmentOrderField = "NAME"
)

// Properties by which environments connections can be ordered
type EnvironmentPinnedFilterField string

const (
	// All environments will be returned.
	EnvironmentPinnedFilterFieldAll EnvironmentPinnedFilterField = "ALL"
	// Environments exclude pinned will be returned
	EnvironmentPinnedFilterFieldNone EnvironmentPinnedFilterField = "NONE"
	// Only pinned environment will be returned
	EnvironmentPinnedFilterFieldOnly EnvironmentPinnedFilterField = "ONLY"
)

// Ordering options for environments
type Environments struct {
	// The direction in which to order environments by the specified field.
	Direction OrderDirection `json:"direction"`
	// The field to order environments by.
	Field EnvironmentOrderField `json:"field"`
}

// An external identity provisioned by SAML SSO or SCIM. If SAML is configured on
// the organization, the external identity is visible to (1) organization owners,
// (2) organization owners' personal access tokens (classic) with read:org or
// admin:org scope, (3) GitHub App with an installation token with read or write
// access to members. If SAML is configured on the enterprise, the external
// identity is visible to (1) enterprise owners, (2) enterprise owners' personal
// access tokens (classic) with read:enterprise or admin:enterprise scope.
type ExternalIdentity struct {
	// The GUID for this identity
	Guid string `json:"guid"`
	// The Node ID of the ExternalIdentity object
	Id string `json:"id"`
	// Organization invitation for this SCIM-provisioned external identity
	OrganizationInvitation *OrganizationInvitation `json:"organizationInvitation,omitempty"`
	// SAML Identity attributes
	SamlIdentity *ExternalIdentitySamlAttributes `json:"samlIdentity,omitempty"`
	// SCIM Identity attributes
	ScimIdentity *ExternalIdentityScimAttributes `json:"scimIdentity,omitempty"`
	// User linked to this external identity. Will be NULL if this identity has not been claimed by an organization member.
	User *User `json:"user,omitempty"`
}

func (*ExternalIdentity) isNode() {}

// An attribute for the External Identity attributes collection
type ExternalIdentityAttribute struct {
	// The attribute metadata as JSON
	Metadata *string `json:"metadata,omitempty"`
	// The attribute name
	Name string `json:"name"`
	// The attribute value
	Value string `json:"value"`
}

// The connection type for ExternalIdentity.
type ExternalIdentityConnection struct {
	// A list of edges.
	Edges []*ExternalIdentityEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*ExternalIdentity `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type ExternalIdentityEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *ExternalIdentity `json:"node,omitempty"`
}

// SAML attributes for the External Identity
type ExternalIdentitySamlAttributes struct {
	// SAML Identity attributes
	Attributes []ExternalIdentityAttribute `json:"attributes"`
	// The emails associated with the SAML identity
	Emails []UserEmailMetadata `json:"emails,omitempty"`
	// Family name of the SAML identity
	FamilyName *string `json:"familyName,omitempty"`
	// Given name of the SAML identity
	GivenName *string `json:"givenName,omitempty"`
	// The groups linked to this identity in IDP
	Groups []string `json:"groups,omitempty"`
	// The NameID of the SAML identity
	NameId *string `json:"nameId,omitempty"`
	// The userName of the SAML identity
	Username *string `json:"username,omitempty"`
}

// SCIM attributes for the External Identity
type ExternalIdentityScimAttributes struct {
	// The emails associated with the SCIM identity
	Emails []UserEmailMetadata `json:"emails,omitempty"`
	// Family name of the SCIM identity
	FamilyName *string `json:"familyName,omitempty"`
	// Given name of the SCIM identity
	GivenName *string `json:"givenName,omitempty"`
	// The groups linked to this identity in IDP
	Groups []string `json:"groups,omitempty"`
	// The userName of the SCIM identity
	Username *string `json:"username,omitempty"`
}

// A command to add a file at the given path with the given contents as part of a
// commit.  Any existing file at that that path will be replaced.
type FileAddition struct {
	// The base64 encoded contents of the file
	Contents Base64String `json:"contents"`
	// The path in the repository where the file will be located
	Path string `json:"path"`
}

// A description of a set of changes to a file tree to be made as part of
// a git commit, modeled as zero or more file `additions` and zero or more
// file `deletions`.
//
// Both fields are optional; omitting both will produce a commit with no
// file changes.
//
// `deletions` and `additions` describe changes to files identified
// by their path in the git tree using unix-style path separators, i.e.
// `/`.  The root of a git tree is an empty string, so paths are not
// slash-prefixed.
//
// `path` values must be unique across all `additions` and `deletions`
// provided.  Any duplication will result in a validation error.
//
// ### Encoding
//
// File contents must be provided in full for each `FileAddition`.
//
// The `contents` of a `FileAddition` must be encoded using RFC 4648
// compliant base64, i.e. correct padding is required and no characters
// outside the standard alphabet may be used.  Invalid base64
// encoding will be rejected with a validation error.
//
// The encoded contents may be binary.
//
// For text files, no assumptions are made about the character encoding of
// the file contents (after base64 decoding).  No charset transcoding or
// line-ending normalization will be performed; it is the client's
// responsibility to manage the character encoding of files they provide.
// However, for maximum compatibility we recommend using UTF-8 encoding
// and ensuring that all files in a repository use a consistent
// line-ending convention (`\n` or `\r\n`), and that all files end
// with a newline.
//
// ### Modeling file changes
//
// Each of the the five types of conceptual changes that can be made in a
// git commit can be described using the `FileChanges` type as follows:
//
// 1. New file addition: create file `hello world\n` at path `docs/README.txt`:
//
//        {
//          "additions" [
//            {
//              "path": "docs/README.txt",
//              "contents": base64encode("hello world\n")
//            }
//          ]
//        }
//
// 2. Existing file modification: change existing `docs/README.txt` to have new
//    content `new content here\n`:
//
//        {
//          "additions" [
//            {
//              "path": "docs/README.txt",
//              "contents": base64encode("new content here\n")
//            }
//          ]
//        }
//
// 3. Existing file deletion: remove existing file `docs/README.txt`.
//    Note that the path is required to exist -- specifying a
//    path that does not exist on the given branch will abort the
//    commit and return an error.
//
//        {
//          "deletions" [
//            {
//              "path": "docs/README.txt"
//            }
//          ]
//        }
//
//
// 4. File rename with no changes: rename `docs/README.txt` with
//    previous content `hello world\n` to the same content at
//    `newdocs/README.txt`:
//
//        {
//          "deletions" [
//            {
//              "path": "docs/README.txt",
//            }
//          ],
//          "additions" [
//            {
//              "path": "newdocs/README.txt",
//              "contents": base64encode("hello world\n")
//            }
//          ]
//        }
//
//
// 5. File rename with changes: rename `docs/README.txt` with
//    previous content `hello world\n` to a file at path
//    `newdocs/README.txt` with content `new contents\n`:
//
//        {
//          "deletions" [
//            {
//              "path": "docs/README.txt",
//            }
//          ],
//          "additions" [
//            {
//              "path": "newdocs/README.txt",
//              "contents": base64encode("new contents\n")
//            }
//          ]
//        }
type FileChanges struct {
	// File to add or change.
	Additions []FileAddition `json:"additions,omitempty"`
	// Files to delete.
	Deletions []FileDeletion `json:"deletions,omitempty"`
}

// A command to delete the file at the given path as part of a commit.
type FileDeletion struct {
	// The path to delete
	Path string `json:"path"`
}

// Prevent commits that include files with specified file extensions from being pushed to the commit graph.
type FileExtensionRestrictionParameters struct {
	// The file extensions that are restricted from being pushed to the commit graph.
	RestrictedFileExtensions []string `json:"restrictedFileExtensions"`
}

func (*FileExtensionRestrictionParameters) isRuleParameters() {}

// Prevent commits that include files with specified file extensions from being pushed to the commit graph.
type FileExtensionRestrictionParametersInput struct {
	// The file extensions that are restricted from being pushed to the commit graph.
	RestrictedFileExtensions []string `json:"restrictedFileExtensions"`
}

// Prevent commits that include changes in specified file and folder paths from
// being pushed to the commit graph. This includes absolute paths that contain file names.
type FilePathRestrictionParameters struct {
	// The file paths that are restricted from being pushed to the commit graph.
	RestrictedFilePaths []string `json:"restrictedFilePaths"`
}

func (*FilePathRestrictionParameters) isRuleParameters() {}

// Prevent commits that include changes in specified file and folder paths from
// being pushed to the commit graph. This includes absolute paths that contain file names.
type FilePathRestrictionParametersInput struct {
	// The file paths that are restricted from being pushed to the commit graph.
	RestrictedFilePaths []string `json:"restrictedFilePaths"`
}

// The possible viewed states of a file .
type FileViewedState string

const (
	// The file has new changes since last viewed.
	FileViewedStateDismissed FileViewedState = "DISMISSED"
	// The file has not been marked as viewed.
	FileViewedStateUnviewed FileViewedState = "UNVIEWED"
	// The file has been marked as viewed.
	FileViewedStateViewed FileViewedState = "VIEWED"
)

// Autogenerated input type of FollowOrganization
type FollowOrganizationInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// ID of the organization to follow.
	OrganizationId string `json:"organizationId"`
}

// Autogenerated return type of FollowOrganization.
type FollowOrganizationPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The organization that was followed.
	Organization *Organization `json:"organization,omitempty"`
}

// Autogenerated input type of FollowUser
type FollowUserInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// ID of the user to follow.
	UserId string `json:"userId"`
}

// Autogenerated return type of FollowUser.
type FollowUserPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The user that was followed.
	User *User `json:"user,omitempty"`
}

// The connection type for User.
type FollowerConnection struct {
	// A list of edges.
	Edges []*UserEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*User `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// The connection type for User.
type FollowingConnection struct {
	// A list of edges.
	Edges []*UserEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*User `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// A funding platform link for a repository.
type FundingLink struct {
	// The funding platform this link is for.
	Platform FundingPlatform `json:"platform"`
	// The configured URL for this funding link.
	Url URI `json:"url"`
}

// The possible funding platforms for repository funding links.
type FundingPlatform string

const (
	// Buy Me a Coffee funding platform.
	FundingPlatformBuyMeACoffee FundingPlatform = "BUY_ME_A_COFFEE"
	// Community Bridge funding platform.
	FundingPlatformCommunityBridge FundingPlatform = "COMMUNITY_BRIDGE"
	// Custom funding platform.
	FundingPlatformCustom FundingPlatform = "CUSTOM"
	// GitHub funding platform.
	FundingPlatformGithub FundingPlatform = "GITHUB"
	// IssueHunt funding platform.
	FundingPlatformIssuehunt FundingPlatform = "ISSUEHUNT"
	// Ko-fi funding platform.
	FundingPlatformKoFi FundingPlatform = "KO_FI"
	// LFX Crowdfunding funding platform.
	FundingPlatformLfxCrowdfunding FundingPlatform = "LFX_CROWDFUNDING"
	// Liberapay funding platform.
	FundingPlatformLiberapay FundingPlatform = "LIBERAPAY"
	// Open Collective funding platform.
	FundingPlatformOpenCollective FundingPlatform = "OPEN_COLLECTIVE"
	// Patreon funding platform.
	FundingPlatformPatreon FundingPlatform = "PATREON"
	// Polar funding platform.
	FundingPlatformPolar FundingPlatform = "POLAR"
	// thanks.dev funding platform.
	FundingPlatformThanksDev FundingPlatform = "THANKS_DEV"
	// Tidelift funding platform.
	FundingPlatformTidelift FundingPlatform = "TIDELIFT"
)

// A generic hovercard context with a message and icon
type GenericHovercardContext struct {
	// A string describing this context
	Message string `json:"message"`
	// An octicon to accompany this context
	Octicon string `json:"octicon"`
}

func (*GenericHovercardContext) isHovercardContext() {}

// A Gist.
type Gist struct {
	// A list of comments associated with the gist
	Comments *GistCommentConnection `json:"comments"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The gist description.
	Description *string `json:"description,omitempty"`
	// The files in this gist.
	Files []*GistFile `json:"files,omitempty"`
	// A list of forks associated with the gist
	Forks *GistConnection `json:"forks"`
	// The Node ID of the Gist object
	Id string `json:"id"`
	// Identifies if the gist is a fork.
	IsFork bool `json:"isFork"`
	// Whether the gist is public or not.
	IsPublic bool `json:"isPublic"`
	// The gist name.
	Name string `json:"name"`
	// The gist owner.
	Owner *RepositoryOwner `json:"owner,omitempty"`
	// Identifies when the gist was last pushed to.
	PushedAt *DateTime `json:"pushedAt,omitempty"`
	// The HTML path to this resource.
	ResourcePath URI `json:"resourcePath"`
	// Returns a count of how many stargazers there are on this object
	StargazerCount int32 `json:"stargazerCount"`
	// A list of users who have starred this starrable.
	Stargazers *StargazerConnection `json:"stargazers"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The HTTP URL for this Gist.
	Url URI `json:"url"`
	// Returns a boolean indicating whether the viewing user has starred this starrable.
	ViewerHasStarred bool `json:"viewerHasStarred"`
}

func (*Gist) isNode() {}

func (*Gist) isStarrable() {}

func (*Gist) isUniformResourceLocatable() {}

func (*Gist) isPinnableItem() {}

// Represents a comment on an Gist.
type GistComment struct {
	// The actor who authored the comment.
	Author *Actor `json:"author,omitempty"`
	// Author's association with the gist.
	AuthorAssociation CommentAuthorAssociation `json:"authorAssociation"`
	// Identifies the comment body.
	Body string `json:"body"`
	// The body rendered to HTML.
	BodyHTML HTML `json:"bodyHTML"`
	// The body rendered to text.
	BodyText string `json:"bodyText"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Check if this comment was created via an email reply.
	CreatedViaEmail bool `json:"createdViaEmail"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The actor who edited the comment.
	Editor *Actor `json:"editor,omitempty"`
	// The associated gist.
	Gist *Gist `json:"gist"`
	// The Node ID of the GistComment object
	Id string `json:"id"`
	// Check if this comment was edited and includes an edit with the creation data
	IncludesCreatedEdit bool `json:"includesCreatedEdit"`
	// Returns whether or not a comment has been minimized.
	IsMinimized bool `json:"isMinimized"`
	// The moment the editor made the last edit
	LastEditedAt *DateTime `json:"lastEditedAt,omitempty"`
	// Returns why the comment was minimized. One of `abuse`, `off-topic`,
	// `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
	// formatting of these values differs from the inputs to the `MinimizeComment` mutation.
	MinimizedReason *string `json:"minimizedReason,omitempty"`
	// Identifies when the comment was published at.
	PublishedAt *DateTime `json:"publishedAt,omitempty"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// A list of edits to this content.
	UserContentEdits *UserContentEditConnection `json:"userContentEdits,omitempty"`
	// Check if the current viewer can delete this object.
	ViewerCanDelete bool `json:"viewerCanDelete"`
	// Check if the current viewer can minimize this object.
	ViewerCanMinimize bool `json:"viewerCanMinimize"`
	// Check if the current viewer can update this object.
	ViewerCanUpdate bool `json:"viewerCanUpdate"`
	// Reasons why the current viewer can not update this comment.
	ViewerCannotUpdateReasons []CommentCannotUpdateReason `json:"viewerCannotUpdateReasons"`
	// Did the viewer author this comment.
	ViewerDidAuthor bool `json:"viewerDidAuthor"`
}

func (*GistComment) isComment() {}

func (*GistComment) isDeletable() {}

func (*GistComment) isMinimizable() {}

func (*GistComment) isNode() {}

func (*GistComment) isUpdatable() {}

func (*GistComment) isUpdatableComment() {}

// The connection type for GistComment.
type GistCommentConnection struct {
	// A list of edges.
	Edges []*GistCommentEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*GistComment `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type GistCommentEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *GistComment `json:"node,omitempty"`
}

// The connection type for Gist.
type GistConnection struct {
	// A list of edges.
	Edges []*GistEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*Gist `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type GistEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *Gist `json:"node,omitempty"`
}

// A file in a gist.
type GistFile struct {
	// The file name encoded to remove characters that are invalid in URL paths.
	EncodedName *string `json:"encodedName,omitempty"`
	// The gist file encoding.
	Encoding *string `json:"encoding,omitempty"`
	// The file extension from the file name.
	Extension *string `json:"extension,omitempty"`
	// Indicates if this file is an image.
	IsImage bool `json:"isImage"`
	// Whether the file's contents were truncated.
	IsTruncated bool `json:"isTruncated"`
	// The programming language this file is written in.
	Language *Language `json:"language,omitempty"`
	// The gist file name.
	Name *string `json:"name,omitempty"`
	// The gist file size in bytes.
	Size *int32 `json:"size,omitempty"`
	// UTF8 text data or null if the file is binary
	Text *string `json:"text,omitempty"`
}

// Ordering options for gist connections
type GistOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order repositories by.
	Field GistOrderField `json:"field"`
}

// Properties by which gist connections can be ordered.
type GistOrderField string

const (
	// Order gists by creation time
	GistOrderFieldCreatedAt GistOrderField = "CREATED_AT"
	// Order gists by push time
	GistOrderFieldPushedAt GistOrderField = "PUSHED_AT"
	// Order gists by update time
	GistOrderFieldUpdatedAt GistOrderField = "UPDATED_AT"
)

// The privacy of a Gist
type GistPrivacy string

const (
	// Gists that are public and secret
	GistPrivacyAll GistPrivacy = "ALL"
	// Public
	GistPrivacyPublic GistPrivacy = "PUBLIC"
	// Secret
	GistPrivacySecret GistPrivacy = "SECRET"
)

// Represents an actor in a Git commit (ie. an author or committer).
type GitActor struct {
	// A URL pointing to the author's public avatar.
	AvatarUrl URI `json:"avatarUrl"`
	// The timestamp of the Git action (authoring or committing).
	Date *GitTimestamp `json:"date,omitempty"`
	// The email in the Git commit.
	Email *string `json:"email,omitempty"`
	// The name in the Git commit.
	Name *string `json:"name,omitempty"`
	// The GitHub user corresponding to the email field. Null if no such user exists.
	User *User `json:"user,omitempty"`
}

// The connection type for GitActor.
type GitActorConnection struct {
	// A list of edges.
	Edges []*GitActorEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*GitActor `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type GitActorEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *GitActor `json:"node,omitempty"`
}

// Represents information about the GitHub instance.
type GitHubMetadata struct {
	// Returns a String that's a SHA of `github-services`
	GitHubServicesSha GitObjectID `json:"gitHubServicesSha"`
	// IP addresses that users connect to for git operations
	GitIpAddresses []string `json:"gitIpAddresses,omitempty"`
	// IP addresses that GitHub Enterprise Importer uses for outbound connections
	GithubEnterpriseImporterIpAddresses []string `json:"githubEnterpriseImporterIpAddresses,omitempty"`
	// IP addresses that service hooks are sent from
	HookIpAddresses []string `json:"hookIpAddresses,omitempty"`
	// IP addresses that the importer connects from
	ImporterIpAddresses []string `json:"importerIpAddresses,omitempty"`
	// Whether or not users are verified
	IsPasswordAuthenticationVerifiable bool `json:"isPasswordAuthenticationVerifiable"`
	// IP addresses for GitHub Pages' A records
	PagesIpAddresses []string `json:"pagesIpAddresses,omitempty"`
}

// Represents a Git object.
type GitObject struct {
	// An abbreviated version of the Git object ID
	AbbreviatedOid string `json:"abbreviatedOid"`
	// The HTTP path for this Git object
	CommitResourcePath URI `json:"commitResourcePath"`
	// The HTTP URL for this Git object
	CommitUrl URI `json:"commitUrl"`
	// The Node ID of the GitObject object
	Id string `json:"id"`
	// The Git object ID
	Oid GitObjectID `json:"oid"`
	// The Repository the Git object belongs to
	Repository *Repository `json:"repository"`

	// Underlying value of the GraphQL interface
	Value GitObjectValue `json:"-"`
}

func (base *GitObject) UnmarshalJSON(b []byte) error {
	type Raw GitObject
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Blob":
		base.Value = new(Blob)
	case "Commit":
		base.Value = new(Commit)
	case "Tag":
		base.Value = new(Tag)
	case "Tree":
		base.Value = new(Tree)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface GitObject: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// GitObjectValue is one of: Blob | Commit | Tag | Tree
type GitObjectValue interface {
	isGitObject()
}

// A Git object ID.
type GitObjectID string

// A fully qualified reference name (e.g. `refs/heads/master`).
type GitRefname string

// Git SSH string
type GitSSHRemote string

// Information about a signature (GPG or S/MIME) on a Commit or Tag.
type GitSignature struct {
	// Email used to sign this object.
	Email string `json:"email"`
	// True if the signature is valid and verified by GitHub.
	IsValid bool `json:"isValid"`
	// Payload for GPG signing object. Raw ODB object without the signature header.
	Payload string `json:"payload"`
	// ASCII-armored signature header from object.
	Signature string `json:"signature"`
	// GitHub user corresponding to the email signing this commit.
	Signer *User `json:"signer,omitempty"`
	// The state of this signature. `VALID` if signature is valid and verified by
	// GitHub, otherwise represents reason why signature is considered invalid.
	State GitSignatureState `json:"state"`
	// The date the signature was verified, if valid
	VerifiedAt *DateTime `json:"verifiedAt,omitempty"`
	// True if the signature was made with GitHub's signing key.
	WasSignedByGitHub bool `json:"wasSignedByGitHub"`

	// Underlying value of the GraphQL interface
	Value GitSignatureValue `json:"-"`
}

func (base *GitSignature) UnmarshalJSON(b []byte) error {
	type Raw GitSignature
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "GpgSignature":
		base.Value = new(GpgSignature)
	case "SmimeSignature":
		base.Value = new(SmimeSignature)
	case "SshSignature":
		base.Value = new(SshSignature)
	case "UnknownSignature":
		base.Value = new(UnknownSignature)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface GitSignature: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// GitSignatureValue is one of: GpgSignature | SmimeSignature | SshSignature | UnknownSignature
type GitSignatureValue interface {
	isGitSignature()
}

// The state of a Git signature.
type GitSignatureState string

const (
	// The signing certificate or its chain could not be verified
	GitSignatureStateBadCert GitSignatureState = "BAD_CERT"
	// Invalid email used for signing
	GitSignatureStateBadEmail GitSignatureState = "BAD_EMAIL"
	// Signing key expired
	GitSignatureStateExpiredKey GitSignatureState = "EXPIRED_KEY"
	// Internal error - the GPG verification service misbehaved
	GitSignatureStateGpgverifyError GitSignatureState = "GPGVERIFY_ERROR"
	// Internal error - the GPG verification service is unavailable at the moment
	GitSignatureStateGpgverifyUnavailable GitSignatureState = "GPGVERIFY_UNAVAILABLE"
	// Invalid signature
	GitSignatureStateInvalid GitSignatureState = "INVALID"
	// Malformed signature
	GitSignatureStateMalformedSig GitSignatureState = "MALFORMED_SIG"
	// The usage flags for the key that signed this don't allow signing
	GitSignatureStateNotSigningKey GitSignatureState = "NOT_SIGNING_KEY"
	// Email used for signing not known to GitHub
	GitSignatureStateNoUser GitSignatureState = "NO_USER"
	// Valid signature, though certificate revocation check failed
	GitSignatureStateOcspError GitSignatureState = "OCSP_ERROR"
	// Valid signature, pending certificate revocation checking
	GitSignatureStateOcspPending GitSignatureState = "OCSP_PENDING"
	// One or more certificates in chain has been revoked
	GitSignatureStateOcspRevoked GitSignatureState = "OCSP_REVOKED"
	// Key used for signing not known to GitHub
	GitSignatureStateUnknownKey GitSignatureState = "UNKNOWN_KEY"
	// Unknown signature type
	GitSignatureStateUnknownSigType GitSignatureState = "UNKNOWN_SIG_TYPE"
	// Unsigned
	GitSignatureStateUnsigned GitSignatureState = "UNSIGNED"
	// Email used for signing unverified on GitHub
	GitSignatureStateUnverifiedEmail GitSignatureState = "UNVERIFIED_EMAIL"
	// Valid signature and verified by GitHub
	GitSignatureStateValid GitSignatureState = "VALID"
)

// An ISO-8601 encoded date string. Unlike the DateTime type, GitTimestamp is not converted in UTC.
type GitTimestamp string

// Represents a GPG signature on a Commit or Tag.
type GpgSignature struct {
	// Email used to sign this object.
	Email string `json:"email"`
	// True if the signature is valid and verified by GitHub.
	IsValid bool `json:"isValid"`
	// Hex-encoded ID of the key that signed this object.
	KeyId *string `json:"keyId,omitempty"`
	// Payload for GPG signing object. Raw ODB object without the signature header.
	Payload string `json:"payload"`
	// ASCII-armored signature header from object.
	Signature string `json:"signature"`
	// GitHub user corresponding to the email signing this commit.
	Signer *User `json:"signer,omitempty"`
	// The state of this signature. `VALID` if signature is valid and verified by
	// GitHub, otherwise represents reason why signature is considered invalid.
	State GitSignatureState `json:"state"`
	// The date the signature was verified, if valid
	VerifiedAt *DateTime `json:"verifiedAt,omitempty"`
	// True if the signature was made with GitHub's signing key.
	WasSignedByGitHub bool `json:"wasSignedByGitHub"`
}

func (*GpgSignature) isGitSignature() {}

// Autogenerated input type of GrantEnterpriseOrganizationsMigratorRole
type GrantEnterpriseOrganizationsMigratorRoleInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the enterprise to which all organizations managed by it will be granted the migrator role.
	EnterpriseId string `json:"enterpriseId"`
	// The login of the user to grant the migrator role
	Login string `json:"login"`
}

// Autogenerated return type of GrantEnterpriseOrganizationsMigratorRole.
type GrantEnterpriseOrganizationsMigratorRolePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The organizations that had the migrator role applied to for the given user.
	Organizations *OrganizationConnection `json:"organizations,omitempty"`
}

// Autogenerated input type of GrantMigratorRole
type GrantMigratorRoleInput struct {
	// The user login or Team slug to grant the migrator role.
	Actor string `json:"actor"`
	// Specifies the type of the actor, can be either USER or TEAM.
	ActorType ActorType `json:"actorType"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the organization that the user/team belongs to.
	OrganizationId string `json:"organizationId"`
}

// Autogenerated return type of GrantMigratorRole.
type GrantMigratorRolePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Did the operation succeed?
	Success *bool `json:"success,omitempty"`
}

// A string containing HTML code.
type HTML string

// Represents a 'head_ref_deleted' event on a given pull request.
type HeadRefDeletedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the Ref associated with the `head_ref_deleted` event.
	HeadRef *Ref `json:"headRef,omitempty"`
	// Identifies the name of the Ref associated with the `head_ref_deleted` event.
	HeadRefName string `json:"headRefName"`
	// The Node ID of the HeadRefDeletedEvent object
	Id string `json:"id"`
	// PullRequest referenced by event.
	PullRequest *PullRequest `json:"pullRequest"`
}

func (*HeadRefDeletedEvent) isNode() {}

func (*HeadRefDeletedEvent) isPullRequestTimelineItem() {}

func (*HeadRefDeletedEvent) isPullRequestTimelineItems() {}

// Represents a 'head_ref_force_pushed' event on a given pull request.
type HeadRefForcePushedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the after commit SHA for the 'head_ref_force_pushed' event.
	AfterCommit *Commit `json:"afterCommit,omitempty"`
	// Identifies the before commit SHA for the 'head_ref_force_pushed' event.
	BeforeCommit *Commit `json:"beforeCommit,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the HeadRefForcePushedEvent object
	Id string `json:"id"`
	// PullRequest referenced by event.
	PullRequest *PullRequest `json:"pullRequest"`
	// Identifies the fully qualified ref name for the 'head_ref_force_pushed' event.
	Ref *Ref `json:"ref,omitempty"`
}

func (*HeadRefForcePushedEvent) isNode() {}

func (*HeadRefForcePushedEvent) isPullRequestTimelineItem() {}

func (*HeadRefForcePushedEvent) isPullRequestTimelineItems() {}

// Represents a 'head_ref_restored' event on a given pull request.
type HeadRefRestoredEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the HeadRefRestoredEvent object
	Id string `json:"id"`
	// PullRequest referenced by event.
	PullRequest *PullRequest `json:"pullRequest"`
}

func (*HeadRefRestoredEvent) isNode() {}

func (*HeadRefRestoredEvent) isPullRequestTimelineItem() {}

func (*HeadRefRestoredEvent) isPullRequestTimelineItems() {}

// Detail needed to display a hovercard for a user
type Hovercard struct {
	// Each of the contexts for this hovercard
	Contexts []HovercardContext `json:"contexts"`
}

// An individual line of a hovercard
type HovercardContext struct {
	// A string describing this context
	Message string `json:"message"`
	// An octicon to accompany this context
	Octicon string `json:"octicon"`

	// Underlying value of the GraphQL interface
	Value HovercardContextValue `json:"-"`
}

func (base *HovercardContext) UnmarshalJSON(b []byte) error {
	type Raw HovercardContext
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "GenericHovercardContext":
		base.Value = new(GenericHovercardContext)
	case "OrganizationTeamsHovercardContext":
		base.Value = new(OrganizationTeamsHovercardContext)
	case "OrganizationsHovercardContext":
		base.Value = new(OrganizationsHovercardContext)
	case "ReviewStatusHovercardContext":
		base.Value = new(ReviewStatusHovercardContext)
	case "ViewerHovercardContext":
		base.Value = new(ViewerHovercardContext)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface HovercardContext: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// HovercardContextValue is one of: GenericHovercardContext | OrganizationTeamsHovercardContext | OrganizationsHovercardContext | ReviewStatusHovercardContext | ViewerHovercardContext
type HovercardContextValue interface {
	isHovercardContext()
}

// The possible states in which authentication can be configured with an identity provider.
type IdentityProviderConfigurationState string

const (
	// Authentication with an identity provider is configured but not enforced.
	IdentityProviderConfigurationStateConfigured IdentityProviderConfigurationState = "CONFIGURED"
	// Authentication with an identity provider is configured and enforced.
	IdentityProviderConfigurationStateEnforced IdentityProviderConfigurationState = "ENFORCED"
	// Authentication with an identity provider is not configured.
	IdentityProviderConfigurationStateUnconfigured IdentityProviderConfigurationState = "UNCONFIGURED"
)

// Autogenerated input type of ImportProject
type ImportProjectInput struct {
	// The description of Project.
	Body *string `json:"body,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// A list of columns containing issues and pull requests.
	ColumnImports []ProjectColumnImport `json:"columnImports"`
	// The name of Project.
	Name string `json:"name"`
	// The name of the Organization or User to create the Project under.
	OwnerName string `json:"ownerName"`
	// Whether the Project is public or not.
	Public *bool `json:"public,omitempty"`
}

// Autogenerated return type of ImportProject.
type ImportProjectPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The new Project!
	Project *Project `json:"project,omitempty"`
}

// Autogenerated input type of InviteEnterpriseAdmin
type InviteEnterpriseAdminInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The email of the person to invite as an administrator.
	Email *string `json:"email,omitempty"`
	// The ID of the enterprise to which you want to invite an administrator.
	EnterpriseId string `json:"enterpriseId"`
	// The login of a user to invite as an administrator.
	Invitee *string `json:"invitee,omitempty"`
	// The role of the administrator.
	Role *EnterpriseAdministratorRole `json:"role,omitempty"`
}

// Autogenerated return type of InviteEnterpriseAdmin.
type InviteEnterpriseAdminPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The created enterprise administrator invitation.
	Invitation *EnterpriseAdministratorInvitation `json:"invitation,omitempty"`
}

// Autogenerated input type of InviteEnterpriseMember
type InviteEnterpriseMemberInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The email of the person to invite as an unaffiliated member.
	Email *string `json:"email,omitempty"`
	// The ID of the enterprise to which you want to invite an unaffiliated member.
	EnterpriseId string `json:"enterpriseId"`
	// The login of a user to invite as an unaffiliated member.
	Invitee *string `json:"invitee,omitempty"`
}

// Autogenerated return type of InviteEnterpriseMember.
type InviteEnterpriseMemberPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The created enterprise member invitation.
	Invitation *EnterpriseMemberInvitation `json:"invitation,omitempty"`
}

// The possible values for the IP allow list enabled setting.
type IpAllowListEnabledSettingValue string

const (
	// The setting is disabled for the owner.
	IpAllowListEnabledSettingValueDisabled IpAllowListEnabledSettingValue = "DISABLED"
	// The setting is enabled for the owner.
	IpAllowListEnabledSettingValueEnabled IpAllowListEnabledSettingValue = "ENABLED"
)

// An IP address or range of addresses that is allowed to access an owner's resources.
type IpAllowListEntry struct {
	// A single IP address or range of IP addresses in CIDR notation.
	AllowListValue string `json:"allowListValue"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the IpAllowListEntry object
	Id string `json:"id"`
	// Whether the entry is currently active.
	IsActive bool `json:"isActive"`
	// The name of the IP allow list entry.
	Name *string `json:"name,omitempty"`
	// The owner of the IP allow list entry.
	Owner IpAllowListOwner `json:"owner"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
}

func (*IpAllowListEntry) isNode() {}

// The connection type for IpAllowListEntry.
type IpAllowListEntryConnection struct {
	// A list of edges.
	Edges []*IpAllowListEntryEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*IpAllowListEntry `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type IpAllowListEntryEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *IpAllowListEntry `json:"node,omitempty"`
}

// Ordering options for IP allow list entry connections.
type IpAllowListEntryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order IP allow list entries by.
	Field IpAllowListEntryOrderField `json:"field"`
}

// Properties by which IP allow list entry connections can be ordered.
type IpAllowListEntryOrderField string

const (
	// Order IP allow list entries by the allow list value.
	IpAllowListEntryOrderFieldAllowListValue IpAllowListEntryOrderField = "ALLOW_LIST_VALUE"
	// Order IP allow list entries by creation time.
	IpAllowListEntryOrderFieldCreatedAt IpAllowListEntryOrderField = "CREATED_AT"
)

// The possible values for the IP allow list configuration for installed GitHub Apps setting.
type IpAllowListForInstalledAppsEnabledSettingValue string

const (
	// The setting is disabled for the owner.
	IpAllowListForInstalledAppsEnabledSettingValueDisabled IpAllowListForInstalledAppsEnabledSettingValue = "DISABLED"
	// The setting is enabled for the owner.
	IpAllowListForInstalledAppsEnabledSettingValueEnabled IpAllowListForInstalledAppsEnabledSettingValue = "ENABLED"
)

// Types that can own an IP allow list.
type IpAllowListOwner struct {
	// Underlying value of the GraphQL union
	Value IpAllowListOwnerValue `json:"-"`
}

func (base *IpAllowListOwner) UnmarshalJSON(b []byte) error {
	type Raw IpAllowListOwner
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "App":
		base.Value = new(App)
	case "Enterprise":
		base.Value = new(Enterprise)
	case "Organization":
		base.Value = new(Organization)
	case "":
		return fmt.Errorf("gqlclient: union IpAllowListOwner: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union IpAllowListOwner: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// IpAllowListOwnerValue is one of: App | Enterprise | Organization
type IpAllowListOwnerValue interface {
	isIpAllowListOwner()
}

// An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project.
type Issue struct {
	// Reason that the conversation was locked.
	ActiveLockReason *LockReason `json:"activeLockReason,omitempty"`
	// A list of actors assigned to this object.
	AssignedActors *AssigneeConnection `json:"assignedActors"`
	// A list of Users assigned to this object.
	Assignees *UserConnection `json:"assignees"`
	// The actor who authored the comment.
	Author *Actor `json:"author,omitempty"`
	// Author's association with the subject of the comment.
	AuthorAssociation CommentAuthorAssociation `json:"authorAssociation"`
	// Identifies the body of the issue.
	Body string `json:"body"`
	// The body rendered to HTML.
	BodyHTML HTML `json:"bodyHTML"`
	// The http path for this issue body
	BodyResourcePath URI `json:"bodyResourcePath"`
	// Identifies the body of the issue rendered to text.
	BodyText string `json:"bodyText"`
	// The http URL for this issue body
	BodyUrl URI `json:"bodyUrl"`
	// Indicates if the object is closed (definition of closed may depend on type)
	Closed bool `json:"closed"`
	// Identifies the date and time when the object was closed.
	ClosedAt *DateTime `json:"closedAt,omitempty"`
	// List of open pull requests referenced from this issue
	ClosedByPullRequestsReferences *PullRequestConnection `json:"closedByPullRequestsReferences,omitempty"`
	// A list of comments associated with the Issue.
	Comments *IssueCommentConnection `json:"comments"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Check if this comment was created via an email reply.
	CreatedViaEmail bool `json:"createdViaEmail"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The actor who edited the comment.
	Editor *Actor `json:"editor,omitempty"`
	// Identifies the primary key from the database as a BigInt.
	FullDatabaseId *BigInt `json:"fullDatabaseId,omitempty"`
	// The hovercard information for this issue
	Hovercard *Hovercard `json:"hovercard"`
	// The Node ID of the Issue object
	Id string `json:"id"`
	// Check if this comment was edited and includes an edit with the creation data
	IncludesCreatedEdit bool `json:"includesCreatedEdit"`
	// Indicates whether or not this issue is currently pinned to the repository issues list
	IsPinned *bool `json:"isPinned,omitempty"`
	// Is this issue read by the viewer
	IsReadByViewer *bool `json:"isReadByViewer,omitempty"`
	// The issue type for this Issue
	IssueType *IssueType `json:"issueType,omitempty"`
	// A list of labels associated with the object.
	Labels *LabelConnection `json:"labels,omitempty"`
	// The moment the editor made the last edit
	LastEditedAt *DateTime `json:"lastEditedAt,omitempty"`
	// Branches linked to this issue.
	LinkedBranches *LinkedBranchConnection `json:"linkedBranches"`
	// `true` if the object is locked
	Locked bool `json:"locked"`
	// Identifies the milestone associated with the issue.
	Milestone *Milestone `json:"milestone,omitempty"`
	// Identifies the issue number.
	Number int32 `json:"number"`
	// The parent entity of the issue.
	Parent *Issue `json:"parent,omitempty"`
	// A list of Users that are participating in the Issue conversation.
	Participants *UserConnection `json:"participants"`
	// List of project cards associated with this issue.
	ProjectCards *ProjectCardConnection `json:"projectCards"`
	// List of project items associated with this issue.
	ProjectItems *ProjectV2ItemConnection `json:"projectItems"`
	// Find a project by number.
	ProjectV2 *ProjectV2 `json:"projectV2,omitempty"`
	// A list of projects under the owner.
	ProjectsV2 *ProjectV2Connection `json:"projectsV2"`
	// Identifies when the comment was published at.
	PublishedAt *DateTime `json:"publishedAt,omitempty"`
	// A list of reactions grouped by content left on the subject.
	ReactionGroups []ReactionGroup `json:"reactionGroups,omitempty"`
	// A list of Reactions left on the Issue.
	Reactions *ReactionConnection `json:"reactions"`
	// The repository associated with this node.
	Repository *Repository `json:"repository"`
	// The HTTP path for this issue
	ResourcePath URI `json:"resourcePath"`
	// Identifies the state of the issue.
	State IssueState `json:"state"`
	// Identifies the reason for the issue state.
	StateReason *IssueStateReason `json:"stateReason,omitempty"`
	// A list of sub-issues associated with the Issue.
	SubIssues *IssueConnection `json:"subIssues"`
	// Summary of the state of an issue's sub-issues
	SubIssuesSummary *SubIssuesSummary `json:"subIssuesSummary"`
	// A list of suggested actors to assign to this object
	SuggestedActors *AssigneeConnection `json:"suggestedActors"`
	// A list of events, comments, commits, etc. associated with the issue.
	Timeline *IssueTimelineConnection `json:"timeline"`
	// A list of events, comments, commits, etc. associated with the issue.
	TimelineItems *IssueTimelineItemsConnection `json:"timelineItems"`
	// Identifies the issue title.
	Title string `json:"title"`
	// Identifies the issue title rendered to HTML.
	TitleHTML string `json:"titleHTML"`
	// A list of issues that track this issue
	TrackedInIssues *IssueConnection `json:"trackedInIssues"`
	// A list of issues tracked inside the current issue
	TrackedIssues *IssueConnection `json:"trackedIssues"`
	// The number of tracked issues for this issue
	TrackedIssuesCount int32 `json:"trackedIssuesCount"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The HTTP URL for this issue
	Url URI `json:"url"`
	// A list of edits to this content.
	UserContentEdits *UserContentEditConnection `json:"userContentEdits,omitempty"`
	// Indicates if the object can be closed by the viewer.
	ViewerCanClose bool `json:"viewerCanClose"`
	// Check if the current viewer can delete this object.
	ViewerCanDelete bool `json:"viewerCanDelete"`
	// Indicates if the viewer can edit labels for this object.
	ViewerCanLabel bool `json:"viewerCanLabel"`
	// Can user react to this subject
	ViewerCanReact bool `json:"viewerCanReact"`
	// Indicates if the object can be reopened by the viewer.
	ViewerCanReopen bool `json:"viewerCanReopen"`
	// Check if the viewer is able to change their subscription status for the repository.
	ViewerCanSubscribe bool `json:"viewerCanSubscribe"`
	// Check if the current viewer can update this object.
	ViewerCanUpdate bool `json:"viewerCanUpdate"`
	// Reasons why the current viewer can not update this comment.
	ViewerCannotUpdateReasons []CommentCannotUpdateReason `json:"viewerCannotUpdateReasons"`
	// Did the viewer author this comment.
	ViewerDidAuthor bool `json:"viewerDidAuthor"`
	// Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
	ViewerSubscription *SubscriptionState `json:"viewerSubscription,omitempty"`
	// Identifies the viewer's thread subscription form action.
	ViewerThreadSubscriptionFormAction *ThreadSubscriptionFormAction `json:"viewerThreadSubscriptionFormAction,omitempty"`
	// Identifies the viewer's thread subscription status.
	ViewerThreadSubscriptionStatus *ThreadSubscriptionState `json:"viewerThreadSubscriptionStatus,omitempty"`
}

func (*Issue) isAssignable() {}

func (*Issue) isClosable() {}

func (*Issue) isComment() {}

func (*Issue) isDeletable() {}

func (*Issue) isLabelable() {}

func (*Issue) isLockable() {}

func (*Issue) isNode() {}

func (*Issue) isProjectV2Owner() {}

func (*Issue) isReactable() {}

func (*Issue) isRepositoryNode() {}

func (*Issue) isSubscribable() {}

func (*Issue) isSubscribableThread() {}

func (*Issue) isUniformResourceLocatable() {}

func (*Issue) isUpdatable() {}

func (*Issue) isUpdatableComment() {}

func (*Issue) isIssueOrPullRequest() {}

func (*Issue) isMilestoneItem() {}

func (*Issue) isProjectCardItem() {}

func (*Issue) isProjectV2ItemContent() {}

func (*Issue) isReferencedSubject() {}

func (*Issue) isRenamedTitleSubject() {}

func (*Issue) isSearchResultItem() {}

// The possible state reasons of a closed issue.
type IssueClosedStateReason string

const (
	// An issue that has been closed as completed
	IssueClosedStateReasonCompleted IssueClosedStateReason = "COMPLETED"
	// An issue that has been closed as a duplicate
	IssueClosedStateReasonDuplicate IssueClosedStateReason = "DUPLICATE"
	// An issue that has been closed as not planned
	IssueClosedStateReasonNotPlanned IssueClosedStateReason = "NOT_PLANNED"
)

// Represents a comment on an Issue.
type IssueComment struct {
	// The actor who authored the comment.
	Author *Actor `json:"author,omitempty"`
	// Author's association with the subject of the comment.
	AuthorAssociation CommentAuthorAssociation `json:"authorAssociation"`
	// The body as Markdown.
	Body string `json:"body"`
	// The body rendered to HTML.
	BodyHTML HTML `json:"bodyHTML"`
	// The body rendered to text.
	BodyText string `json:"bodyText"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Check if this comment was created via an email reply.
	CreatedViaEmail bool `json:"createdViaEmail"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The actor who edited the comment.
	Editor *Actor `json:"editor,omitempty"`
	// Identifies the primary key from the database as a BigInt.
	FullDatabaseId *BigInt `json:"fullDatabaseId,omitempty"`
	// The Node ID of the IssueComment object
	Id string `json:"id"`
	// Check if this comment was edited and includes an edit with the creation data
	IncludesCreatedEdit bool `json:"includesCreatedEdit"`
	// Returns whether or not a comment has been minimized.
	IsMinimized bool `json:"isMinimized"`
	// Identifies the issue associated with the comment.
	Issue *Issue `json:"issue"`
	// The moment the editor made the last edit
	LastEditedAt *DateTime `json:"lastEditedAt,omitempty"`
	// Returns why the comment was minimized. One of `abuse`, `off-topic`,
	// `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
	// formatting of these values differs from the inputs to the `MinimizeComment` mutation.
	MinimizedReason *string `json:"minimizedReason,omitempty"`
	// Identifies when the comment was published at.
	PublishedAt *DateTime `json:"publishedAt,omitempty"`
	// Returns the pull request associated with the comment, if this comment was made on a
	// pull request.
	PullRequest *PullRequest `json:"pullRequest,omitempty"`
	// A list of reactions grouped by content left on the subject.
	ReactionGroups []ReactionGroup `json:"reactionGroups,omitempty"`
	// A list of Reactions left on the Issue.
	Reactions *ReactionConnection `json:"reactions"`
	// The repository associated with this node.
	Repository *Repository `json:"repository"`
	// The HTTP path for this issue comment
	ResourcePath URI `json:"resourcePath"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The HTTP URL for this issue comment
	Url URI `json:"url"`
	// A list of edits to this content.
	UserContentEdits *UserContentEditConnection `json:"userContentEdits,omitempty"`
	// Check if the current viewer can delete this object.
	ViewerCanDelete bool `json:"viewerCanDelete"`
	// Check if the current viewer can minimize this object.
	ViewerCanMinimize bool `json:"viewerCanMinimize"`
	// Can user react to this subject
	ViewerCanReact bool `json:"viewerCanReact"`
	// Check if the current viewer can update this object.
	ViewerCanUpdate bool `json:"viewerCanUpdate"`
	// Reasons why the current viewer can not update this comment.
	ViewerCannotUpdateReasons []CommentCannotUpdateReason `json:"viewerCannotUpdateReasons"`
	// Did the viewer author this comment.
	ViewerDidAuthor bool `json:"viewerDidAuthor"`
}

func (*IssueComment) isComment() {}

func (*IssueComment) isDeletable() {}

func (*IssueComment) isMinimizable() {}

func (*IssueComment) isNode() {}

func (*IssueComment) isReactable() {}

func (*IssueComment) isRepositoryNode() {}

func (*IssueComment) isUpdatable() {}

func (*IssueComment) isUpdatableComment() {}

func (*IssueComment) isIssueTimelineItem() {}

func (*IssueComment) isIssueTimelineItems() {}

func (*IssueComment) isPullRequestTimelineItem() {}

func (*IssueComment) isPullRequestTimelineItems() {}

// The connection type for IssueComment.
type IssueCommentConnection struct {
	// A list of edges.
	Edges []*IssueCommentEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*IssueComment `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type IssueCommentEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *IssueComment `json:"node,omitempty"`
}

// Ways in which lists of issue comments can be ordered upon return.
type IssueCommentOrder struct {
	// The direction in which to order issue comments by the specified field.
	Direction OrderDirection `json:"direction"`
	// The field in which to order issue comments by.
	Field IssueCommentOrderField `json:"field"`
}

// Properties by which issue comment connections can be ordered.
type IssueCommentOrderField string

const (
	// Order issue comments by update time
	IssueCommentOrderFieldUpdatedAt IssueCommentOrderField = "UPDATED_AT"
)

// The connection type for Issue.
type IssueConnection struct {
	// A list of edges.
	Edges []*IssueEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*Issue `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// This aggregates issues opened by a user within one repository.
type IssueContributionsByRepository struct {
	// The issue contributions.
	Contributions *CreatedIssueContributionConnection `json:"contributions"`
	// The repository in which the issues were opened.
	Repository *Repository `json:"repository"`
}

// An edge in a connection.
type IssueEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *Issue `json:"node,omitempty"`
}

// Ways in which to filter lists of issues.
type IssueFilters struct {
	// List issues assigned to given name. Pass in `null` for issues with no assigned
	// user, and `*` for issues assigned to any user.
	Assignee *string `json:"assignee,omitempty"`
	// List issues created by given name.
	CreatedBy *string `json:"createdBy,omitempty"`
	// List issues where the list of label names exist on the issue.
	Labels []string `json:"labels,omitempty"`
	// List issues where the given name is mentioned in the issue.
	Mentioned *string `json:"mentioned,omitempty"`
	// List issues by given milestone argument. If an string representation of an
	// integer is passed, it should refer to a milestone by its database ID. Pass in
	// `null` for issues with no milestone, and `*` for issues that are assigned to any milestone.
	Milestone *string `json:"milestone,omitempty"`
	// List issues by given milestone argument. If an string representation of an
	// integer is passed, it should refer to a milestone by its number field. Pass in
	// `null` for issues with no milestone, and `*` for issues that are assigned to any milestone.
	MilestoneNumber *string `json:"milestoneNumber,omitempty"`
	// List issues that have been updated at or after the given date.
	Since *DateTime `json:"since,omitempty"`
	// List issues filtered by the list of states given.
	States []IssueState `json:"states,omitempty"`
	// List issues filtered by the type given, only supported by searches on repositories.
	Type *string `json:"type,omitempty"`
	// List issues subscribed to by viewer.
	ViewerSubscribed *bool `json:"viewerSubscribed,omitempty"`
}

// Used for return value of Repository.issueOrPullRequest.
type IssueOrPullRequest struct {
	// Underlying value of the GraphQL union
	Value IssueOrPullRequestValue `json:"-"`
}

func (base *IssueOrPullRequest) UnmarshalJSON(b []byte) error {
	type Raw IssueOrPullRequest
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Issue":
		base.Value = new(Issue)
	case "PullRequest":
		base.Value = new(PullRequest)
	case "":
		return fmt.Errorf("gqlclient: union IssueOrPullRequest: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union IssueOrPullRequest: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// IssueOrPullRequestValue is one of: Issue | PullRequest
type IssueOrPullRequestValue interface {
	isIssueOrPullRequest()
}

// Ways in which lists of issues can be ordered upon return.
type IssueOrder struct {
	// The direction in which to order issues by the specified field.
	Direction OrderDirection `json:"direction"`
	// The field in which to order issues by.
	Field IssueOrderField `json:"field"`
}

// Properties by which issue connections can be ordered.
type IssueOrderField string

const (
	// Order issues by comment count
	IssueOrderFieldComments IssueOrderField = "COMMENTS"
	// Order issues by creation time
	IssueOrderFieldCreatedAt IssueOrderField = "CREATED_AT"
	// Order issues by update time
	IssueOrderFieldUpdatedAt IssueOrderField = "UPDATED_AT"
)

// The possible states of an issue.
type IssueState string

const (
	// An issue that has been closed
	IssueStateClosed IssueState = "CLOSED"
	// An issue that is still open
	IssueStateOpen IssueState = "OPEN"
)

// The possible state reasons of an issue.
type IssueStateReason string

const (
	// An issue that has been closed as completed
	IssueStateReasonCompleted IssueStateReason = "COMPLETED"
	// An issue that has been closed as a duplicate. To retrieve this value, set
	// `(enableDuplicate: true)` when querying the stateReason field.
	IssueStateReasonDuplicate IssueStateReason = "DUPLICATE"
	// An issue that has been closed as not planned
	IssueStateReasonNotPlanned IssueStateReason = "NOT_PLANNED"
	// An issue that has been reopened
	IssueStateReasonReopened IssueStateReason = "REOPENED"
)

// A repository issue template.
type IssueTemplate struct {
	// The template purpose.
	About *string `json:"about,omitempty"`
	// The suggested assignees.
	Assignees *UserConnection `json:"assignees"`
	// The suggested issue body.
	Body *string `json:"body,omitempty"`
	// The template filename.
	Filename string `json:"filename"`
	// The suggested issue labels
	Labels *LabelConnection `json:"labels,omitempty"`
	// The template name.
	Name string `json:"name"`
	// The suggested issue title.
	Title *string `json:"title,omitempty"`
	// The suggested issue type
	Type *IssueType `json:"type,omitempty"`
}

// The connection type for IssueTimelineItem.
type IssueTimelineConnection struct {
	// A list of edges.
	Edges []*IssueTimelineItemEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*IssueTimelineItem `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An item in an issue timeline
type IssueTimelineItem struct {
	// Underlying value of the GraphQL union
	Value IssueTimelineItemValue `json:"-"`
}

func (base *IssueTimelineItem) UnmarshalJSON(b []byte) error {
	type Raw IssueTimelineItem
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "AssignedEvent":
		base.Value = new(AssignedEvent)
	case "ClosedEvent":
		base.Value = new(ClosedEvent)
	case "Commit":
		base.Value = new(Commit)
	case "CrossReferencedEvent":
		base.Value = new(CrossReferencedEvent)
	case "DemilestonedEvent":
		base.Value = new(DemilestonedEvent)
	case "IssueComment":
		base.Value = new(IssueComment)
	case "LabeledEvent":
		base.Value = new(LabeledEvent)
	case "LockedEvent":
		base.Value = new(LockedEvent)
	case "MilestonedEvent":
		base.Value = new(MilestonedEvent)
	case "ReferencedEvent":
		base.Value = new(ReferencedEvent)
	case "RenamedTitleEvent":
		base.Value = new(RenamedTitleEvent)
	case "ReopenedEvent":
		base.Value = new(ReopenedEvent)
	case "SubscribedEvent":
		base.Value = new(SubscribedEvent)
	case "TransferredEvent":
		base.Value = new(TransferredEvent)
	case "UnassignedEvent":
		base.Value = new(UnassignedEvent)
	case "UnlabeledEvent":
		base.Value = new(UnlabeledEvent)
	case "UnlockedEvent":
		base.Value = new(UnlockedEvent)
	case "UnsubscribedEvent":
		base.Value = new(UnsubscribedEvent)
	case "UserBlockedEvent":
		base.Value = new(UserBlockedEvent)
	case "":
		return fmt.Errorf("gqlclient: union IssueTimelineItem: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union IssueTimelineItem: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// IssueTimelineItemValue is one of: AssignedEvent | ClosedEvent | Commit | CrossReferencedEvent | DemilestonedEvent | IssueComment | LabeledEvent | LockedEvent | MilestonedEvent | ReferencedEvent | RenamedTitleEvent | ReopenedEvent | SubscribedEvent | TransferredEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnsubscribedEvent | UserBlockedEvent
type IssueTimelineItemValue interface {
	isIssueTimelineItem()
}

// An edge in a connection.
type IssueTimelineItemEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *IssueTimelineItem `json:"node,omitempty"`
}

// An item in an issue timeline
type IssueTimelineItems struct {
	// Underlying value of the GraphQL union
	Value IssueTimelineItemsValue `json:"-"`
}

func (base *IssueTimelineItems) UnmarshalJSON(b []byte) error {
	type Raw IssueTimelineItems
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "AddedToProjectEvent":
		base.Value = new(AddedToProjectEvent)
	case "AssignedEvent":
		base.Value = new(AssignedEvent)
	case "ClosedEvent":
		base.Value = new(ClosedEvent)
	case "CommentDeletedEvent":
		base.Value = new(CommentDeletedEvent)
	case "ConnectedEvent":
		base.Value = new(ConnectedEvent)
	case "ConvertedNoteToIssueEvent":
		base.Value = new(ConvertedNoteToIssueEvent)
	case "ConvertedToDiscussionEvent":
		base.Value = new(ConvertedToDiscussionEvent)
	case "CrossReferencedEvent":
		base.Value = new(CrossReferencedEvent)
	case "DemilestonedEvent":
		base.Value = new(DemilestonedEvent)
	case "DisconnectedEvent":
		base.Value = new(DisconnectedEvent)
	case "IssueComment":
		base.Value = new(IssueComment)
	case "IssueTypeAddedEvent":
		base.Value = new(IssueTypeAddedEvent)
	case "IssueTypeChangedEvent":
		base.Value = new(IssueTypeChangedEvent)
	case "IssueTypeRemovedEvent":
		base.Value = new(IssueTypeRemovedEvent)
	case "LabeledEvent":
		base.Value = new(LabeledEvent)
	case "LockedEvent":
		base.Value = new(LockedEvent)
	case "MarkedAsDuplicateEvent":
		base.Value = new(MarkedAsDuplicateEvent)
	case "MentionedEvent":
		base.Value = new(MentionedEvent)
	case "MilestonedEvent":
		base.Value = new(MilestonedEvent)
	case "MovedColumnsInProjectEvent":
		base.Value = new(MovedColumnsInProjectEvent)
	case "ParentIssueAddedEvent":
		base.Value = new(ParentIssueAddedEvent)
	case "ParentIssueRemovedEvent":
		base.Value = new(ParentIssueRemovedEvent)
	case "PinnedEvent":
		base.Value = new(PinnedEvent)
	case "ReferencedEvent":
		base.Value = new(ReferencedEvent)
	case "RemovedFromProjectEvent":
		base.Value = new(RemovedFromProjectEvent)
	case "RenamedTitleEvent":
		base.Value = new(RenamedTitleEvent)
	case "ReopenedEvent":
		base.Value = new(ReopenedEvent)
	case "SubIssueAddedEvent":
		base.Value = new(SubIssueAddedEvent)
	case "SubIssueRemovedEvent":
		base.Value = new(SubIssueRemovedEvent)
	case "SubscribedEvent":
		base.Value = new(SubscribedEvent)
	case "TransferredEvent":
		base.Value = new(TransferredEvent)
	case "UnassignedEvent":
		base.Value = new(UnassignedEvent)
	case "UnlabeledEvent":
		base.Value = new(UnlabeledEvent)
	case "UnlockedEvent":
		base.Value = new(UnlockedEvent)
	case "UnmarkedAsDuplicateEvent":
		base.Value = new(UnmarkedAsDuplicateEvent)
	case "UnpinnedEvent":
		base.Value = new(UnpinnedEvent)
	case "UnsubscribedEvent":
		base.Value = new(UnsubscribedEvent)
	case "UserBlockedEvent":
		base.Value = new(UserBlockedEvent)
	case "":
		return fmt.Errorf("gqlclient: union IssueTimelineItems: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union IssueTimelineItems: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// IssueTimelineItemsValue is one of: AddedToProjectEvent | AssignedEvent | ClosedEvent | CommentDeletedEvent | ConnectedEvent | ConvertedNoteToIssueEvent | ConvertedToDiscussionEvent | CrossReferencedEvent | DemilestonedEvent | DisconnectedEvent | IssueComment | IssueTypeAddedEvent | IssueTypeChangedEvent | IssueTypeRemovedEvent | LabeledEvent | LockedEvent | MarkedAsDuplicateEvent | MentionedEvent | MilestonedEvent | MovedColumnsInProjectEvent | ParentIssueAddedEvent | ParentIssueRemovedEvent | PinnedEvent | ReferencedEvent | RemovedFromProjectEvent | RenamedTitleEvent | ReopenedEvent | SubIssueAddedEvent | SubIssueRemovedEvent | SubscribedEvent | TransferredEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnmarkedAsDuplicateEvent | UnpinnedEvent | UnsubscribedEvent | UserBlockedEvent
type IssueTimelineItemsValue interface {
	isIssueTimelineItems()
}

// The connection type for IssueTimelineItems.
type IssueTimelineItemsConnection struct {
	// A list of edges.
	Edges []*IssueTimelineItemsEdge `json:"edges,omitempty"`
	// Identifies the count of items after applying `before` and `after` filters.
	FilteredCount int32 `json:"filteredCount"`
	// A list of nodes.
	Nodes []*IssueTimelineItems `json:"nodes,omitempty"`
	// Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing.
	PageCount int32 `json:"pageCount"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
	// Identifies the date and time when the timeline was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
}

// An edge in a connection.
type IssueTimelineItemsEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *IssueTimelineItems `json:"node,omitempty"`
}

// The possible item types found in a timeline.
type IssueTimelineItemsItemType string

const (
	// Represents a 'added_to_project' event on a given issue or pull request.
	IssueTimelineItemsItemTypeAddedToProjectEvent IssueTimelineItemsItemType = "ADDED_TO_PROJECT_EVENT"
	// Represents an 'assigned' event on any assignable object.
	IssueTimelineItemsItemTypeAssignedEvent IssueTimelineItemsItemType = "ASSIGNED_EVENT"
	// Represents a 'closed' event on any `Closable`.
	IssueTimelineItemsItemTypeClosedEvent IssueTimelineItemsItemType = "CLOSED_EVENT"
	// Represents a 'comment_deleted' event on a given issue or pull request.
	IssueTimelineItemsItemTypeCommentDeletedEvent IssueTimelineItemsItemType = "COMMENT_DELETED_EVENT"
	// Represents a 'connected' event on a given issue or pull request.
	IssueTimelineItemsItemTypeConnectedEvent IssueTimelineItemsItemType = "CONNECTED_EVENT"
	// Represents a 'converted_note_to_issue' event on a given issue or pull request.
	IssueTimelineItemsItemTypeConvertedNoteToIssueEvent IssueTimelineItemsItemType = "CONVERTED_NOTE_TO_ISSUE_EVENT"
	// Represents a 'converted_to_discussion' event on a given issue.
	IssueTimelineItemsItemTypeConvertedToDiscussionEvent IssueTimelineItemsItemType = "CONVERTED_TO_DISCUSSION_EVENT"
	// Represents a mention made by one issue or pull request to another.
	IssueTimelineItemsItemTypeCrossReferencedEvent IssueTimelineItemsItemType = "CROSS_REFERENCED_EVENT"
	// Represents a 'demilestoned' event on a given issue or pull request.
	IssueTimelineItemsItemTypeDemilestonedEvent IssueTimelineItemsItemType = "DEMILESTONED_EVENT"
	// Represents a 'disconnected' event on a given issue or pull request.
	IssueTimelineItemsItemTypeDisconnectedEvent IssueTimelineItemsItemType = "DISCONNECTED_EVENT"
	// Represents a comment on an Issue.
	IssueTimelineItemsItemTypeIssueComment IssueTimelineItemsItemType = "ISSUE_COMMENT"
	// Represents a 'issue_type_added' event on a given issue.
	IssueTimelineItemsItemTypeIssueTypeAddedEvent IssueTimelineItemsItemType = "ISSUE_TYPE_ADDED_EVENT"
	// Represents a 'issue_type_changed' event on a given issue.
	IssueTimelineItemsItemTypeIssueTypeChangedEvent IssueTimelineItemsItemType = "ISSUE_TYPE_CHANGED_EVENT"
	// Represents a 'issue_type_removed' event on a given issue.
	IssueTimelineItemsItemTypeIssueTypeRemovedEvent IssueTimelineItemsItemType = "ISSUE_TYPE_REMOVED_EVENT"
	// Represents a 'labeled' event on a given issue or pull request.
	IssueTimelineItemsItemTypeLabeledEvent IssueTimelineItemsItemType = "LABELED_EVENT"
	// Represents a 'locked' event on a given issue or pull request.
	IssueTimelineItemsItemTypeLockedEvent IssueTimelineItemsItemType = "LOCKED_EVENT"
	// Represents a 'marked_as_duplicate' event on a given issue or pull request.
	IssueTimelineItemsItemTypeMarkedAsDuplicateEvent IssueTimelineItemsItemType = "MARKED_AS_DUPLICATE_EVENT"
	// Represents a 'mentioned' event on a given issue or pull request.
	IssueTimelineItemsItemTypeMentionedEvent IssueTimelineItemsItemType = "MENTIONED_EVENT"
	// Represents a 'milestoned' event on a given issue or pull request.
	IssueTimelineItemsItemTypeMilestonedEvent IssueTimelineItemsItemType = "MILESTONED_EVENT"
	// Represents a 'moved_columns_in_project' event on a given issue or pull request.
	IssueTimelineItemsItemTypeMovedColumnsInProjectEvent IssueTimelineItemsItemType = "MOVED_COLUMNS_IN_PROJECT_EVENT"
	// Represents a 'parent_issue_added' event on a given issue.
	IssueTimelineItemsItemTypeParentIssueAddedEvent IssueTimelineItemsItemType = "PARENT_ISSUE_ADDED_EVENT"
	// Represents a 'parent_issue_removed' event on a given issue.
	IssueTimelineItemsItemTypeParentIssueRemovedEvent IssueTimelineItemsItemType = "PARENT_ISSUE_REMOVED_EVENT"
	// Represents a 'pinned' event on a given issue or pull request.
	IssueTimelineItemsItemTypePinnedEvent IssueTimelineItemsItemType = "PINNED_EVENT"
	// Represents a 'referenced' event on a given `ReferencedSubject`.
	IssueTimelineItemsItemTypeReferencedEvent IssueTimelineItemsItemType = "REFERENCED_EVENT"
	// Represents a 'removed_from_project' event on a given issue or pull request.
	IssueTimelineItemsItemTypeRemovedFromProjectEvent IssueTimelineItemsItemType = "REMOVED_FROM_PROJECT_EVENT"
	// Represents a 'renamed' event on a given issue or pull request
	IssueTimelineItemsItemTypeRenamedTitleEvent IssueTimelineItemsItemType = "RENAMED_TITLE_EVENT"
	// Represents a 'reopened' event on any `Closable`.
	IssueTimelineItemsItemTypeReopenedEvent IssueTimelineItemsItemType = "REOPENED_EVENT"
	// Represents a 'subscribed' event on a given `Subscribable`.
	IssueTimelineItemsItemTypeSubscribedEvent IssueTimelineItemsItemType = "SUBSCRIBED_EVENT"
	// Represents a 'sub_issue_added' event on a given issue.
	IssueTimelineItemsItemTypeSubIssueAddedEvent IssueTimelineItemsItemType = "SUB_ISSUE_ADDED_EVENT"
	// Represents a 'sub_issue_removed' event on a given issue.
	IssueTimelineItemsItemTypeSubIssueRemovedEvent IssueTimelineItemsItemType = "SUB_ISSUE_REMOVED_EVENT"
	// Represents a 'transferred' event on a given issue or pull request.
	IssueTimelineItemsItemTypeTransferredEvent IssueTimelineItemsItemType = "TRANSFERRED_EVENT"
	// Represents an 'unassigned' event on any assignable object.
	IssueTimelineItemsItemTypeUnassignedEvent IssueTimelineItemsItemType = "UNASSIGNED_EVENT"
	// Represents an 'unlabeled' event on a given issue or pull request.
	IssueTimelineItemsItemTypeUnlabeledEvent IssueTimelineItemsItemType = "UNLABELED_EVENT"
	// Represents an 'unlocked' event on a given issue or pull request.
	IssueTimelineItemsItemTypeUnlockedEvent IssueTimelineItemsItemType = "UNLOCKED_EVENT"
	// Represents an 'unmarked_as_duplicate' event on a given issue or pull request.
	IssueTimelineItemsItemTypeUnmarkedAsDuplicateEvent IssueTimelineItemsItemType = "UNMARKED_AS_DUPLICATE_EVENT"
	// Represents an 'unpinned' event on a given issue or pull request.
	IssueTimelineItemsItemTypeUnpinnedEvent IssueTimelineItemsItemType = "UNPINNED_EVENT"
	// Represents an 'unsubscribed' event on a given `Subscribable`.
	IssueTimelineItemsItemTypeUnsubscribedEvent IssueTimelineItemsItemType = "UNSUBSCRIBED_EVENT"
	// Represents a 'user_blocked' event on a given user.
	IssueTimelineItemsItemTypeUserBlockedEvent IssueTimelineItemsItemType = "USER_BLOCKED_EVENT"
)

// Represents the type of Issue.
type IssueType struct {
	// The issue type's color.
	Color IssueTypeColor `json:"color"`
	// The issue type's description.
	Description *string `json:"description,omitempty"`
	// The Node ID of the IssueType object
	Id string `json:"id"`
	// The issue type's enabled state.
	IsEnabled bool `json:"isEnabled"`
	// Whether the issue type is publicly visible.
	IsPrivate bool `json:"isPrivate"`
	// The issues with this issue type in the given repository.
	Issues *IssueConnection `json:"issues"`
	// The issue type's name.
	Name string `json:"name"`
}

func (*IssueType) isNode() {}

// Represents a 'issue_type_added' event on a given issue.
type IssueTypeAddedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the IssueTypeAddedEvent object
	Id string `json:"id"`
	// The issue type added.
	IssueType *IssueType `json:"issueType,omitempty"`
}

func (*IssueTypeAddedEvent) isIssueTimelineItems() {}

func (*IssueTypeAddedEvent) isNode() {}

func (*IssueTypeAddedEvent) isPullRequestTimelineItems() {}

// Represents a 'issue_type_changed' event on a given issue.
type IssueTypeChangedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the IssueTypeChangedEvent object
	Id string `json:"id"`
	// The issue type added.
	IssueType *IssueType `json:"issueType,omitempty"`
	// The issue type removed.
	PrevIssueType *IssueType `json:"prevIssueType,omitempty"`
}

func (*IssueTypeChangedEvent) isIssueTimelineItems() {}

func (*IssueTypeChangedEvent) isNode() {}

func (*IssueTypeChangedEvent) isPullRequestTimelineItems() {}

// The possible color for an issue type
type IssueTypeColor string

const (
	// blue
	IssueTypeColorBlue IssueTypeColor = "BLUE"
	// gray
	IssueTypeColorGray IssueTypeColor = "GRAY"
	// green
	IssueTypeColorGreen IssueTypeColor = "GREEN"
	// orange
	IssueTypeColorOrange IssueTypeColor = "ORANGE"
	// pink
	IssueTypeColorPink IssueTypeColor = "PINK"
	// purple
	IssueTypeColorPurple IssueTypeColor = "PURPLE"
	// red
	IssueTypeColorRed IssueTypeColor = "RED"
	// yellow
	IssueTypeColorYellow IssueTypeColor = "YELLOW"
)

// The connection type for IssueType.
type IssueTypeConnection struct {
	// A list of edges.
	Edges []*IssueTypeEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*IssueType `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type IssueTypeEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *IssueType `json:"node,omitempty"`
}

// Ordering options for issue types connections
type IssueTypeOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order issue types by.
	Field IssueTypeOrderField `json:"field"`
}

// Properties by which issue type connections can be ordered.
type IssueTypeOrderField string

const (
	// Order issue types by creation time
	IssueTypeOrderFieldCreatedAt IssueTypeOrderField = "CREATED_AT"
	// Order issue types by name
	IssueTypeOrderFieldName IssueTypeOrderField = "NAME"
)

// Represents a 'issue_type_removed' event on a given issue.
type IssueTypeRemovedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the IssueTypeRemovedEvent object
	Id string `json:"id"`
	// The issue type removed.
	IssueType *IssueType `json:"issueType,omitempty"`
}

func (*IssueTypeRemovedEvent) isIssueTimelineItems() {}

func (*IssueTypeRemovedEvent) isNode() {}

func (*IssueTypeRemovedEvent) isPullRequestTimelineItems() {}

// Represents a user signing up for a GitHub account.
type JoinedGitHubContribution struct {
	// Whether this contribution is associated with a record you do not have access to. For
	// example, your own 'first issue' contribution may have been made on a repository you can no
	// longer access.
	IsRestricted bool `json:"isRestricted"`
	// When this contribution was made.
	OccurredAt DateTime `json:"occurredAt"`
	// The HTTP path for this contribution.
	ResourcePath URI `json:"resourcePath"`
	// The HTTP URL for this contribution.
	Url URI `json:"url"`
	// The user who made this contribution.
	User *User `json:"user"`
}

func (*JoinedGitHubContribution) isContribution() {}

// A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository.
type Label struct {
	// Identifies the label color.
	Color string `json:"color"`
	// Identifies the date and time when the label was created.
	CreatedAt *DateTime `json:"createdAt,omitempty"`
	// A brief description of this label.
	Description *string `json:"description,omitempty"`
	// The Node ID of the Label object
	Id string `json:"id"`
	// Indicates whether or not this is a default label.
	IsDefault bool `json:"isDefault"`
	// A list of issues associated with this label.
	Issues *IssueConnection `json:"issues"`
	// Identifies the label name.
	Name string `json:"name"`
	// A list of pull requests associated with this label.
	PullRequests *PullRequestConnection `json:"pullRequests"`
	// The repository associated with this label.
	Repository *Repository `json:"repository"`
	// The HTTP path for this label.
	ResourcePath URI `json:"resourcePath"`
	// Identifies the date and time when the label was last updated.
	UpdatedAt *DateTime `json:"updatedAt,omitempty"`
	// The HTTP URL for this label.
	Url URI `json:"url"`
}

func (*Label) isNode() {}

// The connection type for Label.
type LabelConnection struct {
	// A list of edges.
	Edges []*LabelEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*Label `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type LabelEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *Label `json:"node,omitempty"`
}

// Ways in which lists of labels can be ordered upon return.
type LabelOrder struct {
	// The direction in which to order labels by the specified field.
	Direction OrderDirection `json:"direction"`
	// The field in which to order labels by.
	Field LabelOrderField `json:"field"`
}

// Properties by which label connections can be ordered.
type LabelOrderField string

const (
	// Order labels by creation time
	LabelOrderFieldCreatedAt LabelOrderField = "CREATED_AT"
	// Order labels by name
	LabelOrderFieldName LabelOrderField = "NAME"
)

// An object that can have labels assigned to it.
type Labelable struct {
	// A list of labels associated with the object.
	Labels *LabelConnection `json:"labels,omitempty"`
	// Indicates if the viewer can edit labels for this object.
	ViewerCanLabel bool `json:"viewerCanLabel"`

	// Underlying value of the GraphQL interface
	Value LabelableValue `json:"-"`
}

func (base *Labelable) UnmarshalJSON(b []byte) error {
	type Raw Labelable
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Discussion":
		base.Value = new(Discussion)
	case "Issue":
		base.Value = new(Issue)
	case "PullRequest":
		base.Value = new(PullRequest)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface Labelable: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// LabelableValue is one of: Discussion | Issue | PullRequest
type LabelableValue interface {
	isLabelable()
}

// Represents a 'labeled' event on a given issue or pull request.
type LabeledEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the LabeledEvent object
	Id string `json:"id"`
	// Identifies the label associated with the 'labeled' event.
	Label *Label `json:"label"`
	// Identifies the `Labelable` associated with the event.
	Labelable *Labelable `json:"labelable"`
}

func (*LabeledEvent) isIssueTimelineItem() {}

func (*LabeledEvent) isIssueTimelineItems() {}

func (*LabeledEvent) isNode() {}

func (*LabeledEvent) isPullRequestTimelineItem() {}

func (*LabeledEvent) isPullRequestTimelineItems() {}

// Represents a given language found in repositories.
type Language struct {
	// The color defined for the current language.
	Color *string `json:"color,omitempty"`
	// The Node ID of the Language object
	Id string `json:"id"`
	// The name of the current language.
	Name string `json:"name"`
}

func (*Language) isNode() {}

// A list of languages associated with the parent.
type LanguageConnection struct {
	// A list of edges.
	Edges []*LanguageEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*Language `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
	// The total size in bytes of files written in that language.
	TotalSize int32 `json:"totalSize"`
}

// Represents the language of a repository.
type LanguageEdge struct {
	Cursor string    `json:"cursor"`
	Node   *Language `json:"node"`
	// The number of bytes of code written in the language.
	Size int32 `json:"size"`
}

// Ordering options for language connections.
type LanguageOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order languages by.
	Field LanguageOrderField `json:"field"`
}

// Properties by which language connections can be ordered.
type LanguageOrderField string

const (
	// Order languages by the size of all files containing the language
	LanguageOrderFieldSize LanguageOrderField = "SIZE"
)

// A repository's open source license
type License struct {
	// The full text of the license
	Body string `json:"body"`
	// The conditions set by the license
	Conditions []*LicenseRule `json:"conditions"`
	// A human-readable description of the license
	Description *string `json:"description,omitempty"`
	// Whether the license should be featured
	Featured bool `json:"featured"`
	// Whether the license should be displayed in license pickers
	Hidden bool `json:"hidden"`
	// The Node ID of the License object
	Id string `json:"id"`
	// Instructions on how to implement the license
	Implementation *string `json:"implementation,omitempty"`
	// The lowercased SPDX ID of the license
	Key string `json:"key"`
	// The limitations set by the license
	Limitations []*LicenseRule `json:"limitations"`
	// The license full name specified by <https://spdx.org/licenses>
	Name string `json:"name"`
	// Customary short name if applicable (e.g, GPLv3)
	Nickname *string `json:"nickname,omitempty"`
	// The permissions set by the license
	Permissions []*LicenseRule `json:"permissions"`
	// Whether the license is a pseudo-license placeholder (e.g., other, no-license)
	PseudoLicense bool `json:"pseudoLicense"`
	// Short identifier specified by <https://spdx.org/licenses>
	SpdxId *string `json:"spdxId,omitempty"`
	// URL to the license on <https://choosealicense.com>
	Url *URI `json:"url,omitempty"`
}

func (*License) isNode() {}

// Describes a License's conditions, permissions, and limitations
type LicenseRule struct {
	// A description of the rule
	Description string `json:"description"`
	// The machine-readable rule key
	Key string `json:"key"`
	// The human-readable rule label
	Label string `json:"label"`
}

// Autogenerated input type of LinkProjectV2ToRepository
type LinkProjectV2ToRepositoryInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the project to link to the repository.
	ProjectId string `json:"projectId"`
	// The ID of the repository to link to the project.
	RepositoryId string `json:"repositoryId"`
}

// Autogenerated return type of LinkProjectV2ToRepository.
type LinkProjectV2ToRepositoryPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The repository the project is linked to.
	Repository *Repository `json:"repository,omitempty"`
}

// Autogenerated input type of LinkProjectV2ToTeam
type LinkProjectV2ToTeamInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the project to link to the team.
	ProjectId string `json:"projectId"`
	// The ID of the team to link to the project.
	TeamId string `json:"teamId"`
}

// Autogenerated return type of LinkProjectV2ToTeam.
type LinkProjectV2ToTeamPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The team the project is linked to
	Team *Team `json:"team,omitempty"`
}

// Autogenerated input type of LinkRepositoryToProject
type LinkRepositoryToProjectInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the Project to link to a Repository
	ProjectId string `json:"projectId"`
	// The ID of the Repository to link to a Project.
	RepositoryId string `json:"repositoryId"`
}

// Autogenerated return type of LinkRepositoryToProject.
type LinkRepositoryToProjectPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The linked Project.
	Project *Project `json:"project,omitempty"`
	// The linked Repository.
	Repository *Repository `json:"repository,omitempty"`
}

// A branch linked to an issue.
type LinkedBranch struct {
	// The Node ID of the LinkedBranch object
	Id string `json:"id"`
	// The branch's ref.
	Ref *Ref `json:"ref,omitempty"`
}

func (*LinkedBranch) isNode() {}

// A list of branches linked to an issue.
type LinkedBranchConnection struct {
	// A list of edges.
	Edges []*LinkedBranchEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*LinkedBranch `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type LinkedBranchEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *LinkedBranch `json:"node,omitempty"`
}

// Autogenerated input type of LockLockable
type LockLockableInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// A reason for why the item will be locked.
	LockReason *LockReason `json:"lockReason,omitempty"`
	// ID of the item to be locked.
	LockableId string `json:"lockableId"`
}

// Autogenerated return type of LockLockable.
type LockLockablePayload struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The item that was locked.
	LockedRecord *Lockable `json:"lockedRecord,omitempty"`
}

// The possible reasons that an issue or pull request was locked.
type LockReason string

const (
	// The issue or pull request was locked because the conversation was off-topic.
	LockReasonOffTopic LockReason = "OFF_TOPIC"
	// The issue or pull request was locked because the conversation was resolved.
	LockReasonResolved LockReason = "RESOLVED"
	// The issue or pull request was locked because the conversation was spam.
	LockReasonSpam LockReason = "SPAM"
	// The issue or pull request was locked because the conversation was too heated.
	LockReasonTooHeated LockReason = "TOO_HEATED"
)

// An object that can be locked.
type Lockable struct {
	// Reason that the conversation was locked.
	ActiveLockReason *LockReason `json:"activeLockReason,omitempty"`
	// `true` if the object is locked
	Locked bool `json:"locked"`

	// Underlying value of the GraphQL interface
	Value LockableValue `json:"-"`
}

func (base *Lockable) UnmarshalJSON(b []byte) error {
	type Raw Lockable
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Discussion":
		base.Value = new(Discussion)
	case "Issue":
		base.Value = new(Issue)
	case "PullRequest":
		base.Value = new(PullRequest)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface Lockable: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// LockableValue is one of: Discussion | Issue | PullRequest
type LockableValue interface {
	isLockable()
}

// Represents a 'locked' event on a given issue or pull request.
type LockedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the LockedEvent object
	Id string `json:"id"`
	// Reason that the conversation was locked (optional).
	LockReason *LockReason `json:"lockReason,omitempty"`
	// Object that was locked.
	Lockable *Lockable `json:"lockable"`
}

func (*LockedEvent) isIssueTimelineItem() {}

func (*LockedEvent) isIssueTimelineItems() {}

func (*LockedEvent) isNode() {}

func (*LockedEvent) isPullRequestTimelineItem() {}

func (*LockedEvent) isPullRequestTimelineItems() {}

// A placeholder user for attribution of imported data on GitHub.
type Mannequin struct {
	// A URL pointing to the GitHub App's public avatar.
	AvatarUrl URI `json:"avatarUrl"`
	// The user that has claimed the data attributed to this mannequin.
	Claimant *User `json:"claimant,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The mannequin's email on the source instance.
	Email *string `json:"email,omitempty"`
	// The Node ID of the Mannequin object
	Id string `json:"id"`
	// The username of the actor.
	Login string `json:"login"`
	// The HTML path to this resource.
	ResourcePath URI `json:"resourcePath"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The URL to this resource.
	Url URI `json:"url"`
}

func (*Mannequin) isAssignee() {}

func (*Mannequin) isClaimable() {}

func (*Mannequin) isActor() {}

func (*Mannequin) isNode() {}

func (*Mannequin) isUniformResourceLocatable() {}

func (*Mannequin) isReactor() {}

func (*Mannequin) isRequestedReviewer() {}

// A list of mannequins.
type MannequinConnection struct {
	// A list of edges.
	Edges []*MannequinEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*Mannequin `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// Represents a mannequin.
type MannequinEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *Mannequin `json:"node,omitempty"`
}

// Ordering options for mannequins.
type MannequinOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order mannequins by.
	Field MannequinOrderField `json:"field"`
}

// Properties by which mannequins can be ordered.
type MannequinOrderField string

const (
	// Order mannequins why when they were created.
	MannequinOrderFieldCreatedAt MannequinOrderField = "CREATED_AT"
	// Order mannequins alphabetically by their source login.
	MannequinOrderFieldLogin MannequinOrderField = "LOGIN"
)

// Autogenerated input type of MarkDiscussionCommentAsAnswer
type MarkDiscussionCommentAsAnswerInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Node ID of the discussion comment to mark as an answer.
	Id string `json:"id"`
}

// Autogenerated return type of MarkDiscussionCommentAsAnswer.
type MarkDiscussionCommentAsAnswerPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The discussion that includes the chosen comment.
	Discussion *Discussion `json:"discussion,omitempty"`
}

// Autogenerated input type of MarkFileAsViewed
type MarkFileAsViewedInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The path of the file to mark as viewed
	Path string `json:"path"`
	// The Node ID of the pull request.
	PullRequestId string `json:"pullRequestId"`
}

// Autogenerated return type of MarkFileAsViewed.
type MarkFileAsViewedPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The updated pull request.
	PullRequest *PullRequest `json:"pullRequest,omitempty"`
}

// Autogenerated input type of MarkProjectV2AsTemplate
type MarkProjectV2AsTemplateInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the Project to mark as a template.
	ProjectId string `json:"projectId"`
}

// Autogenerated return type of MarkProjectV2AsTemplate.
type MarkProjectV2AsTemplatePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The project.
	ProjectV2 *ProjectV2 `json:"projectV2,omitempty"`
}

// Autogenerated input type of MarkPullRequestReadyForReview
type MarkPullRequestReadyForReviewInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// ID of the pull request to be marked as ready for review.
	PullRequestId string `json:"pullRequestId"`
}

// Autogenerated return type of MarkPullRequestReadyForReview.
type MarkPullRequestReadyForReviewPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The pull request that is ready for review.
	PullRequest *PullRequest `json:"pullRequest,omitempty"`
}

// Represents a 'marked_as_duplicate' event on a given issue or pull request.
type MarkedAsDuplicateEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// The authoritative issue or pull request which has been duplicated by another.
	Canonical *IssueOrPullRequest `json:"canonical,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The issue or pull request which has been marked as a duplicate of another.
	Duplicate *IssueOrPullRequest `json:"duplicate,omitempty"`
	// The Node ID of the MarkedAsDuplicateEvent object
	Id string `json:"id"`
	// Canonical and duplicate belong to different repositories.
	IsCrossRepository bool `json:"isCrossRepository"`
}

func (*MarkedAsDuplicateEvent) isIssueTimelineItems() {}

func (*MarkedAsDuplicateEvent) isNode() {}

func (*MarkedAsDuplicateEvent) isPullRequestTimelineItems() {}

// A public description of a Marketplace category.
type MarketplaceCategory struct {
	// The category's description.
	Description *string `json:"description,omitempty"`
	// The technical description of how apps listed in this category work with GitHub.
	HowItWorks *string `json:"howItWorks,omitempty"`
	// The Node ID of the MarketplaceCategory object
	Id string `json:"id"`
	// The category's name.
	Name string `json:"name"`
	// How many Marketplace listings have this as their primary category.
	PrimaryListingCount int32 `json:"primaryListingCount"`
	// The HTTP path for this Marketplace category.
	ResourcePath URI `json:"resourcePath"`
	// How many Marketplace listings have this as their secondary category.
	SecondaryListingCount int32 `json:"secondaryListingCount"`
	// The short name of the category used in its URL.
	Slug string `json:"slug"`
	// The HTTP URL for this Marketplace category.
	Url URI `json:"url"`
}

func (*MarketplaceCategory) isNode() {}

// A listing in the GitHub integration marketplace.
type MarketplaceListing struct {
	// The GitHub App this listing represents.
	App *App `json:"app,omitempty"`
	// URL to the listing owner's company site.
	CompanyUrl *URI `json:"companyUrl,omitempty"`
	// The HTTP path for configuring access to the listing's integration or OAuth app
	ConfigurationResourcePath URI `json:"configurationResourcePath"`
	// The HTTP URL for configuring access to the listing's integration or OAuth app
	ConfigurationUrl URI `json:"configurationUrl"`
	// URL to the listing's documentation.
	DocumentationUrl *URI `json:"documentationUrl,omitempty"`
	// The listing's detailed description.
	ExtendedDescription *string `json:"extendedDescription,omitempty"`
	// The listing's detailed description rendered to HTML.
	ExtendedDescriptionHTML HTML `json:"extendedDescriptionHTML"`
	// The listing's introductory description.
	FullDescription string `json:"fullDescription"`
	// The listing's introductory description rendered to HTML.
	FullDescriptionHTML HTML `json:"fullDescriptionHTML"`
	// Does this listing have any plans with a free trial?
	HasPublishedFreeTrialPlans bool `json:"hasPublishedFreeTrialPlans"`
	// Does this listing have a terms of service link?
	HasTermsOfService bool `json:"hasTermsOfService"`
	// Whether the creator of the app is a verified org
	HasVerifiedOwner bool `json:"hasVerifiedOwner"`
	// A technical description of how this app works with GitHub.
	HowItWorks *string `json:"howItWorks,omitempty"`
	// The listing's technical description rendered to HTML.
	HowItWorksHTML HTML `json:"howItWorksHTML"`
	// The Node ID of the MarketplaceListing object
	Id string `json:"id"`
	// URL to install the product to the viewer's account or organization.
	InstallationUrl *URI `json:"installationUrl,omitempty"`
	// Whether this listing's app has been installed for the current viewer
	InstalledForViewer bool `json:"installedForViewer"`
	// Whether this listing has been removed from the Marketplace.
	IsArchived bool `json:"isArchived"`
	// Whether this listing is still an editable draft that has not been submitted
	// for review and is not publicly visible in the Marketplace.
	IsDraft bool `json:"isDraft"`
	// Whether the product this listing represents is available as part of a paid plan.
	IsPaid bool `json:"isPaid"`
	// Whether this listing has been approved for display in the Marketplace.
	IsPublic bool `json:"isPublic"`
	// Whether this listing has been rejected by GitHub for display in the Marketplace.
	IsRejected bool `json:"isRejected"`
	// Whether this listing has been approved for unverified display in the Marketplace.
	IsUnverified bool `json:"isUnverified"`
	// Whether this draft listing has been submitted for review for approval to be unverified in the Marketplace.
	IsUnverifiedPending bool `json:"isUnverifiedPending"`
	// Whether this draft listing has been submitted for review from GitHub for approval to be verified in the Marketplace.
	IsVerificationPendingFromDraft bool `json:"isVerificationPendingFromDraft"`
	// Whether this unverified listing has been submitted for review from GitHub for approval to be verified in the Marketplace.
	IsVerificationPendingFromUnverified bool `json:"isVerificationPendingFromUnverified"`
	// Whether this listing has been approved for verified display in the Marketplace.
	IsVerified bool `json:"isVerified"`
	// The hex color code, without the leading '#', for the logo background.
	LogoBackgroundColor string `json:"logoBackgroundColor"`
	// URL for the listing's logo image.
	LogoUrl *URI `json:"logoUrl,omitempty"`
	// The listing's full name.
	Name string `json:"name"`
	// The listing's very short description without a trailing period or ampersands.
	NormalizedShortDescription string `json:"normalizedShortDescription"`
	// URL to the listing's detailed pricing.
	PricingUrl *URI `json:"pricingUrl,omitempty"`
	// The category that best describes the listing.
	PrimaryCategory *MarketplaceCategory `json:"primaryCategory"`
	// URL to the listing's privacy policy, may return an empty string for listings that do not require a privacy policy URL.
	PrivacyPolicyUrl URI `json:"privacyPolicyUrl"`
	// The HTTP path for the Marketplace listing.
	ResourcePath URI `json:"resourcePath"`
	// The URLs for the listing's screenshots.
	ScreenshotUrls []*string `json:"screenshotUrls"`
	// An alternate category that describes the listing.
	SecondaryCategory *MarketplaceCategory `json:"secondaryCategory,omitempty"`
	// The listing's very short description.
	ShortDescription string `json:"shortDescription"`
	// The short name of the listing used in its URL.
	Slug string `json:"slug"`
	// URL to the listing's status page.
	StatusUrl *URI `json:"statusUrl,omitempty"`
	// An email address for support for this listing's app.
	SupportEmail *string `json:"supportEmail,omitempty"`
	// Either a URL or an email address for support for this listing's app, may
	// return an empty string for listings that do not require a support URL.
	SupportUrl URI `json:"supportUrl"`
	// URL to the listing's terms of service.
	TermsOfServiceUrl *URI `json:"termsOfServiceUrl,omitempty"`
	// The HTTP URL for the Marketplace listing.
	Url URI `json:"url"`
	// Can the current viewer add plans for this Marketplace listing.
	ViewerCanAddPlans bool `json:"viewerCanAddPlans"`
	// Can the current viewer approve this Marketplace listing.
	ViewerCanApprove bool `json:"viewerCanApprove"`
	// Can the current viewer delist this Marketplace listing.
	ViewerCanDelist bool `json:"viewerCanDelist"`
	// Can the current viewer edit this Marketplace listing.
	ViewerCanEdit bool `json:"viewerCanEdit"`
	// Can the current viewer edit the primary and secondary category of this
	// Marketplace listing.
	ViewerCanEditCategories bool `json:"viewerCanEditCategories"`
	// Can the current viewer edit the plans for this Marketplace listing.
	ViewerCanEditPlans bool `json:"viewerCanEditPlans"`
	// Can the current viewer return this Marketplace listing to draft state
	// so it becomes editable again.
	ViewerCanRedraft bool `json:"viewerCanRedraft"`
	// Can the current viewer reject this Marketplace listing by returning it to
	// an editable draft state or rejecting it entirely.
	ViewerCanReject bool `json:"viewerCanReject"`
	// Can the current viewer request this listing be reviewed for display in
	// the Marketplace as verified.
	ViewerCanRequestApproval bool `json:"viewerCanRequestApproval"`
	// Indicates whether the current user has an active subscription to this Marketplace listing.
	ViewerHasPurchased bool `json:"viewerHasPurchased"`
	// Indicates if the current user has purchased a subscription to this Marketplace listing
	// for all of the organizations the user owns.
	ViewerHasPurchasedForAllOrganizations bool `json:"viewerHasPurchasedForAllOrganizations"`
	// Does the current viewer role allow them to administer this Marketplace listing.
	ViewerIsListingAdmin bool `json:"viewerIsListingAdmin"`
}

func (*MarketplaceListing) isNode() {}

func (*MarketplaceListing) isSearchResultItem() {}

// Look up Marketplace Listings
type MarketplaceListingConnection struct {
	// A list of edges.
	Edges []*MarketplaceListingEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*MarketplaceListing `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type MarketplaceListingEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *MarketplaceListing `json:"node,omitempty"`
}

// Prevent commits that include file paths that exceed the specified character limit from being pushed to the commit graph.
type MaxFilePathLengthParameters struct {
	// The maximum amount of characters allowed in file paths.
	MaxFilePathLength int32 `json:"maxFilePathLength"`
}

func (*MaxFilePathLengthParameters) isRuleParameters() {}

// Prevent commits that include file paths that exceed the specified character limit from being pushed to the commit graph.
type MaxFilePathLengthParametersInput struct {
	// The maximum amount of characters allowed in file paths.
	MaxFilePathLength int32 `json:"maxFilePathLength"`
}

// Prevent commits with individual files that exceed the specified limit from being pushed to the commit graph.
type MaxFileSizeParameters struct {
	// The maximum file size allowed in megabytes. This limit does not apply to Git Large File Storage (Git LFS).
	MaxFileSize int32 `json:"maxFileSize"`
}

func (*MaxFileSizeParameters) isRuleParameters() {}

// Prevent commits with individual files that exceed the specified limit from being pushed to the commit graph.
type MaxFileSizeParametersInput struct {
	// The maximum file size allowed in megabytes. This limit does not apply to Git Large File Storage (Git LFS).
	MaxFileSize int32 `json:"maxFileSize"`
}

// Represents a member feature request notification
type MemberFeatureRequestNotification struct {
	// Represents member feature request body containing entity name and the number of feature requests
	Body string `json:"body"`
	// The Node ID of the MemberFeatureRequestNotification object
	Id string `json:"id"`
	// Represents member feature request notification title
	Title string `json:"title"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
}

func (*MemberFeatureRequestNotification) isNode() {}

// Entities that have members who can set status messages.
type MemberStatusable struct {
	// Get the status messages members of this entity have set that are either public or visible only to the organization.
	MemberStatuses *UserStatusConnection `json:"memberStatuses"`

	// Underlying value of the GraphQL interface
	Value MemberStatusableValue `json:"-"`
}

func (base *MemberStatusable) UnmarshalJSON(b []byte) error {
	type Raw MemberStatusable
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Organization":
		base.Value = new(Organization)
	case "Team":
		base.Value = new(Team)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface MemberStatusable: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// MemberStatusableValue is one of: Organization | Team
type MemberStatusableValue interface {
	isMemberStatusable()
}

// Audit log entry for a members_can_delete_repos.clear event.
type MembersCanDeleteReposClearAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The HTTP path for this enterprise.
	EnterpriseResourcePath *URI `json:"enterpriseResourcePath,omitempty"`
	// The slug of the enterprise.
	EnterpriseSlug *string `json:"enterpriseSlug,omitempty"`
	// The HTTP URL for this enterprise.
	EnterpriseUrl *URI `json:"enterpriseUrl,omitempty"`
	// The Node ID of the MembersCanDeleteReposClearAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*MembersCanDeleteReposClearAuditEntry) isAuditEntry() {}

func (*MembersCanDeleteReposClearAuditEntry) isEnterpriseAuditEntryData() {}

func (*MembersCanDeleteReposClearAuditEntry) isNode() {}

func (*MembersCanDeleteReposClearAuditEntry) isOrganizationAuditEntryData() {}

func (*MembersCanDeleteReposClearAuditEntry) isOrganizationAuditEntry() {}

// Audit log entry for a members_can_delete_repos.disable event.
type MembersCanDeleteReposDisableAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The HTTP path for this enterprise.
	EnterpriseResourcePath *URI `json:"enterpriseResourcePath,omitempty"`
	// The slug of the enterprise.
	EnterpriseSlug *string `json:"enterpriseSlug,omitempty"`
	// The HTTP URL for this enterprise.
	EnterpriseUrl *URI `json:"enterpriseUrl,omitempty"`
	// The Node ID of the MembersCanDeleteReposDisableAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*MembersCanDeleteReposDisableAuditEntry) isAuditEntry() {}

func (*MembersCanDeleteReposDisableAuditEntry) isEnterpriseAuditEntryData() {}

func (*MembersCanDeleteReposDisableAuditEntry) isNode() {}

func (*MembersCanDeleteReposDisableAuditEntry) isOrganizationAuditEntryData() {}

func (*MembersCanDeleteReposDisableAuditEntry) isOrganizationAuditEntry() {}

// Audit log entry for a members_can_delete_repos.enable event.
type MembersCanDeleteReposEnableAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The HTTP path for this enterprise.
	EnterpriseResourcePath *URI `json:"enterpriseResourcePath,omitempty"`
	// The slug of the enterprise.
	EnterpriseSlug *string `json:"enterpriseSlug,omitempty"`
	// The HTTP URL for this enterprise.
	EnterpriseUrl *URI `json:"enterpriseUrl,omitempty"`
	// The Node ID of the MembersCanDeleteReposEnableAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*MembersCanDeleteReposEnableAuditEntry) isAuditEntry() {}

func (*MembersCanDeleteReposEnableAuditEntry) isEnterpriseAuditEntryData() {}

func (*MembersCanDeleteReposEnableAuditEntry) isNode() {}

func (*MembersCanDeleteReposEnableAuditEntry) isOrganizationAuditEntryData() {}

func (*MembersCanDeleteReposEnableAuditEntry) isOrganizationAuditEntry() {}

// Represents a 'mentioned' event on a given issue or pull request.
type MentionedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The Node ID of the MentionedEvent object
	Id string `json:"id"`
}

func (*MentionedEvent) isIssueTimelineItems() {}

func (*MentionedEvent) isNode() {}

func (*MentionedEvent) isPullRequestTimelineItems() {}

// Autogenerated input type of MergeBranch
type MergeBranchInput struct {
	// The email address to associate with this commit.
	AuthorEmail *string `json:"authorEmail,omitempty"`
	// The name of the base branch that the provided head will be merged into.
	Base string `json:"base"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Message to use for the merge commit. If omitted, a default will be used.
	CommitMessage *string `json:"commitMessage,omitempty"`
	// The head to merge into the base branch. This can be a branch name or a commit GitObjectID.
	Head string `json:"head"`
	// The Node ID of the Repository containing the base branch that will be modified.
	RepositoryId string `json:"repositoryId"`
}

// Autogenerated return type of MergeBranch.
type MergeBranchPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The resulting merge Commit.
	MergeCommit *Commit `json:"mergeCommit,omitempty"`
}

// The possible default commit messages for merges.
type MergeCommitMessage string

const (
	// Default to a blank commit message.
	MergeCommitMessageBlank MergeCommitMessage = "BLANK"
	// Default to the pull request's body.
	MergeCommitMessagePrBody MergeCommitMessage = "PR_BODY"
	// Default to the pull request's title.
	MergeCommitMessagePrTitle MergeCommitMessage = "PR_TITLE"
)

// The possible default commit titles for merges.
type MergeCommitTitle string

const (
	// Default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
	MergeCommitTitleMergeMessage MergeCommitTitle = "MERGE_MESSAGE"
	// Default to the pull request's title.
	MergeCommitTitlePrTitle MergeCommitTitle = "PR_TITLE"
)

// Autogenerated input type of MergePullRequest
type MergePullRequestInput struct {
	// The email address to associate with this merge.
	AuthorEmail *string `json:"authorEmail,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Commit body to use for the merge commit; if omitted, a default message will be used
	CommitBody *string `json:"commitBody,omitempty"`
	// Commit headline to use for the merge commit; if omitted, a default message will be used.
	CommitHeadline *string `json:"commitHeadline,omitempty"`
	// OID that the pull request head ref must match to allow merge; if omitted, no check is performed.
	ExpectedHeadOid *GitObjectID `json:"expectedHeadOid,omitempty"`
	// The merge method to use. If omitted, defaults to 'MERGE'
	MergeMethod *PullRequestMergeMethod `json:"mergeMethod,omitempty"`
	// ID of the pull request to be merged.
	PullRequestId string `json:"pullRequestId"`
}

// Autogenerated return type of MergePullRequest.
type MergePullRequestPayload struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The pull request that was merged.
	PullRequest *PullRequest `json:"pullRequest,omitempty"`
}

// The queue of pull request entries to be merged into a protected branch in a repository.
type MergeQueue struct {
	// The configuration for this merge queue
	Configuration *MergeQueueConfiguration `json:"configuration,omitempty"`
	// The entries in the queue
	Entries *MergeQueueEntryConnection `json:"entries,omitempty"`
	// The Node ID of the MergeQueue object
	Id string `json:"id"`
	// The estimated time in seconds until a newly added entry would be merged
	NextEntryEstimatedTimeToMerge *int32 `json:"nextEntryEstimatedTimeToMerge,omitempty"`
	// The repository this merge queue belongs to
	Repository *Repository `json:"repository,omitempty"`
	// The HTTP path for this merge queue
	ResourcePath URI `json:"resourcePath"`
	// The HTTP URL for this merge queue
	Url URI `json:"url"`
}

func (*MergeQueue) isNode() {}

// Configuration for a MergeQueue
type MergeQueueConfiguration struct {
	// The amount of time in minutes to wait for a check response before considering it a failure.
	CheckResponseTimeout *int32 `json:"checkResponseTimeout,omitempty"`
	// The maximum number of entries to build at once.
	MaximumEntriesToBuild *int32 `json:"maximumEntriesToBuild,omitempty"`
	// The maximum number of entries to merge at once.
	MaximumEntriesToMerge *int32 `json:"maximumEntriesToMerge,omitempty"`
	// The merge method to use for this queue.
	MergeMethod *PullRequestMergeMethod `json:"mergeMethod,omitempty"`
	// The strategy to use when merging entries.
	MergingStrategy *MergeQueueMergingStrategy `json:"mergingStrategy,omitempty"`
	// The minimum number of entries required to merge at once.
	MinimumEntriesToMerge *int32 `json:"minimumEntriesToMerge,omitempty"`
	// The amount of time in minutes to wait before ignoring the minumum number of
	// entries in the queue requirement and merging a collection of entries
	MinimumEntriesToMergeWaitTime *int32 `json:"minimumEntriesToMergeWaitTime,omitempty"`
}

// Entries in a MergeQueue
type MergeQueueEntry struct {
	// The base commit for this entry
	BaseCommit *Commit `json:"baseCommit,omitempty"`
	// The date and time this entry was added to the merge queue
	EnqueuedAt DateTime `json:"enqueuedAt"`
	// The actor that enqueued this entry
	Enqueuer *Actor `json:"enqueuer"`
	// The estimated time in seconds until this entry will be merged
	EstimatedTimeToMerge *int32 `json:"estimatedTimeToMerge,omitempty"`
	// The head commit for this entry
	HeadCommit *Commit `json:"headCommit,omitempty"`
	// The Node ID of the MergeQueueEntry object
	Id string `json:"id"`
	// Whether this pull request should jump the queue
	Jump bool `json:"jump"`
	// The merge queue that this entry belongs to
	MergeQueue *MergeQueue `json:"mergeQueue,omitempty"`
	// The position of this entry in the queue
	Position int32 `json:"position"`
	// The pull request that will be added to a merge group
	PullRequest *PullRequest `json:"pullRequest,omitempty"`
	// Does this pull request need to be deployed on its own
	Solo bool `json:"solo"`
	// The state of this entry in the queue
	State MergeQueueEntryState `json:"state"`
}

func (*MergeQueueEntry) isNode() {}

// The connection type for MergeQueueEntry.
type MergeQueueEntryConnection struct {
	// A list of edges.
	Edges []*MergeQueueEntryEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*MergeQueueEntry `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type MergeQueueEntryEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *MergeQueueEntry `json:"node,omitempty"`
}

// The possible states for a merge queue entry.
type MergeQueueEntryState string

const (
	// The entry is currently waiting for checks to pass.
	MergeQueueEntryStateAwaitingChecks MergeQueueEntryState = "AWAITING_CHECKS"
	// The entry is currently locked.
	MergeQueueEntryStateLocked MergeQueueEntryState = "LOCKED"
	// The entry is currently mergeable.
	MergeQueueEntryStateMergeable MergeQueueEntryState = "MERGEABLE"
	// The entry is currently queued.
	MergeQueueEntryStateQueued MergeQueueEntryState = "QUEUED"
	// The entry is currently unmergeable.
	MergeQueueEntryStateUnmergeable MergeQueueEntryState = "UNMERGEABLE"
)

// When set to ALLGREEN, the merge commit created by merge queue for each PR in the
// group must pass all required checks to merge. When set to HEADGREEN, only the
// commit at the head of the merge group, i.e. the commit containing changes from
// all of the PRs in the group, must pass its required checks to merge.
type MergeQueueGroupingStrategy string

const (
	// The merge commit created by merge queue for each PR in the group must pass all required checks to merge
	MergeQueueGroupingStrategyAllgreen MergeQueueGroupingStrategy = "ALLGREEN"
	// Only the commit at the head of the merge group must pass its required checks to merge.
	MergeQueueGroupingStrategyHeadgreen MergeQueueGroupingStrategy = "HEADGREEN"
)

// Method to use when merging changes from queued pull requests.
type MergeQueueMergeMethod string

const (
	// Merge commit
	MergeQueueMergeMethodMerge MergeQueueMergeMethod = "MERGE"
	// Rebase and merge
	MergeQueueMergeMethodRebase MergeQueueMergeMethod = "REBASE"
	// Squash and merge
	MergeQueueMergeMethodSquash MergeQueueMergeMethod = "SQUASH"
)

// The possible merging strategies for a merge queue.
type MergeQueueMergingStrategy string

const (
	// Entries only allowed to merge if they are passing.
	MergeQueueMergingStrategyAllgreen MergeQueueMergingStrategy = "ALLGREEN"
	// Failing Entires are allowed to merge if they are with a passing entry.
	MergeQueueMergingStrategyHeadgreen MergeQueueMergingStrategy = "HEADGREEN"
)

// Merges must be performed via a merge queue.
type MergeQueueParameters struct {
	// Maximum time for a required status check to report a conclusion. After this
	// much time has elapsed, checks that have not reported a conclusion will be
	// assumed to have failed
	CheckResponseTimeoutMinutes int32 `json:"checkResponseTimeoutMinutes"`
	// When set to ALLGREEN, the merge commit created by merge queue for each PR in
	// the group must pass all required checks to merge. When set to HEADGREEN, only
	// the commit at the head of the merge group, i.e. the commit containing changes
	// from all of the PRs in the group, must pass its required checks to merge.
	GroupingStrategy MergeQueueGroupingStrategy `json:"groupingStrategy"`
	// Limit the number of queued pull requests requesting checks and workflow runs at the same time.
	MaxEntriesToBuild int32 `json:"maxEntriesToBuild"`
	// The maximum number of PRs that will be merged together in a group.
	MaxEntriesToMerge int32 `json:"maxEntriesToMerge"`
	// Method to use when merging changes from queued pull requests.
	MergeMethod MergeQueueMergeMethod `json:"mergeMethod"`
	// The minimum number of PRs that will be merged together in a group.
	MinEntriesToMerge int32 `json:"minEntriesToMerge"`
	// The time merge queue should wait after the first PR is added to the queue for
	// the minimum group size to be met. After this time has elapsed, the minimum
	// group size will be ignored and a smaller group will be merged.
	MinEntriesToMergeWaitMinutes int32 `json:"minEntriesToMergeWaitMinutes"`
}

func (*MergeQueueParameters) isRuleParameters() {}

// Merges must be performed via a merge queue.
type MergeQueueParametersInput struct {
	// Maximum time for a required status check to report a conclusion. After this
	// much time has elapsed, checks that have not reported a conclusion will be
	// assumed to have failed
	CheckResponseTimeoutMinutes int32 `json:"checkResponseTimeoutMinutes"`
	// When set to ALLGREEN, the merge commit created by merge queue for each PR in
	// the group must pass all required checks to merge. When set to HEADGREEN, only
	// the commit at the head of the merge group, i.e. the commit containing changes
	// from all of the PRs in the group, must pass its required checks to merge.
	GroupingStrategy MergeQueueGroupingStrategy `json:"groupingStrategy"`
	// Limit the number of queued pull requests requesting checks and workflow runs at the same time.
	MaxEntriesToBuild int32 `json:"maxEntriesToBuild"`
	// The maximum number of PRs that will be merged together in a group.
	MaxEntriesToMerge int32 `json:"maxEntriesToMerge"`
	// Method to use when merging changes from queued pull requests.
	MergeMethod MergeQueueMergeMethod `json:"mergeMethod"`
	// The minimum number of PRs that will be merged together in a group.
	MinEntriesToMerge int32 `json:"minEntriesToMerge"`
	// The time merge queue should wait after the first PR is added to the queue for
	// the minimum group size to be met. After this time has elapsed, the minimum
	// group size will be ignored and a smaller group will be merged.
	MinEntriesToMergeWaitMinutes int32 `json:"minEntriesToMergeWaitMinutes"`
}

// Detailed status information about a pull request merge.
type MergeStateStatus string

const (
	// The head ref is out of date.
	MergeStateStatusBehind MergeStateStatus = "BEHIND"
	// The merge is blocked.
	MergeStateStatusBlocked MergeStateStatus = "BLOCKED"
	// Mergeable and passing commit status.
	MergeStateStatusClean MergeStateStatus = "CLEAN"
	// The merge commit cannot be cleanly created.
	MergeStateStatusDirty MergeStateStatus = "DIRTY"
	// The merge is blocked due to the pull request being a draft.
	MergeStateStatusDraft MergeStateStatus = "DRAFT"
	// Mergeable with passing commit status and pre-receive hooks.
	MergeStateStatusHasHooks MergeStateStatus = "HAS_HOOKS"
	// The state cannot currently be determined.
	MergeStateStatusUnknown MergeStateStatus = "UNKNOWN"
	// Mergeable with non-passing commit status.
	MergeStateStatusUnstable MergeStateStatus = "UNSTABLE"
)

// Whether or not a PullRequest can be merged.
type MergeableState string

const (
	// The pull request cannot be merged due to merge conflicts.
	MergeableStateConflicting MergeableState = "CONFLICTING"
	// The pull request can be merged.
	MergeableStateMergeable MergeableState = "MERGEABLE"
	// The mergeability of the pull request is still being calculated.
	MergeableStateUnknown MergeableState = "UNKNOWN"
)

// Represents a 'merged' event on a given pull request.
type MergedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the commit associated with the `merge` event.
	Commit *Commit `json:"commit,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the MergedEvent object
	Id string `json:"id"`
	// Identifies the Ref associated with the `merge` event.
	MergeRef *Ref `json:"mergeRef,omitempty"`
	// Identifies the name of the Ref associated with the `merge` event.
	MergeRefName string `json:"mergeRefName"`
	// PullRequest referenced by event.
	PullRequest *PullRequest `json:"pullRequest"`
	// The HTTP path for this merged event.
	ResourcePath URI `json:"resourcePath"`
	// The HTTP URL for this merged event.
	Url URI `json:"url"`
}

func (*MergedEvent) isNode() {}

func (*MergedEvent) isUniformResourceLocatable() {}

func (*MergedEvent) isPullRequestTimelineItem() {}

func (*MergedEvent) isPullRequestTimelineItems() {}

// Represents a GitHub Enterprise Importer (GEI) migration.
type Migration struct {
	// The migration flag to continue on error.
	ContinueOnError bool `json:"continueOnError"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *string `json:"databaseId,omitempty"`
	// The reason the migration failed.
	FailureReason *string `json:"failureReason,omitempty"`
	// The Node ID of the Migration object
	Id string `json:"id"`
	// The URL for the migration log (expires 1 day after migration completes).
	MigrationLogUrl *URI `json:"migrationLogUrl,omitempty"`
	// The migration source.
	MigrationSource *MigrationSource `json:"migrationSource"`
	// The target repository name.
	RepositoryName string `json:"repositoryName"`
	// The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`.
	SourceUrl URI `json:"sourceUrl"`
	// The migration state.
	State MigrationState `json:"state"`
	// The number of warnings encountered for this migration. To review the warnings,
	// check the [Migration Log](https://docs.github.com/migrations/using-github-enterprise-importer/completing-your-migration-with-github-enterprise-importer/accessing-your-migration-logs-for-github-enterprise-importer).
	WarningsCount int32 `json:"warningsCount"`

	// Underlying value of the GraphQL interface
	Value MigrationValue `json:"-"`
}

func (base *Migration) UnmarshalJSON(b []byte) error {
	type Raw Migration
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "RepositoryMigration":
		base.Value = new(RepositoryMigration)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface Migration: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// MigrationValue is one of: RepositoryMigration
type MigrationValue interface {
	isMigration()
}

// A GitHub Enterprise Importer (GEI) migration source.
type MigrationSource struct {
	// The Node ID of the MigrationSource object
	Id string `json:"id"`
	// The migration source name.
	Name string `json:"name"`
	// The migration source type.
	Type MigrationSourceType `json:"type"`
	// The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`.
	Url URI `json:"url"`
}

func (*MigrationSource) isNode() {}

// Represents the different GitHub Enterprise Importer (GEI) migration sources.
type MigrationSourceType string

const (
	// An Azure DevOps migration source.
	MigrationSourceTypeAzureDevops MigrationSourceType = "AZURE_DEVOPS"
	// A Bitbucket Server migration source.
	MigrationSourceTypeBitbucketServer MigrationSourceType = "BITBUCKET_SERVER"
	// A GitHub Migration API source.
	MigrationSourceTypeGithubArchive MigrationSourceType = "GITHUB_ARCHIVE"
)

// The GitHub Enterprise Importer (GEI) migration state.
type MigrationState string

const (
	// The migration has failed.
	MigrationStateFailed MigrationState = "FAILED"
	// The migration has invalid credentials.
	MigrationStateFailedValidation MigrationState = "FAILED_VALIDATION"
	// The migration is in progress.
	MigrationStateInProgress MigrationState = "IN_PROGRESS"
	// The migration has not started.
	MigrationStateNotStarted MigrationState = "NOT_STARTED"
	// The migration needs to have its credentials validated.
	MigrationStatePendingValidation MigrationState = "PENDING_VALIDATION"
	// The migration has been queued.
	MigrationStateQueued MigrationState = "QUEUED"
	// The migration has succeeded.
	MigrationStateSucceeded MigrationState = "SUCCEEDED"
)

// Represents a Milestone object on a given repository.
type Milestone struct {
	// Indicates if the object is closed (definition of closed may depend on type)
	Closed bool `json:"closed"`
	// Identifies the date and time when the object was closed.
	ClosedAt *DateTime `json:"closedAt,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the actor who created the milestone.
	Creator *Actor `json:"creator,omitempty"`
	// Identifies the description of the milestone.
	Description *string `json:"description,omitempty"`
	// The HTML rendered description of the milestone using GitHub Flavored Markdown.
	DescriptionHTML *string `json:"descriptionHTML,omitempty"`
	// Identifies the due date of the milestone.
	DueOn *DateTime `json:"dueOn,omitempty"`
	// The Node ID of the Milestone object
	Id string `json:"id"`
	// A list of issues associated with the milestone.
	Issues *IssueConnection `json:"issues"`
	// Identifies the number of the milestone.
	Number int32 `json:"number"`
	// Identifies the percentage complete for the milestone
	ProgressPercentage float64 `json:"progressPercentage"`
	// A list of pull requests associated with the milestone.
	PullRequests *PullRequestConnection `json:"pullRequests"`
	// The repository associated with this milestone.
	Repository *Repository `json:"repository"`
	// The HTTP path for this milestone
	ResourcePath URI `json:"resourcePath"`
	// Identifies the state of the milestone.
	State MilestoneState `json:"state"`
	// Identifies the title of the milestone.
	Title string `json:"title"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The HTTP URL for this milestone
	Url URI `json:"url"`
	// Indicates if the object can be closed by the viewer.
	ViewerCanClose bool `json:"viewerCanClose"`
	// Indicates if the object can be reopened by the viewer.
	ViewerCanReopen bool `json:"viewerCanReopen"`
}

func (*Milestone) isClosable() {}

func (*Milestone) isNode() {}

func (*Milestone) isUniformResourceLocatable() {}

// The connection type for Milestone.
type MilestoneConnection struct {
	// A list of edges.
	Edges []*MilestoneEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*Milestone `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type MilestoneEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *Milestone `json:"node,omitempty"`
}

// Types that can be inside a Milestone.
type MilestoneItem struct {
	// Underlying value of the GraphQL union
	Value MilestoneItemValue `json:"-"`
}

func (base *MilestoneItem) UnmarshalJSON(b []byte) error {
	type Raw MilestoneItem
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Issue":
		base.Value = new(Issue)
	case "PullRequest":
		base.Value = new(PullRequest)
	case "":
		return fmt.Errorf("gqlclient: union MilestoneItem: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union MilestoneItem: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// MilestoneItemValue is one of: Issue | PullRequest
type MilestoneItemValue interface {
	isMilestoneItem()
}

// Ordering options for milestone connections.
type MilestoneOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order milestones by.
	Field MilestoneOrderField `json:"field"`
}

// Properties by which milestone connections can be ordered.
type MilestoneOrderField string

const (
	// Order milestones by when they were created.
	MilestoneOrderFieldCreatedAt MilestoneOrderField = "CREATED_AT"
	// Order milestones by when they are due.
	MilestoneOrderFieldDueDate MilestoneOrderField = "DUE_DATE"
	// Order milestones by their number.
	MilestoneOrderFieldNumber MilestoneOrderField = "NUMBER"
	// Order milestones by when they were last updated.
	MilestoneOrderFieldUpdatedAt MilestoneOrderField = "UPDATED_AT"
)

// The possible states of a milestone.
type MilestoneState string

const (
	// A milestone that has been closed.
	MilestoneStateClosed MilestoneState = "CLOSED"
	// A milestone that is still open.
	MilestoneStateOpen MilestoneState = "OPEN"
)

// Represents a 'milestoned' event on a given issue or pull request.
type MilestonedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the MilestonedEvent object
	Id string `json:"id"`
	// Identifies the milestone title associated with the 'milestoned' event.
	MilestoneTitle string `json:"milestoneTitle"`
	// Object referenced by event.
	Subject MilestoneItem `json:"subject"`
}

func (*MilestonedEvent) isIssueTimelineItem() {}

func (*MilestonedEvent) isIssueTimelineItems() {}

func (*MilestonedEvent) isNode() {}

func (*MilestonedEvent) isPullRequestTimelineItem() {}

func (*MilestonedEvent) isPullRequestTimelineItems() {}

// Entities that can be minimized.
type Minimizable struct {
	// Returns whether or not a comment has been minimized.
	IsMinimized bool `json:"isMinimized"`
	// Returns why the comment was minimized. One of `abuse`, `off-topic`,
	// `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
	// formatting of these values differs from the inputs to the `MinimizeComment` mutation.
	MinimizedReason *string `json:"minimizedReason,omitempty"`
	// Check if the current viewer can minimize this object.
	ViewerCanMinimize bool `json:"viewerCanMinimize"`

	// Underlying value of the GraphQL interface
	Value MinimizableValue `json:"-"`
}

func (base *Minimizable) UnmarshalJSON(b []byte) error {
	type Raw Minimizable
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "CommitComment":
		base.Value = new(CommitComment)
	case "DiscussionComment":
		base.Value = new(DiscussionComment)
	case "GistComment":
		base.Value = new(GistComment)
	case "IssueComment":
		base.Value = new(IssueComment)
	case "PullRequestReview":
		base.Value = new(PullRequestReview)
	case "PullRequestReviewComment":
		base.Value = new(PullRequestReviewComment)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface Minimizable: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// MinimizableValue is one of: CommitComment | DiscussionComment | GistComment | IssueComment | PullRequestReview | PullRequestReviewComment
type MinimizableValue interface {
	isMinimizable()
}

// Autogenerated input type of MinimizeComment
type MinimizeCommentInput struct {
	// The classification of comment
	Classifier ReportedContentClassifiers `json:"classifier"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Node ID of the subject to modify.
	SubjectId string `json:"subjectId"`
}

// Autogenerated return type of MinimizeComment.
type MinimizeCommentPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The comment that was minimized.
	MinimizedComment *Minimizable `json:"minimizedComment,omitempty"`
}

// Autogenerated input type of MoveProjectCard
type MoveProjectCardInput struct {
	// Place the new card after the card with this id. Pass null to place it at the top.
	AfterCardId string `json:"afterCardId,omitempty"`
	// The id of the card to move.
	CardId string `json:"cardId"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The id of the column to move it into.
	ColumnId string `json:"columnId"`
}

// Autogenerated return type of MoveProjectCard.
type MoveProjectCardPayload struct {
	// The new edge of the moved card.
	CardEdge *ProjectCardEdge `json:"cardEdge,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
}

// Autogenerated input type of MoveProjectColumn
type MoveProjectColumnInput struct {
	// Place the new column after the column with this id. Pass null to place it at the front.
	AfterColumnId string `json:"afterColumnId,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The id of the column to move.
	ColumnId string `json:"columnId"`
}

// Autogenerated return type of MoveProjectColumn.
type MoveProjectColumnPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The new edge of the moved column.
	ColumnEdge *ProjectColumnEdge `json:"columnEdge,omitempty"`
}

// Represents a 'moved_columns_in_project' event on a given issue or pull request.
type MovedColumnsInProjectEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The Node ID of the MovedColumnsInProjectEvent object
	Id string `json:"id"`
	// Column name the issue or pull request was moved from.
	PreviousProjectColumnName string `json:"previousProjectColumnName"`
	// Project referenced by event.
	Project *Project `json:"project,omitempty"`
	// Project card referenced by this project event.
	ProjectCard *ProjectCard `json:"projectCard,omitempty"`
	// Column name the issue or pull request was moved to.
	ProjectColumnName string `json:"projectColumnName"`
}

func (*MovedColumnsInProjectEvent) isIssueTimelineItems() {}

func (*MovedColumnsInProjectEvent) isNode() {}

func (*MovedColumnsInProjectEvent) isPullRequestTimelineItems() {}

// An object with an ID.
type Node struct {
	// ID of the object.
	Id string `json:"id"`

	// Underlying value of the GraphQL interface
	Value NodeValue `json:"-"`
}

func (base *Node) UnmarshalJSON(b []byte) error {
	type Raw Node
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "AddedToMergeQueueEvent":
		base.Value = new(AddedToMergeQueueEvent)
	case "AddedToProjectEvent":
		base.Value = new(AddedToProjectEvent)
	case "App":
		base.Value = new(App)
	case "AssignedEvent":
		base.Value = new(AssignedEvent)
	case "AutoMergeDisabledEvent":
		base.Value = new(AutoMergeDisabledEvent)
	case "AutoMergeEnabledEvent":
		base.Value = new(AutoMergeEnabledEvent)
	case "AutoRebaseEnabledEvent":
		base.Value = new(AutoRebaseEnabledEvent)
	case "AutoSquashEnabledEvent":
		base.Value = new(AutoSquashEnabledEvent)
	case "AutomaticBaseChangeFailedEvent":
		base.Value = new(AutomaticBaseChangeFailedEvent)
	case "AutomaticBaseChangeSucceededEvent":
		base.Value = new(AutomaticBaseChangeSucceededEvent)
	case "BaseRefChangedEvent":
		base.Value = new(BaseRefChangedEvent)
	case "BaseRefDeletedEvent":
		base.Value = new(BaseRefDeletedEvent)
	case "BaseRefForcePushedEvent":
		base.Value = new(BaseRefForcePushedEvent)
	case "Blob":
		base.Value = new(Blob)
	case "Bot":
		base.Value = new(Bot)
	case "BranchProtectionRule":
		base.Value = new(BranchProtectionRule)
	case "BypassForcePushAllowance":
		base.Value = new(BypassForcePushAllowance)
	case "BypassPullRequestAllowance":
		base.Value = new(BypassPullRequestAllowance)
	case "CWE":
		base.Value = new(CWE)
	case "CheckRun":
		base.Value = new(CheckRun)
	case "CheckSuite":
		base.Value = new(CheckSuite)
	case "ClosedEvent":
		base.Value = new(ClosedEvent)
	case "CodeOfConduct":
		base.Value = new(CodeOfConduct)
	case "CommentDeletedEvent":
		base.Value = new(CommentDeletedEvent)
	case "Commit":
		base.Value = new(Commit)
	case "CommitComment":
		base.Value = new(CommitComment)
	case "CommitCommentThread":
		base.Value = new(CommitCommentThread)
	case "Comparison":
		base.Value = new(Comparison)
	case "ConnectedEvent":
		base.Value = new(ConnectedEvent)
	case "ConvertToDraftEvent":
		base.Value = new(ConvertToDraftEvent)
	case "ConvertedNoteToIssueEvent":
		base.Value = new(ConvertedNoteToIssueEvent)
	case "ConvertedToDiscussionEvent":
		base.Value = new(ConvertedToDiscussionEvent)
	case "CrossReferencedEvent":
		base.Value = new(CrossReferencedEvent)
	case "DemilestonedEvent":
		base.Value = new(DemilestonedEvent)
	case "DependencyGraphManifest":
		base.Value = new(DependencyGraphManifest)
	case "DeployKey":
		base.Value = new(DeployKey)
	case "DeployedEvent":
		base.Value = new(DeployedEvent)
	case "Deployment":
		base.Value = new(Deployment)
	case "DeploymentEnvironmentChangedEvent":
		base.Value = new(DeploymentEnvironmentChangedEvent)
	case "DeploymentReview":
		base.Value = new(DeploymentReview)
	case "DeploymentStatus":
		base.Value = new(DeploymentStatus)
	case "DisconnectedEvent":
		base.Value = new(DisconnectedEvent)
	case "Discussion":
		base.Value = new(Discussion)
	case "DiscussionCategory":
		base.Value = new(DiscussionCategory)
	case "DiscussionComment":
		base.Value = new(DiscussionComment)
	case "DiscussionPoll":
		base.Value = new(DiscussionPoll)
	case "DiscussionPollOption":
		base.Value = new(DiscussionPollOption)
	case "DraftIssue":
		base.Value = new(DraftIssue)
	case "Enterprise":
		base.Value = new(Enterprise)
	case "EnterpriseAdministratorInvitation":
		base.Value = new(EnterpriseAdministratorInvitation)
	case "EnterpriseIdentityProvider":
		base.Value = new(EnterpriseIdentityProvider)
	case "EnterpriseMemberInvitation":
		base.Value = new(EnterpriseMemberInvitation)
	case "EnterpriseRepositoryInfo":
		base.Value = new(EnterpriseRepositoryInfo)
	case "EnterpriseServerInstallation":
		base.Value = new(EnterpriseServerInstallation)
	case "EnterpriseServerUserAccount":
		base.Value = new(EnterpriseServerUserAccount)
	case "EnterpriseServerUserAccountEmail":
		base.Value = new(EnterpriseServerUserAccountEmail)
	case "EnterpriseServerUserAccountsUpload":
		base.Value = new(EnterpriseServerUserAccountsUpload)
	case "EnterpriseUserAccount":
		base.Value = new(EnterpriseUserAccount)
	case "Environment":
		base.Value = new(Environment)
	case "ExternalIdentity":
		base.Value = new(ExternalIdentity)
	case "Gist":
		base.Value = new(Gist)
	case "GistComment":
		base.Value = new(GistComment)
	case "HeadRefDeletedEvent":
		base.Value = new(HeadRefDeletedEvent)
	case "HeadRefForcePushedEvent":
		base.Value = new(HeadRefForcePushedEvent)
	case "HeadRefRestoredEvent":
		base.Value = new(HeadRefRestoredEvent)
	case "IpAllowListEntry":
		base.Value = new(IpAllowListEntry)
	case "Issue":
		base.Value = new(Issue)
	case "IssueComment":
		base.Value = new(IssueComment)
	case "IssueType":
		base.Value = new(IssueType)
	case "IssueTypeAddedEvent":
		base.Value = new(IssueTypeAddedEvent)
	case "IssueTypeChangedEvent":
		base.Value = new(IssueTypeChangedEvent)
	case "IssueTypeRemovedEvent":
		base.Value = new(IssueTypeRemovedEvent)
	case "Label":
		base.Value = new(Label)
	case "LabeledEvent":
		base.Value = new(LabeledEvent)
	case "Language":
		base.Value = new(Language)
	case "License":
		base.Value = new(License)
	case "LinkedBranch":
		base.Value = new(LinkedBranch)
	case "LockedEvent":
		base.Value = new(LockedEvent)
	case "Mannequin":
		base.Value = new(Mannequin)
	case "MarkedAsDuplicateEvent":
		base.Value = new(MarkedAsDuplicateEvent)
	case "MarketplaceCategory":
		base.Value = new(MarketplaceCategory)
	case "MarketplaceListing":
		base.Value = new(MarketplaceListing)
	case "MemberFeatureRequestNotification":
		base.Value = new(MemberFeatureRequestNotification)
	case "MembersCanDeleteReposClearAuditEntry":
		base.Value = new(MembersCanDeleteReposClearAuditEntry)
	case "MembersCanDeleteReposDisableAuditEntry":
		base.Value = new(MembersCanDeleteReposDisableAuditEntry)
	case "MembersCanDeleteReposEnableAuditEntry":
		base.Value = new(MembersCanDeleteReposEnableAuditEntry)
	case "MentionedEvent":
		base.Value = new(MentionedEvent)
	case "MergeQueue":
		base.Value = new(MergeQueue)
	case "MergeQueueEntry":
		base.Value = new(MergeQueueEntry)
	case "MergedEvent":
		base.Value = new(MergedEvent)
	case "MigrationSource":
		base.Value = new(MigrationSource)
	case "Milestone":
		base.Value = new(Milestone)
	case "MilestonedEvent":
		base.Value = new(MilestonedEvent)
	case "MovedColumnsInProjectEvent":
		base.Value = new(MovedColumnsInProjectEvent)
	case "OIDCProvider":
		base.Value = new(OIDCProvider)
	case "OauthApplicationCreateAuditEntry":
		base.Value = new(OauthApplicationCreateAuditEntry)
	case "OrgAddBillingManagerAuditEntry":
		base.Value = new(OrgAddBillingManagerAuditEntry)
	case "OrgAddMemberAuditEntry":
		base.Value = new(OrgAddMemberAuditEntry)
	case "OrgBlockUserAuditEntry":
		base.Value = new(OrgBlockUserAuditEntry)
	case "OrgConfigDisableCollaboratorsOnlyAuditEntry":
		base.Value = new(OrgConfigDisableCollaboratorsOnlyAuditEntry)
	case "OrgConfigEnableCollaboratorsOnlyAuditEntry":
		base.Value = new(OrgConfigEnableCollaboratorsOnlyAuditEntry)
	case "OrgCreateAuditEntry":
		base.Value = new(OrgCreateAuditEntry)
	case "OrgDisableOauthAppRestrictionsAuditEntry":
		base.Value = new(OrgDisableOauthAppRestrictionsAuditEntry)
	case "OrgDisableSamlAuditEntry":
		base.Value = new(OrgDisableSamlAuditEntry)
	case "OrgDisableTwoFactorRequirementAuditEntry":
		base.Value = new(OrgDisableTwoFactorRequirementAuditEntry)
	case "OrgEnableOauthAppRestrictionsAuditEntry":
		base.Value = new(OrgEnableOauthAppRestrictionsAuditEntry)
	case "OrgEnableSamlAuditEntry":
		base.Value = new(OrgEnableSamlAuditEntry)
	case "OrgEnableTwoFactorRequirementAuditEntry":
		base.Value = new(OrgEnableTwoFactorRequirementAuditEntry)
	case "OrgInviteMemberAuditEntry":
		base.Value = new(OrgInviteMemberAuditEntry)
	case "OrgInviteToBusinessAuditEntry":
		base.Value = new(OrgInviteToBusinessAuditEntry)
	case "OrgOauthAppAccessApprovedAuditEntry":
		base.Value = new(OrgOauthAppAccessApprovedAuditEntry)
	case "OrgOauthAppAccessBlockedAuditEntry":
		base.Value = new(OrgOauthAppAccessBlockedAuditEntry)
	case "OrgOauthAppAccessDeniedAuditEntry":
		base.Value = new(OrgOauthAppAccessDeniedAuditEntry)
	case "OrgOauthAppAccessRequestedAuditEntry":
		base.Value = new(OrgOauthAppAccessRequestedAuditEntry)
	case "OrgOauthAppAccessUnblockedAuditEntry":
		base.Value = new(OrgOauthAppAccessUnblockedAuditEntry)
	case "OrgRemoveBillingManagerAuditEntry":
		base.Value = new(OrgRemoveBillingManagerAuditEntry)
	case "OrgRemoveMemberAuditEntry":
		base.Value = new(OrgRemoveMemberAuditEntry)
	case "OrgRemoveOutsideCollaboratorAuditEntry":
		base.Value = new(OrgRemoveOutsideCollaboratorAuditEntry)
	case "OrgRestoreMemberAuditEntry":
		base.Value = new(OrgRestoreMemberAuditEntry)
	case "OrgUnblockUserAuditEntry":
		base.Value = new(OrgUnblockUserAuditEntry)
	case "OrgUpdateDefaultRepositoryPermissionAuditEntry":
		base.Value = new(OrgUpdateDefaultRepositoryPermissionAuditEntry)
	case "OrgUpdateMemberAuditEntry":
		base.Value = new(OrgUpdateMemberAuditEntry)
	case "OrgUpdateMemberRepositoryCreationPermissionAuditEntry":
		base.Value = new(OrgUpdateMemberRepositoryCreationPermissionAuditEntry)
	case "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry":
		base.Value = new(OrgUpdateMemberRepositoryInvitationPermissionAuditEntry)
	case "Organization":
		base.Value = new(Organization)
	case "OrganizationIdentityProvider":
		base.Value = new(OrganizationIdentityProvider)
	case "OrganizationInvitation":
		base.Value = new(OrganizationInvitation)
	case "OrganizationMigration":
		base.Value = new(OrganizationMigration)
	case "Package":
		base.Value = new(Package)
	case "PackageFile":
		base.Value = new(PackageFile)
	case "PackageTag":
		base.Value = new(PackageTag)
	case "PackageVersion":
		base.Value = new(PackageVersion)
	case "ParentIssueAddedEvent":
		base.Value = new(ParentIssueAddedEvent)
	case "ParentIssueRemovedEvent":
		base.Value = new(ParentIssueRemovedEvent)
	case "PinnedDiscussion":
		base.Value = new(PinnedDiscussion)
	case "PinnedEnvironment":
		base.Value = new(PinnedEnvironment)
	case "PinnedEvent":
		base.Value = new(PinnedEvent)
	case "PinnedIssue":
		base.Value = new(PinnedIssue)
	case "PrivateRepositoryForkingDisableAuditEntry":
		base.Value = new(PrivateRepositoryForkingDisableAuditEntry)
	case "PrivateRepositoryForkingEnableAuditEntry":
		base.Value = new(PrivateRepositoryForkingEnableAuditEntry)
	case "Project":
		base.Value = new(Project)
	case "ProjectCard":
		base.Value = new(ProjectCard)
	case "ProjectColumn":
		base.Value = new(ProjectColumn)
	case "ProjectV2":
		base.Value = new(ProjectV2)
	case "ProjectV2Field":
		base.Value = new(ProjectV2Field)
	case "ProjectV2Item":
		base.Value = new(ProjectV2Item)
	case "ProjectV2ItemFieldDateValue":
		base.Value = new(ProjectV2ItemFieldDateValue)
	case "ProjectV2ItemFieldIterationValue":
		base.Value = new(ProjectV2ItemFieldIterationValue)
	case "ProjectV2ItemFieldNumberValue":
		base.Value = new(ProjectV2ItemFieldNumberValue)
	case "ProjectV2ItemFieldSingleSelectValue":
		base.Value = new(ProjectV2ItemFieldSingleSelectValue)
	case "ProjectV2ItemFieldTextValue":
		base.Value = new(ProjectV2ItemFieldTextValue)
	case "ProjectV2IterationField":
		base.Value = new(ProjectV2IterationField)
	case "ProjectV2SingleSelectField":
		base.Value = new(ProjectV2SingleSelectField)
	case "ProjectV2StatusUpdate":
		base.Value = new(ProjectV2StatusUpdate)
	case "ProjectV2View":
		base.Value = new(ProjectV2View)
	case "ProjectV2Workflow":
		base.Value = new(ProjectV2Workflow)
	case "PublicKey":
		base.Value = new(PublicKey)
	case "PullRequest":
		base.Value = new(PullRequest)
	case "PullRequestCommit":
		base.Value = new(PullRequestCommit)
	case "PullRequestCommitCommentThread":
		base.Value = new(PullRequestCommitCommentThread)
	case "PullRequestReview":
		base.Value = new(PullRequestReview)
	case "PullRequestReviewComment":
		base.Value = new(PullRequestReviewComment)
	case "PullRequestReviewThread":
		base.Value = new(PullRequestReviewThread)
	case "PullRequestThread":
		base.Value = new(PullRequestThread)
	case "Push":
		base.Value = new(Push)
	case "PushAllowance":
		base.Value = new(PushAllowance)
	case "Reaction":
		base.Value = new(Reaction)
	case "ReadyForReviewEvent":
		base.Value = new(ReadyForReviewEvent)
	case "Ref":
		base.Value = new(Ref)
	case "ReferencedEvent":
		base.Value = new(ReferencedEvent)
	case "Release":
		base.Value = new(Release)
	case "ReleaseAsset":
		base.Value = new(ReleaseAsset)
	case "RemovedFromMergeQueueEvent":
		base.Value = new(RemovedFromMergeQueueEvent)
	case "RemovedFromProjectEvent":
		base.Value = new(RemovedFromProjectEvent)
	case "RenamedTitleEvent":
		base.Value = new(RenamedTitleEvent)
	case "ReopenedEvent":
		base.Value = new(ReopenedEvent)
	case "RepoAccessAuditEntry":
		base.Value = new(RepoAccessAuditEntry)
	case "RepoAddMemberAuditEntry":
		base.Value = new(RepoAddMemberAuditEntry)
	case "RepoAddTopicAuditEntry":
		base.Value = new(RepoAddTopicAuditEntry)
	case "RepoArchivedAuditEntry":
		base.Value = new(RepoArchivedAuditEntry)
	case "RepoChangeMergeSettingAuditEntry":
		base.Value = new(RepoChangeMergeSettingAuditEntry)
	case "RepoConfigDisableAnonymousGitAccessAuditEntry":
		base.Value = new(RepoConfigDisableAnonymousGitAccessAuditEntry)
	case "RepoConfigDisableCollaboratorsOnlyAuditEntry":
		base.Value = new(RepoConfigDisableCollaboratorsOnlyAuditEntry)
	case "RepoConfigDisableContributorsOnlyAuditEntry":
		base.Value = new(RepoConfigDisableContributorsOnlyAuditEntry)
	case "RepoConfigDisableSockpuppetDisallowedAuditEntry":
		base.Value = new(RepoConfigDisableSockpuppetDisallowedAuditEntry)
	case "RepoConfigEnableAnonymousGitAccessAuditEntry":
		base.Value = new(RepoConfigEnableAnonymousGitAccessAuditEntry)
	case "RepoConfigEnableCollaboratorsOnlyAuditEntry":
		base.Value = new(RepoConfigEnableCollaboratorsOnlyAuditEntry)
	case "RepoConfigEnableContributorsOnlyAuditEntry":
		base.Value = new(RepoConfigEnableContributorsOnlyAuditEntry)
	case "RepoConfigEnableSockpuppetDisallowedAuditEntry":
		base.Value = new(RepoConfigEnableSockpuppetDisallowedAuditEntry)
	case "RepoConfigLockAnonymousGitAccessAuditEntry":
		base.Value = new(RepoConfigLockAnonymousGitAccessAuditEntry)
	case "RepoConfigUnlockAnonymousGitAccessAuditEntry":
		base.Value = new(RepoConfigUnlockAnonymousGitAccessAuditEntry)
	case "RepoCreateAuditEntry":
		base.Value = new(RepoCreateAuditEntry)
	case "RepoDestroyAuditEntry":
		base.Value = new(RepoDestroyAuditEntry)
	case "RepoRemoveMemberAuditEntry":
		base.Value = new(RepoRemoveMemberAuditEntry)
	case "RepoRemoveTopicAuditEntry":
		base.Value = new(RepoRemoveTopicAuditEntry)
	case "Repository":
		base.Value = new(Repository)
	case "RepositoryInvitation":
		base.Value = new(RepositoryInvitation)
	case "RepositoryMigration":
		base.Value = new(RepositoryMigration)
	case "RepositoryRule":
		base.Value = new(RepositoryRule)
	case "RepositoryRuleset":
		base.Value = new(RepositoryRuleset)
	case "RepositoryRulesetBypassActor":
		base.Value = new(RepositoryRulesetBypassActor)
	case "RepositoryTopic":
		base.Value = new(RepositoryTopic)
	case "RepositoryVisibilityChangeDisableAuditEntry":
		base.Value = new(RepositoryVisibilityChangeDisableAuditEntry)
	case "RepositoryVisibilityChangeEnableAuditEntry":
		base.Value = new(RepositoryVisibilityChangeEnableAuditEntry)
	case "RepositoryVulnerabilityAlert":
		base.Value = new(RepositoryVulnerabilityAlert)
	case "ReviewDismissalAllowance":
		base.Value = new(ReviewDismissalAllowance)
	case "ReviewDismissedEvent":
		base.Value = new(ReviewDismissedEvent)
	case "ReviewRequest":
		base.Value = new(ReviewRequest)
	case "ReviewRequestRemovedEvent":
		base.Value = new(ReviewRequestRemovedEvent)
	case "ReviewRequestedEvent":
		base.Value = new(ReviewRequestedEvent)
	case "SavedReply":
		base.Value = new(SavedReply)
	case "SecurityAdvisory":
		base.Value = new(SecurityAdvisory)
	case "SponsorsActivity":
		base.Value = new(SponsorsActivity)
	case "SponsorsListing":
		base.Value = new(SponsorsListing)
	case "SponsorsListingFeaturedItem":
		base.Value = new(SponsorsListingFeaturedItem)
	case "SponsorsTier":
		base.Value = new(SponsorsTier)
	case "Sponsorship":
		base.Value = new(Sponsorship)
	case "SponsorshipNewsletter":
		base.Value = new(SponsorshipNewsletter)
	case "Status":
		base.Value = new(Status)
	case "StatusCheckRollup":
		base.Value = new(StatusCheckRollup)
	case "StatusContext":
		base.Value = new(StatusContext)
	case "SubIssueAddedEvent":
		base.Value = new(SubIssueAddedEvent)
	case "SubIssueRemovedEvent":
		base.Value = new(SubIssueRemovedEvent)
	case "SubscribedEvent":
		base.Value = new(SubscribedEvent)
	case "Tag":
		base.Value = new(Tag)
	case "Team":
		base.Value = new(Team)
	case "TeamAddMemberAuditEntry":
		base.Value = new(TeamAddMemberAuditEntry)
	case "TeamAddRepositoryAuditEntry":
		base.Value = new(TeamAddRepositoryAuditEntry)
	case "TeamChangeParentTeamAuditEntry":
		base.Value = new(TeamChangeParentTeamAuditEntry)
	case "TeamDiscussion":
		base.Value = new(TeamDiscussion)
	case "TeamDiscussionComment":
		base.Value = new(TeamDiscussionComment)
	case "TeamRemoveMemberAuditEntry":
		base.Value = new(TeamRemoveMemberAuditEntry)
	case "TeamRemoveRepositoryAuditEntry":
		base.Value = new(TeamRemoveRepositoryAuditEntry)
	case "Topic":
		base.Value = new(Topic)
	case "TransferredEvent":
		base.Value = new(TransferredEvent)
	case "Tree":
		base.Value = new(Tree)
	case "UnassignedEvent":
		base.Value = new(UnassignedEvent)
	case "UnlabeledEvent":
		base.Value = new(UnlabeledEvent)
	case "UnlockedEvent":
		base.Value = new(UnlockedEvent)
	case "UnmarkedAsDuplicateEvent":
		base.Value = new(UnmarkedAsDuplicateEvent)
	case "UnpinnedEvent":
		base.Value = new(UnpinnedEvent)
	case "UnsubscribedEvent":
		base.Value = new(UnsubscribedEvent)
	case "User":
		base.Value = new(User)
	case "UserBlockedEvent":
		base.Value = new(UserBlockedEvent)
	case "UserContentEdit":
		base.Value = new(UserContentEdit)
	case "UserList":
		base.Value = new(UserList)
	case "UserNamespaceRepository":
		base.Value = new(UserNamespaceRepository)
	case "UserStatus":
		base.Value = new(UserStatus)
	case "VerifiableDomain":
		base.Value = new(VerifiableDomain)
	case "Workflow":
		base.Value = new(Workflow)
	case "WorkflowRun":
		base.Value = new(WorkflowRun)
	case "WorkflowRunFile":
		base.Value = new(WorkflowRunFile)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface Node: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// NodeValue is one of: AddedToMergeQueueEvent | AddedToProjectEvent | App | AssignedEvent | AutoMergeDisabledEvent | AutoMergeEnabledEvent | AutoRebaseEnabledEvent | AutoSquashEnabledEvent | AutomaticBaseChangeFailedEvent | AutomaticBaseChangeSucceededEvent | BaseRefChangedEvent | BaseRefDeletedEvent | BaseRefForcePushedEvent | Blob | Bot | BranchProtectionRule | BypassForcePushAllowance | BypassPullRequestAllowance | CWE | CheckRun | CheckSuite | ClosedEvent | CodeOfConduct | CommentDeletedEvent | Commit | CommitComment | CommitCommentThread | Comparison | ConnectedEvent | ConvertToDraftEvent | ConvertedNoteToIssueEvent | ConvertedToDiscussionEvent | CrossReferencedEvent | DemilestonedEvent | DependencyGraphManifest | DeployKey | DeployedEvent | Deployment | DeploymentEnvironmentChangedEvent | DeploymentReview | DeploymentStatus | DisconnectedEvent | Discussion | DiscussionCategory | DiscussionComment | DiscussionPoll | DiscussionPollOption | DraftIssue | Enterprise | EnterpriseAdministratorInvitation | EnterpriseIdentityProvider | EnterpriseMemberInvitation | EnterpriseRepositoryInfo | EnterpriseServerInstallation | EnterpriseServerUserAccount | EnterpriseServerUserAccountEmail | EnterpriseServerUserAccountsUpload | EnterpriseUserAccount | Environment | ExternalIdentity | Gist | GistComment | HeadRefDeletedEvent | HeadRefForcePushedEvent | HeadRefRestoredEvent | IpAllowListEntry | Issue | IssueComment | IssueType | IssueTypeAddedEvent | IssueTypeChangedEvent | IssueTypeRemovedEvent | Label | LabeledEvent | Language | License | LinkedBranch | LockedEvent | Mannequin | MarkedAsDuplicateEvent | MarketplaceCategory | MarketplaceListing | MemberFeatureRequestNotification | MembersCanDeleteReposClearAuditEntry | MembersCanDeleteReposDisableAuditEntry | MembersCanDeleteReposEnableAuditEntry | MentionedEvent | MergeQueue | MergeQueueEntry | MergedEvent | MigrationSource | Milestone | MilestonedEvent | MovedColumnsInProjectEvent | OIDCProvider | OauthApplicationCreateAuditEntry | OrgAddBillingManagerAuditEntry | OrgAddMemberAuditEntry | OrgBlockUserAuditEntry | OrgConfigDisableCollaboratorsOnlyAuditEntry | OrgConfigEnableCollaboratorsOnlyAuditEntry | OrgCreateAuditEntry | OrgDisableOauthAppRestrictionsAuditEntry | OrgDisableSamlAuditEntry | OrgDisableTwoFactorRequirementAuditEntry | OrgEnableOauthAppRestrictionsAuditEntry | OrgEnableSamlAuditEntry | OrgEnableTwoFactorRequirementAuditEntry | OrgInviteMemberAuditEntry | OrgInviteToBusinessAuditEntry | OrgOauthAppAccessApprovedAuditEntry | OrgOauthAppAccessBlockedAuditEntry | OrgOauthAppAccessDeniedAuditEntry | OrgOauthAppAccessRequestedAuditEntry | OrgOauthAppAccessUnblockedAuditEntry | OrgRemoveBillingManagerAuditEntry | OrgRemoveMemberAuditEntry | OrgRemoveOutsideCollaboratorAuditEntry | OrgRestoreMemberAuditEntry | OrgUnblockUserAuditEntry | OrgUpdateDefaultRepositoryPermissionAuditEntry | OrgUpdateMemberAuditEntry | OrgUpdateMemberRepositoryCreationPermissionAuditEntry | OrgUpdateMemberRepositoryInvitationPermissionAuditEntry | Organization | OrganizationIdentityProvider | OrganizationInvitation | OrganizationMigration | Package | PackageFile | PackageTag | PackageVersion | ParentIssueAddedEvent | ParentIssueRemovedEvent | PinnedDiscussion | PinnedEnvironment | PinnedEvent | PinnedIssue | PrivateRepositoryForkingDisableAuditEntry | PrivateRepositoryForkingEnableAuditEntry | Project | ProjectCard | ProjectColumn | ProjectV2 | ProjectV2Field | ProjectV2Item | ProjectV2ItemFieldDateValue | ProjectV2ItemFieldIterationValue | ProjectV2ItemFieldNumberValue | ProjectV2ItemFieldSingleSelectValue | ProjectV2ItemFieldTextValue | ProjectV2IterationField | ProjectV2SingleSelectField | ProjectV2StatusUpdate | ProjectV2View | ProjectV2Workflow | PublicKey | PullRequest | PullRequestCommit | PullRequestCommitCommentThread | PullRequestReview | PullRequestReviewComment | PullRequestReviewThread | PullRequestThread | Push | PushAllowance | Reaction | ReadyForReviewEvent | Ref | ReferencedEvent | Release | ReleaseAsset | RemovedFromMergeQueueEvent | RemovedFromProjectEvent | RenamedTitleEvent | ReopenedEvent | RepoAccessAuditEntry | RepoAddMemberAuditEntry | RepoAddTopicAuditEntry | RepoArchivedAuditEntry | RepoChangeMergeSettingAuditEntry | RepoConfigDisableAnonymousGitAccessAuditEntry | RepoConfigDisableCollaboratorsOnlyAuditEntry | RepoConfigDisableContributorsOnlyAuditEntry | RepoConfigDisableSockpuppetDisallowedAuditEntry | RepoConfigEnableAnonymousGitAccessAuditEntry | RepoConfigEnableCollaboratorsOnlyAuditEntry | RepoConfigEnableContributorsOnlyAuditEntry | RepoConfigEnableSockpuppetDisallowedAuditEntry | RepoConfigLockAnonymousGitAccessAuditEntry | RepoConfigUnlockAnonymousGitAccessAuditEntry | RepoCreateAuditEntry | RepoDestroyAuditEntry | RepoRemoveMemberAuditEntry | RepoRemoveTopicAuditEntry | Repository | RepositoryInvitation | RepositoryMigration | RepositoryRule | RepositoryRuleset | RepositoryRulesetBypassActor | RepositoryTopic | RepositoryVisibilityChangeDisableAuditEntry | RepositoryVisibilityChangeEnableAuditEntry | RepositoryVulnerabilityAlert | ReviewDismissalAllowance | ReviewDismissedEvent | ReviewRequest | ReviewRequestRemovedEvent | ReviewRequestedEvent | SavedReply | SecurityAdvisory | SponsorsActivity | SponsorsListing | SponsorsListingFeaturedItem | SponsorsTier | Sponsorship | SponsorshipNewsletter | Status | StatusCheckRollup | StatusContext | SubIssueAddedEvent | SubIssueRemovedEvent | SubscribedEvent | Tag | Team | TeamAddMemberAuditEntry | TeamAddRepositoryAuditEntry | TeamChangeParentTeamAuditEntry | TeamDiscussion | TeamDiscussionComment | TeamRemoveMemberAuditEntry | TeamRemoveRepositoryAuditEntry | Topic | TransferredEvent | Tree | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnmarkedAsDuplicateEvent | UnpinnedEvent | UnsubscribedEvent | User | UserBlockedEvent | UserContentEdit | UserList | UserNamespaceRepository | UserStatus | VerifiableDomain | Workflow | WorkflowRun | WorkflowRunFile
type NodeValue interface {
	isNode()
}

// The possible values for the notification restriction setting.
type NotificationRestrictionSettingValue string

const (
	// The setting is disabled for the owner.
	NotificationRestrictionSettingValueDisabled NotificationRestrictionSettingValue = "DISABLED"
	// The setting is enabled for the owner.
	NotificationRestrictionSettingValueEnabled NotificationRestrictionSettingValue = "ENABLED"
)

// An OIDC identity provider configured to provision identities for an enterprise.
// Visible to enterprise owners or enterprise owners' personal access tokens
// (classic) with read:enterprise or admin:enterprise scope.
type OIDCProvider struct {
	// The enterprise this identity provider belongs to.
	Enterprise *Enterprise `json:"enterprise,omitempty"`
	// ExternalIdentities provisioned by this identity provider.
	ExternalIdentities *ExternalIdentityConnection `json:"externalIdentities"`
	// The Node ID of the OIDCProvider object
	Id string `json:"id"`
	// The OIDC identity provider type
	ProviderType OIDCProviderType `json:"providerType"`
	// The id of the tenant this provider is attached to
	TenantId string `json:"tenantId"`
}

func (*OIDCProvider) isNode() {}

// The OIDC identity provider type
type OIDCProviderType string

const (
	// Azure Active Directory
	OIDCProviderTypeAad OIDCProviderType = "AAD"
)

// Metadata for an audit entry with action oauth_application.*
type OauthApplicationAuditEntryData struct {
	// The name of the OAuth application.
	OauthApplicationName *string `json:"oauthApplicationName,omitempty"`
	// The HTTP path for the OAuth application
	OauthApplicationResourcePath *URI `json:"oauthApplicationResourcePath,omitempty"`
	// The HTTP URL for the OAuth application
	OauthApplicationUrl *URI `json:"oauthApplicationUrl,omitempty"`

	// Underlying value of the GraphQL interface
	Value OauthApplicationAuditEntryDataValue `json:"-"`
}

func (base *OauthApplicationAuditEntryData) UnmarshalJSON(b []byte) error {
	type Raw OauthApplicationAuditEntryData
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "OauthApplicationCreateAuditEntry":
		base.Value = new(OauthApplicationCreateAuditEntry)
	case "OrgOauthAppAccessApprovedAuditEntry":
		base.Value = new(OrgOauthAppAccessApprovedAuditEntry)
	case "OrgOauthAppAccessBlockedAuditEntry":
		base.Value = new(OrgOauthAppAccessBlockedAuditEntry)
	case "OrgOauthAppAccessDeniedAuditEntry":
		base.Value = new(OrgOauthAppAccessDeniedAuditEntry)
	case "OrgOauthAppAccessRequestedAuditEntry":
		base.Value = new(OrgOauthAppAccessRequestedAuditEntry)
	case "OrgOauthAppAccessUnblockedAuditEntry":
		base.Value = new(OrgOauthAppAccessUnblockedAuditEntry)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface OauthApplicationAuditEntryData: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// OauthApplicationAuditEntryDataValue is one of: OauthApplicationCreateAuditEntry | OrgOauthAppAccessApprovedAuditEntry | OrgOauthAppAccessBlockedAuditEntry | OrgOauthAppAccessDeniedAuditEntry | OrgOauthAppAccessRequestedAuditEntry | OrgOauthAppAccessUnblockedAuditEntry
type OauthApplicationAuditEntryDataValue interface {
	isOauthApplicationAuditEntryData()
}

// Audit log entry for a oauth_application.create event.
type OauthApplicationCreateAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The application URL of the OAuth application.
	ApplicationUrl *URI `json:"applicationUrl,omitempty"`
	// The callback URL of the OAuth application.
	CallbackUrl *URI `json:"callbackUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the OauthApplicationCreateAuditEntry object
	Id string `json:"id"`
	// The name of the OAuth application.
	OauthApplicationName *string `json:"oauthApplicationName,omitempty"`
	// The HTTP path for the OAuth application
	OauthApplicationResourcePath *URI `json:"oauthApplicationResourcePath,omitempty"`
	// The HTTP URL for the OAuth application
	OauthApplicationUrl *URI `json:"oauthApplicationUrl,omitempty"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The rate limit of the OAuth application.
	RateLimit *int32 `json:"rateLimit,omitempty"`
	// The state of the OAuth application.
	State *OauthApplicationCreateAuditEntryState `json:"state,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*OauthApplicationCreateAuditEntry) isAuditEntry() {}

func (*OauthApplicationCreateAuditEntry) isNode() {}

func (*OauthApplicationCreateAuditEntry) isOauthApplicationAuditEntryData() {}

func (*OauthApplicationCreateAuditEntry) isOrganizationAuditEntryData() {}

func (*OauthApplicationCreateAuditEntry) isOrganizationAuditEntry() {}

// The state of an OAuth application when it was created.
type OauthApplicationCreateAuditEntryState string

const (
	// The OAuth application was active and allowed to have OAuth Accesses.
	OauthApplicationCreateAuditEntryStateActive OauthApplicationCreateAuditEntryState = "ACTIVE"
	// The OAuth application was in the process of being deleted.
	OauthApplicationCreateAuditEntryStatePendingDeletion OauthApplicationCreateAuditEntryState = "PENDING_DELETION"
	// The OAuth application was suspended from generating OAuth Accesses due to abuse or security concerns.
	OauthApplicationCreateAuditEntryStateSuspended OauthApplicationCreateAuditEntryState = "SUSPENDED"
)

// The corresponding operation type for the action
type OperationType string

const (
	// An existing resource was accessed
	OperationTypeAccess OperationType = "ACCESS"
	// A resource performed an authentication event
	OperationTypeAuthentication OperationType = "AUTHENTICATION"
	// A new resource was created
	OperationTypeCreate OperationType = "CREATE"
	// An existing resource was modified
	OperationTypeModify OperationType = "MODIFY"
	// An existing resource was removed
	OperationTypeRemove OperationType = "REMOVE"
	// An existing resource was restored
	OperationTypeRestore OperationType = "RESTORE"
	// An existing resource was transferred between multiple resources
	OperationTypeTransfer OperationType = "TRANSFER"
)

// Possible directions in which to order a list of items when provided an `orderBy` argument.
type OrderDirection string

const (
	// Specifies an ascending order for a given `orderBy` argument.
	OrderDirectionAsc OrderDirection = "ASC"
	// Specifies a descending order for a given `orderBy` argument.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Audit log entry for a org.add_billing_manager
type OrgAddBillingManagerAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the OrgAddBillingManagerAuditEntry object
	Id string `json:"id"`
	// The email address used to invite a billing manager for the organization.
	InvitationEmail *string `json:"invitationEmail,omitempty"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*OrgAddBillingManagerAuditEntry) isAuditEntry() {}

func (*OrgAddBillingManagerAuditEntry) isNode() {}

func (*OrgAddBillingManagerAuditEntry) isOrganizationAuditEntryData() {}

func (*OrgAddBillingManagerAuditEntry) isOrganizationAuditEntry() {}

// Audit log entry for a org.add_member
type OrgAddMemberAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the OrgAddMemberAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The permission level of the member added to the organization.
	Permission *OrgAddMemberAuditEntryPermission `json:"permission,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*OrgAddMemberAuditEntry) isAuditEntry() {}

func (*OrgAddMemberAuditEntry) isNode() {}

func (*OrgAddMemberAuditEntry) isOrganizationAuditEntryData() {}

func (*OrgAddMemberAuditEntry) isOrganizationAuditEntry() {}

// The permissions available to members on an Organization.
type OrgAddMemberAuditEntryPermission string

const (
	// Can read, clone, push, and add collaborators to repositories.
	OrgAddMemberAuditEntryPermissionAdmin OrgAddMemberAuditEntryPermission = "ADMIN"
	// Can read and clone repositories.
	OrgAddMemberAuditEntryPermissionRead OrgAddMemberAuditEntryPermission = "READ"
)

// Audit log entry for a org.block_user
type OrgBlockUserAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The blocked user.
	BlockedUser *User `json:"blockedUser,omitempty"`
	// The username of the blocked user.
	BlockedUserName *string `json:"blockedUserName,omitempty"`
	// The HTTP path for the blocked user.
	BlockedUserResourcePath *URI `json:"blockedUserResourcePath,omitempty"`
	// The HTTP URL for the blocked user.
	BlockedUserUrl *URI `json:"blockedUserUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the OrgBlockUserAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*OrgBlockUserAuditEntry) isAuditEntry() {}

func (*OrgBlockUserAuditEntry) isNode() {}

func (*OrgBlockUserAuditEntry) isOrganizationAuditEntryData() {}

func (*OrgBlockUserAuditEntry) isOrganizationAuditEntry() {}

// Audit log entry for a org.config.disable_collaborators_only event.
type OrgConfigDisableCollaboratorsOnlyAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the OrgConfigDisableCollaboratorsOnlyAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*OrgConfigDisableCollaboratorsOnlyAuditEntry) isAuditEntry() {}

func (*OrgConfigDisableCollaboratorsOnlyAuditEntry) isNode() {}

func (*OrgConfigDisableCollaboratorsOnlyAuditEntry) isOrganizationAuditEntryData() {}

func (*OrgConfigDisableCollaboratorsOnlyAuditEntry) isOrganizationAuditEntry() {}

// Audit log entry for a org.config.enable_collaborators_only event.
type OrgConfigEnableCollaboratorsOnlyAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the OrgConfigEnableCollaboratorsOnlyAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*OrgConfigEnableCollaboratorsOnlyAuditEntry) isAuditEntry() {}

func (*OrgConfigEnableCollaboratorsOnlyAuditEntry) isNode() {}

func (*OrgConfigEnableCollaboratorsOnlyAuditEntry) isOrganizationAuditEntryData() {}

func (*OrgConfigEnableCollaboratorsOnlyAuditEntry) isOrganizationAuditEntry() {}

// Audit log entry for a org.create event.
type OrgCreateAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The billing plan for the Organization.
	BillingPlan *OrgCreateAuditEntryBillingPlan `json:"billingPlan,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the OrgCreateAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*OrgCreateAuditEntry) isAuditEntry() {}

func (*OrgCreateAuditEntry) isNode() {}

func (*OrgCreateAuditEntry) isOrganizationAuditEntryData() {}

func (*OrgCreateAuditEntry) isOrganizationAuditEntry() {}

// The billing plans available for organizations.
type OrgCreateAuditEntryBillingPlan string

const (
	// Team Plan
	OrgCreateAuditEntryBillingPlanBusiness OrgCreateAuditEntryBillingPlan = "BUSINESS"
	// Enterprise Cloud Plan
	OrgCreateAuditEntryBillingPlanBusinessPlus OrgCreateAuditEntryBillingPlan = "BUSINESS_PLUS"
	// Free Plan
	OrgCreateAuditEntryBillingPlanFree OrgCreateAuditEntryBillingPlan = "FREE"
	// Tiered Per Seat Plan
	OrgCreateAuditEntryBillingPlanTieredPerSeat OrgCreateAuditEntryBillingPlan = "TIERED_PER_SEAT"
	// Legacy Unlimited Plan
	OrgCreateAuditEntryBillingPlanUnlimited OrgCreateAuditEntryBillingPlan = "UNLIMITED"
)

// Audit log entry for a org.disable_oauth_app_restrictions event.
type OrgDisableOauthAppRestrictionsAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the OrgDisableOauthAppRestrictionsAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*OrgDisableOauthAppRestrictionsAuditEntry) isAuditEntry() {}

func (*OrgDisableOauthAppRestrictionsAuditEntry) isNode() {}

func (*OrgDisableOauthAppRestrictionsAuditEntry) isOrganizationAuditEntryData() {}

func (*OrgDisableOauthAppRestrictionsAuditEntry) isOrganizationAuditEntry() {}

// Audit log entry for a org.disable_saml event.
type OrgDisableSamlAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The SAML provider's digest algorithm URL.
	DigestMethodUrl *URI `json:"digestMethodUrl,omitempty"`
	// The Node ID of the OrgDisableSamlAuditEntry object
	Id string `json:"id"`
	// The SAML provider's issuer URL.
	IssuerUrl *URI `json:"issuerUrl,omitempty"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The SAML provider's signature algorithm URL.
	SignatureMethodUrl *URI `json:"signatureMethodUrl,omitempty"`
	// The SAML provider's single sign-on URL.
	SingleSignOnUrl *URI `json:"singleSignOnUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*OrgDisableSamlAuditEntry) isAuditEntry() {}

func (*OrgDisableSamlAuditEntry) isNode() {}

func (*OrgDisableSamlAuditEntry) isOrganizationAuditEntryData() {}

func (*OrgDisableSamlAuditEntry) isOrganizationAuditEntry() {}

// Audit log entry for a org.disable_two_factor_requirement event.
type OrgDisableTwoFactorRequirementAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the OrgDisableTwoFactorRequirementAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*OrgDisableTwoFactorRequirementAuditEntry) isAuditEntry() {}

func (*OrgDisableTwoFactorRequirementAuditEntry) isNode() {}

func (*OrgDisableTwoFactorRequirementAuditEntry) isOrganizationAuditEntryData() {}

func (*OrgDisableTwoFactorRequirementAuditEntry) isOrganizationAuditEntry() {}

// Audit log entry for a org.enable_oauth_app_restrictions event.
type OrgEnableOauthAppRestrictionsAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the OrgEnableOauthAppRestrictionsAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*OrgEnableOauthAppRestrictionsAuditEntry) isAuditEntry() {}

func (*OrgEnableOauthAppRestrictionsAuditEntry) isNode() {}

func (*OrgEnableOauthAppRestrictionsAuditEntry) isOrganizationAuditEntryData() {}

func (*OrgEnableOauthAppRestrictionsAuditEntry) isOrganizationAuditEntry() {}

// Audit log entry for a org.enable_saml event.
type OrgEnableSamlAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The SAML provider's digest algorithm URL.
	DigestMethodUrl *URI `json:"digestMethodUrl,omitempty"`
	// The Node ID of the OrgEnableSamlAuditEntry object
	Id string `json:"id"`
	// The SAML provider's issuer URL.
	IssuerUrl *URI `json:"issuerUrl,omitempty"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The SAML provider's signature algorithm URL.
	SignatureMethodUrl *URI `json:"signatureMethodUrl,omitempty"`
	// The SAML provider's single sign-on URL.
	SingleSignOnUrl *URI `json:"singleSignOnUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*OrgEnableSamlAuditEntry) isAuditEntry() {}

func (*OrgEnableSamlAuditEntry) isNode() {}

func (*OrgEnableSamlAuditEntry) isOrganizationAuditEntryData() {}

func (*OrgEnableSamlAuditEntry) isOrganizationAuditEntry() {}

// Audit log entry for a org.enable_two_factor_requirement event.
type OrgEnableTwoFactorRequirementAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the OrgEnableTwoFactorRequirementAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*OrgEnableTwoFactorRequirementAuditEntry) isAuditEntry() {}

func (*OrgEnableTwoFactorRequirementAuditEntry) isNode() {}

func (*OrgEnableTwoFactorRequirementAuditEntry) isOrganizationAuditEntryData() {}

func (*OrgEnableTwoFactorRequirementAuditEntry) isOrganizationAuditEntry() {}

// Ordering options for an organization's enterprise owner connections.
type OrgEnterpriseOwnerOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order enterprise owners by.
	Field OrgEnterpriseOwnerOrderField `json:"field"`
}

// Properties by which enterprise owners can be ordered.
type OrgEnterpriseOwnerOrderField string

const (
	// Order enterprise owners by login.
	OrgEnterpriseOwnerOrderFieldLogin OrgEnterpriseOwnerOrderField = "LOGIN"
)

// Audit log entry for a org.invite_member event.
type OrgInviteMemberAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The email address of the organization invitation.
	Email *string `json:"email,omitempty"`
	// The Node ID of the OrgInviteMemberAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The organization invitation.
	OrganizationInvitation *OrganizationInvitation `json:"organizationInvitation,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*OrgInviteMemberAuditEntry) isAuditEntry() {}

func (*OrgInviteMemberAuditEntry) isNode() {}

func (*OrgInviteMemberAuditEntry) isOrganizationAuditEntryData() {}

func (*OrgInviteMemberAuditEntry) isOrganizationAuditEntry() {}

// Audit log entry for a org.invite_to_business event.
type OrgInviteToBusinessAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The HTTP path for this enterprise.
	EnterpriseResourcePath *URI `json:"enterpriseResourcePath,omitempty"`
	// The slug of the enterprise.
	EnterpriseSlug *string `json:"enterpriseSlug,omitempty"`
	// The HTTP URL for this enterprise.
	EnterpriseUrl *URI `json:"enterpriseUrl,omitempty"`
	// The Node ID of the OrgInviteToBusinessAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*OrgInviteToBusinessAuditEntry) isAuditEntry() {}

func (*OrgInviteToBusinessAuditEntry) isEnterpriseAuditEntryData() {}

func (*OrgInviteToBusinessAuditEntry) isNode() {}

func (*OrgInviteToBusinessAuditEntry) isOrganizationAuditEntryData() {}

func (*OrgInviteToBusinessAuditEntry) isOrganizationAuditEntry() {}

// Audit log entry for a org.oauth_app_access_approved event.
type OrgOauthAppAccessApprovedAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the OrgOauthAppAccessApprovedAuditEntry object
	Id string `json:"id"`
	// The name of the OAuth application.
	OauthApplicationName *string `json:"oauthApplicationName,omitempty"`
	// The HTTP path for the OAuth application
	OauthApplicationResourcePath *URI `json:"oauthApplicationResourcePath,omitempty"`
	// The HTTP URL for the OAuth application
	OauthApplicationUrl *URI `json:"oauthApplicationUrl,omitempty"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*OrgOauthAppAccessApprovedAuditEntry) isAuditEntry() {}

func (*OrgOauthAppAccessApprovedAuditEntry) isNode() {}

func (*OrgOauthAppAccessApprovedAuditEntry) isOauthApplicationAuditEntryData() {}

func (*OrgOauthAppAccessApprovedAuditEntry) isOrganizationAuditEntryData() {}

func (*OrgOauthAppAccessApprovedAuditEntry) isOrganizationAuditEntry() {}

// Audit log entry for a org.oauth_app_access_blocked event.
type OrgOauthAppAccessBlockedAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the OrgOauthAppAccessBlockedAuditEntry object
	Id string `json:"id"`
	// The name of the OAuth application.
	OauthApplicationName *string `json:"oauthApplicationName,omitempty"`
	// The HTTP path for the OAuth application
	OauthApplicationResourcePath *URI `json:"oauthApplicationResourcePath,omitempty"`
	// The HTTP URL for the OAuth application
	OauthApplicationUrl *URI `json:"oauthApplicationUrl,omitempty"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*OrgOauthAppAccessBlockedAuditEntry) isAuditEntry() {}

func (*OrgOauthAppAccessBlockedAuditEntry) isNode() {}

func (*OrgOauthAppAccessBlockedAuditEntry) isOauthApplicationAuditEntryData() {}

func (*OrgOauthAppAccessBlockedAuditEntry) isOrganizationAuditEntryData() {}

func (*OrgOauthAppAccessBlockedAuditEntry) isOrganizationAuditEntry() {}

// Audit log entry for a org.oauth_app_access_denied event.
type OrgOauthAppAccessDeniedAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the OrgOauthAppAccessDeniedAuditEntry object
	Id string `json:"id"`
	// The name of the OAuth application.
	OauthApplicationName *string `json:"oauthApplicationName,omitempty"`
	// The HTTP path for the OAuth application
	OauthApplicationResourcePath *URI `json:"oauthApplicationResourcePath,omitempty"`
	// The HTTP URL for the OAuth application
	OauthApplicationUrl *URI `json:"oauthApplicationUrl,omitempty"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*OrgOauthAppAccessDeniedAuditEntry) isAuditEntry() {}

func (*OrgOauthAppAccessDeniedAuditEntry) isNode() {}

func (*OrgOauthAppAccessDeniedAuditEntry) isOauthApplicationAuditEntryData() {}

func (*OrgOauthAppAccessDeniedAuditEntry) isOrganizationAuditEntryData() {}

func (*OrgOauthAppAccessDeniedAuditEntry) isOrganizationAuditEntry() {}

// Audit log entry for a org.oauth_app_access_requested event.
type OrgOauthAppAccessRequestedAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the OrgOauthAppAccessRequestedAuditEntry object
	Id string `json:"id"`
	// The name of the OAuth application.
	OauthApplicationName *string `json:"oauthApplicationName,omitempty"`
	// The HTTP path for the OAuth application
	OauthApplicationResourcePath *URI `json:"oauthApplicationResourcePath,omitempty"`
	// The HTTP URL for the OAuth application
	OauthApplicationUrl *URI `json:"oauthApplicationUrl,omitempty"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*OrgOauthAppAccessRequestedAuditEntry) isAuditEntry() {}

func (*OrgOauthAppAccessRequestedAuditEntry) isNode() {}

func (*OrgOauthAppAccessRequestedAuditEntry) isOauthApplicationAuditEntryData() {}

func (*OrgOauthAppAccessRequestedAuditEntry) isOrganizationAuditEntryData() {}

func (*OrgOauthAppAccessRequestedAuditEntry) isOrganizationAuditEntry() {}

// Audit log entry for a org.oauth_app_access_unblocked event.
type OrgOauthAppAccessUnblockedAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the OrgOauthAppAccessUnblockedAuditEntry object
	Id string `json:"id"`
	// The name of the OAuth application.
	OauthApplicationName *string `json:"oauthApplicationName,omitempty"`
	// The HTTP path for the OAuth application
	OauthApplicationResourcePath *URI `json:"oauthApplicationResourcePath,omitempty"`
	// The HTTP URL for the OAuth application
	OauthApplicationUrl *URI `json:"oauthApplicationUrl,omitempty"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*OrgOauthAppAccessUnblockedAuditEntry) isAuditEntry() {}

func (*OrgOauthAppAccessUnblockedAuditEntry) isNode() {}

func (*OrgOauthAppAccessUnblockedAuditEntry) isOauthApplicationAuditEntryData() {}

func (*OrgOauthAppAccessUnblockedAuditEntry) isOrganizationAuditEntryData() {}

func (*OrgOauthAppAccessUnblockedAuditEntry) isOrganizationAuditEntry() {}

// Audit log entry for a org.remove_billing_manager event.
type OrgRemoveBillingManagerAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the OrgRemoveBillingManagerAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The reason for the billing manager being removed.
	Reason *OrgRemoveBillingManagerAuditEntryReason `json:"reason,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*OrgRemoveBillingManagerAuditEntry) isAuditEntry() {}

func (*OrgRemoveBillingManagerAuditEntry) isNode() {}

func (*OrgRemoveBillingManagerAuditEntry) isOrganizationAuditEntryData() {}

func (*OrgRemoveBillingManagerAuditEntry) isOrganizationAuditEntry() {}

// The reason a billing manager was removed from an Organization.
type OrgRemoveBillingManagerAuditEntryReason string

const (
	// SAML external identity missing
	OrgRemoveBillingManagerAuditEntryReasonSamlExternalIdentityMissing OrgRemoveBillingManagerAuditEntryReason = "SAML_EXTERNAL_IDENTITY_MISSING"
	// SAML SSO enforcement requires an external identity
	OrgRemoveBillingManagerAuditEntryReasonSamlSsoEnforcementRequiresExternalIdentity OrgRemoveBillingManagerAuditEntryReason = "SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY"
	// The organization required 2FA of its billing managers and this user did not have 2FA enabled.
	OrgRemoveBillingManagerAuditEntryReasonTwoFactorRequirementNonCompliance OrgRemoveBillingManagerAuditEntryReason = "TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE"
)

// Audit log entry for a org.remove_member event.
type OrgRemoveMemberAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the OrgRemoveMemberAuditEntry object
	Id string `json:"id"`
	// The types of membership the member has with the organization.
	MembershipTypes []OrgRemoveMemberAuditEntryMembershipType `json:"membershipTypes,omitempty"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The reason for the member being removed.
	Reason *OrgRemoveMemberAuditEntryReason `json:"reason,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*OrgRemoveMemberAuditEntry) isAuditEntry() {}

func (*OrgRemoveMemberAuditEntry) isNode() {}

func (*OrgRemoveMemberAuditEntry) isOrganizationAuditEntryData() {}

func (*OrgRemoveMemberAuditEntry) isOrganizationAuditEntry() {}

// The type of membership a user has with an Organization.
type OrgRemoveMemberAuditEntryMembershipType string

const (
	// Organization owners have full access and can change several settings,
	// including the names of repositories that belong to the Organization and Owners
	// team membership. In addition, organization owners can delete the organization
	// and all of its repositories.
	OrgRemoveMemberAuditEntryMembershipTypeAdmin OrgRemoveMemberAuditEntryMembershipType = "ADMIN"
	// A billing manager is a user who manages the billing settings for the Organization, such as updating payment information.
	OrgRemoveMemberAuditEntryMembershipTypeBillingManager OrgRemoveMemberAuditEntryMembershipType = "BILLING_MANAGER"
	// A direct member is a user that is a member of the Organization.
	OrgRemoveMemberAuditEntryMembershipTypeDirectMember OrgRemoveMemberAuditEntryMembershipType = "DIRECT_MEMBER"
	// An outside collaborator is a person who isn't explicitly a member of the
	// Organization, but who has Read, Write, or Admin permissions to one or more
	// repositories in the organization.
	OrgRemoveMemberAuditEntryMembershipTypeOutsideCollaborator OrgRemoveMemberAuditEntryMembershipType = "OUTSIDE_COLLABORATOR"
	// A suspended member.
	OrgRemoveMemberAuditEntryMembershipTypeSuspended OrgRemoveMemberAuditEntryMembershipType = "SUSPENDED"
	// An unaffiliated collaborator is a person who is not a member of the
	// Organization and does not have access to any repositories in the Organization.
	OrgRemoveMemberAuditEntryMembershipTypeUnaffiliated OrgRemoveMemberAuditEntryMembershipType = "UNAFFILIATED"
)

// The reason a member was removed from an Organization.
type OrgRemoveMemberAuditEntryReason string

const (
	// SAML external identity missing
	OrgRemoveMemberAuditEntryReasonSamlExternalIdentityMissing OrgRemoveMemberAuditEntryReason = "SAML_EXTERNAL_IDENTITY_MISSING"
	// SAML SSO enforcement requires an external identity
	OrgRemoveMemberAuditEntryReasonSamlSsoEnforcementRequiresExternalIdentity OrgRemoveMemberAuditEntryReason = "SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY"
	// User was removed from organization during account recovery
	OrgRemoveMemberAuditEntryReasonTwoFactorAccountRecovery OrgRemoveMemberAuditEntryReason = "TWO_FACTOR_ACCOUNT_RECOVERY"
	// The organization required 2FA of its billing managers and this user did not have 2FA enabled.
	OrgRemoveMemberAuditEntryReasonTwoFactorRequirementNonCompliance OrgRemoveMemberAuditEntryReason = "TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE"
	// User account has been deleted
	OrgRemoveMemberAuditEntryReasonUserAccountDeleted OrgRemoveMemberAuditEntryReason = "USER_ACCOUNT_DELETED"
)

// Audit log entry for a org.remove_outside_collaborator event.
type OrgRemoveOutsideCollaboratorAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the OrgRemoveOutsideCollaboratorAuditEntry object
	Id string `json:"id"`
	// The types of membership the outside collaborator has with the organization.
	MembershipTypes []OrgRemoveOutsideCollaboratorAuditEntryMembershipType `json:"membershipTypes,omitempty"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The reason for the outside collaborator being removed from the Organization.
	Reason *OrgRemoveOutsideCollaboratorAuditEntryReason `json:"reason,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*OrgRemoveOutsideCollaboratorAuditEntry) isAuditEntry() {}

func (*OrgRemoveOutsideCollaboratorAuditEntry) isNode() {}

func (*OrgRemoveOutsideCollaboratorAuditEntry) isOrganizationAuditEntryData() {}

func (*OrgRemoveOutsideCollaboratorAuditEntry) isOrganizationAuditEntry() {}

// The type of membership a user has with an Organization.
type OrgRemoveOutsideCollaboratorAuditEntryMembershipType string

const (
	// A billing manager is a user who manages the billing settings for the Organization, such as updating payment information.
	OrgRemoveOutsideCollaboratorAuditEntryMembershipTypeBillingManager OrgRemoveOutsideCollaboratorAuditEntryMembershipType = "BILLING_MANAGER"
	// An outside collaborator is a person who isn't explicitly a member of the
	// Organization, but who has Read, Write, or Admin permissions to one or more
	// repositories in the organization.
	OrgRemoveOutsideCollaboratorAuditEntryMembershipTypeOutsideCollaborator OrgRemoveOutsideCollaboratorAuditEntryMembershipType = "OUTSIDE_COLLABORATOR"
	// An unaffiliated collaborator is a person who is not a member of the
	// Organization and does not have access to any repositories in the organization.
	OrgRemoveOutsideCollaboratorAuditEntryMembershipTypeUnaffiliated OrgRemoveOutsideCollaboratorAuditEntryMembershipType = "UNAFFILIATED"
)

// The reason an outside collaborator was removed from an Organization.
type OrgRemoveOutsideCollaboratorAuditEntryReason string

const (
	// SAML external identity missing
	OrgRemoveOutsideCollaboratorAuditEntryReasonSamlExternalIdentityMissing OrgRemoveOutsideCollaboratorAuditEntryReason = "SAML_EXTERNAL_IDENTITY_MISSING"
	// The organization required 2FA of its billing managers and this user did not have 2FA enabled.
	OrgRemoveOutsideCollaboratorAuditEntryReasonTwoFactorRequirementNonCompliance OrgRemoveOutsideCollaboratorAuditEntryReason = "TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE"
)

// Audit log entry for a org.restore_member event.
type OrgRestoreMemberAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the OrgRestoreMemberAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The number of custom email routings for the restored member.
	RestoredCustomEmailRoutingsCount *int32 `json:"restoredCustomEmailRoutingsCount,omitempty"`
	// The number of issue assignments for the restored member.
	RestoredIssueAssignmentsCount *int32 `json:"restoredIssueAssignmentsCount,omitempty"`
	// Restored organization membership objects.
	RestoredMemberships []OrgRestoreMemberAuditEntryMembership `json:"restoredMemberships,omitempty"`
	// The number of restored memberships.
	RestoredMembershipsCount *int32 `json:"restoredMembershipsCount,omitempty"`
	// The number of repositories of the restored member.
	RestoredRepositoriesCount *int32 `json:"restoredRepositoriesCount,omitempty"`
	// The number of starred repositories for the restored member.
	RestoredRepositoryStarsCount *int32 `json:"restoredRepositoryStarsCount,omitempty"`
	// The number of watched repositories for the restored member.
	RestoredRepositoryWatchesCount *int32 `json:"restoredRepositoryWatchesCount,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*OrgRestoreMemberAuditEntry) isAuditEntry() {}

func (*OrgRestoreMemberAuditEntry) isNode() {}

func (*OrgRestoreMemberAuditEntry) isOrganizationAuditEntryData() {}

func (*OrgRestoreMemberAuditEntry) isOrganizationAuditEntry() {}

// Types of memberships that can be restored for an Organization member.
type OrgRestoreMemberAuditEntryMembership struct {
	// Underlying value of the GraphQL union
	Value OrgRestoreMemberAuditEntryMembershipValue `json:"-"`
}

func (base *OrgRestoreMemberAuditEntryMembership) UnmarshalJSON(b []byte) error {
	type Raw OrgRestoreMemberAuditEntryMembership
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "OrgRestoreMemberMembershipOrganizationAuditEntryData":
		base.Value = new(OrgRestoreMemberMembershipOrganizationAuditEntryData)
	case "OrgRestoreMemberMembershipRepositoryAuditEntryData":
		base.Value = new(OrgRestoreMemberMembershipRepositoryAuditEntryData)
	case "OrgRestoreMemberMembershipTeamAuditEntryData":
		base.Value = new(OrgRestoreMemberMembershipTeamAuditEntryData)
	case "":
		return fmt.Errorf("gqlclient: union OrgRestoreMemberAuditEntryMembership: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union OrgRestoreMemberAuditEntryMembership: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// OrgRestoreMemberAuditEntryMembershipValue is one of: OrgRestoreMemberMembershipOrganizationAuditEntryData | OrgRestoreMemberMembershipRepositoryAuditEntryData | OrgRestoreMemberMembershipTeamAuditEntryData
type OrgRestoreMemberAuditEntryMembershipValue interface {
	isOrgRestoreMemberAuditEntryMembership()
}

// Metadata for an organization membership for org.restore_member actions
type OrgRestoreMemberMembershipOrganizationAuditEntryData struct {
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
}

func (*OrgRestoreMemberMembershipOrganizationAuditEntryData) isOrgRestoreMemberAuditEntryMembership() {
}

func (*OrgRestoreMemberMembershipOrganizationAuditEntryData) isOrganizationAuditEntryData() {}

// Metadata for a repository membership for org.restore_member actions
type OrgRestoreMemberMembershipRepositoryAuditEntryData struct {
	// The repository associated with the action
	Repository *Repository `json:"repository,omitempty"`
	// The name of the repository
	RepositoryName *string `json:"repositoryName,omitempty"`
	// The HTTP path for the repository
	RepositoryResourcePath *URI `json:"repositoryResourcePath,omitempty"`
	// The HTTP URL for the repository
	RepositoryUrl *URI `json:"repositoryUrl,omitempty"`
}

func (*OrgRestoreMemberMembershipRepositoryAuditEntryData) isOrgRestoreMemberAuditEntryMembership() {}

func (*OrgRestoreMemberMembershipRepositoryAuditEntryData) isRepositoryAuditEntryData() {}

// Metadata for a team membership for org.restore_member actions
type OrgRestoreMemberMembershipTeamAuditEntryData struct {
	// The team associated with the action
	Team *Team `json:"team,omitempty"`
	// The name of the team
	TeamName *string `json:"teamName,omitempty"`
	// The HTTP path for this team
	TeamResourcePath *URI `json:"teamResourcePath,omitempty"`
	// The HTTP URL for this team
	TeamUrl *URI `json:"teamUrl,omitempty"`
}

func (*OrgRestoreMemberMembershipTeamAuditEntryData) isOrgRestoreMemberAuditEntryMembership() {}

func (*OrgRestoreMemberMembershipTeamAuditEntryData) isTeamAuditEntryData() {}

// Audit log entry for a org.unblock_user
type OrgUnblockUserAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The user being unblocked by the organization.
	BlockedUser *User `json:"blockedUser,omitempty"`
	// The username of the blocked user.
	BlockedUserName *string `json:"blockedUserName,omitempty"`
	// The HTTP path for the blocked user.
	BlockedUserResourcePath *URI `json:"blockedUserResourcePath,omitempty"`
	// The HTTP URL for the blocked user.
	BlockedUserUrl *URI `json:"blockedUserUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the OrgUnblockUserAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*OrgUnblockUserAuditEntry) isAuditEntry() {}

func (*OrgUnblockUserAuditEntry) isNode() {}

func (*OrgUnblockUserAuditEntry) isOrganizationAuditEntryData() {}

func (*OrgUnblockUserAuditEntry) isOrganizationAuditEntry() {}

// Audit log entry for a org.update_default_repository_permission
type OrgUpdateDefaultRepositoryPermissionAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the OrgUpdateDefaultRepositoryPermissionAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The new base repository permission level for the organization.
	Permission *OrgUpdateDefaultRepositoryPermissionAuditEntryPermission `json:"permission,omitempty"`
	// The former base repository permission level for the organization.
	PermissionWas *OrgUpdateDefaultRepositoryPermissionAuditEntryPermission `json:"permissionWas,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*OrgUpdateDefaultRepositoryPermissionAuditEntry) isAuditEntry() {}

func (*OrgUpdateDefaultRepositoryPermissionAuditEntry) isNode() {}

func (*OrgUpdateDefaultRepositoryPermissionAuditEntry) isOrganizationAuditEntryData() {}

func (*OrgUpdateDefaultRepositoryPermissionAuditEntry) isOrganizationAuditEntry() {}

// The default permission a repository can have in an Organization.
type OrgUpdateDefaultRepositoryPermissionAuditEntryPermission string

const (
	// Can read, clone, push, and add collaborators to repositories.
	OrgUpdateDefaultRepositoryPermissionAuditEntryPermissionAdmin OrgUpdateDefaultRepositoryPermissionAuditEntryPermission = "ADMIN"
	// No default permission value.
	OrgUpdateDefaultRepositoryPermissionAuditEntryPermissionNone OrgUpdateDefaultRepositoryPermissionAuditEntryPermission = "NONE"
	// Can read and clone repositories.
	OrgUpdateDefaultRepositoryPermissionAuditEntryPermissionRead OrgUpdateDefaultRepositoryPermissionAuditEntryPermission = "READ"
	// Can read, clone and push to repositories.
	OrgUpdateDefaultRepositoryPermissionAuditEntryPermissionWrite OrgUpdateDefaultRepositoryPermissionAuditEntryPermission = "WRITE"
)

// Audit log entry for a org.update_member event.
type OrgUpdateMemberAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the OrgUpdateMemberAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The new member permission level for the organization.
	Permission *OrgUpdateMemberAuditEntryPermission `json:"permission,omitempty"`
	// The former member permission level for the organization.
	PermissionWas *OrgUpdateMemberAuditEntryPermission `json:"permissionWas,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*OrgUpdateMemberAuditEntry) isAuditEntry() {}

func (*OrgUpdateMemberAuditEntry) isNode() {}

func (*OrgUpdateMemberAuditEntry) isOrganizationAuditEntryData() {}

func (*OrgUpdateMemberAuditEntry) isOrganizationAuditEntry() {}

// The permissions available to members on an Organization.
type OrgUpdateMemberAuditEntryPermission string

const (
	// Can read, clone, push, and add collaborators to repositories.
	OrgUpdateMemberAuditEntryPermissionAdmin OrgUpdateMemberAuditEntryPermission = "ADMIN"
	// Can read and clone repositories.
	OrgUpdateMemberAuditEntryPermissionRead OrgUpdateMemberAuditEntryPermission = "READ"
)

// Audit log entry for a org.update_member_repository_creation_permission event.
type OrgUpdateMemberRepositoryCreationPermissionAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// Can members create repositories in the organization.
	CanCreateRepositories *bool `json:"canCreateRepositories,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the OrgUpdateMemberRepositoryCreationPermissionAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
	// The permission for visibility level of repositories for this organization.
	Visibility *OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility `json:"visibility,omitempty"`
}

func (*OrgUpdateMemberRepositoryCreationPermissionAuditEntry) isAuditEntry() {}

func (*OrgUpdateMemberRepositoryCreationPermissionAuditEntry) isNode() {}

func (*OrgUpdateMemberRepositoryCreationPermissionAuditEntry) isOrganizationAuditEntryData() {}

func (*OrgUpdateMemberRepositoryCreationPermissionAuditEntry) isOrganizationAuditEntry() {}

// The permissions available for repository creation on an Organization.
type OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility string

const (
	// All organization members are restricted from creating any repositories.
	OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityAll OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility = "ALL"
	// All organization members are restricted from creating internal repositories.
	OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityInternal OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility = "INTERNAL"
	// All organization members are allowed to create any repositories.
	OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityNone OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility = "NONE"
	// All organization members are restricted from creating private repositories.
	OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityPrivate OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility = "PRIVATE"
	// All organization members are restricted from creating private or internal repositories.
	OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityPrivateInternal OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility = "PRIVATE_INTERNAL"
	// All organization members are restricted from creating public repositories.
	OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityPublic OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility = "PUBLIC"
	// All organization members are restricted from creating public or internal repositories.
	OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityPublicInternal OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility = "PUBLIC_INTERNAL"
	// All organization members are restricted from creating public or private repositories.
	OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityPublicPrivate OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility = "PUBLIC_PRIVATE"
)

// Audit log entry for a org.update_member_repository_invitation_permission event.
type OrgUpdateMemberRepositoryInvitationPermissionAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// Can outside collaborators be invited to repositories in the organization.
	CanInviteOutsideCollaboratorsToRepositories *bool `json:"canInviteOutsideCollaboratorsToRepositories,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the OrgUpdateMemberRepositoryInvitationPermissionAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*OrgUpdateMemberRepositoryInvitationPermissionAuditEntry) isAuditEntry() {}

func (*OrgUpdateMemberRepositoryInvitationPermissionAuditEntry) isNode() {}

func (*OrgUpdateMemberRepositoryInvitationPermissionAuditEntry) isOrganizationAuditEntryData() {}

func (*OrgUpdateMemberRepositoryInvitationPermissionAuditEntry) isOrganizationAuditEntry() {}

// An account on GitHub, with one or more owners, that has repositories, members and teams.
type Organization struct {
	// The announcement banner set on this organization, if any. Only visible to members of the organization's enterprise.
	AnnouncementBanner *AnnouncementBanner `json:"announcementBanner,omitempty"`
	// Determine if this repository owner has any items that can be pinned to their profile.
	AnyPinnableItems bool `json:"anyPinnableItems"`
	// Identifies the date and time when the organization was archived.
	ArchivedAt *DateTime `json:"archivedAt,omitempty"`
	// Audit log entries of the organization
	AuditLog *OrganizationAuditEntryConnection `json:"auditLog"`
	// A URL pointing to the organization's public avatar.
	AvatarUrl URI `json:"avatarUrl"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The organization's public profile description.
	Description *string `json:"description,omitempty"`
	// The organization's public profile description rendered to HTML.
	DescriptionHTML *string `json:"descriptionHTML,omitempty"`
	// A list of domains owned by the organization.
	Domains *VerifiableDomainConnection `json:"domains,omitempty"`
	// The organization's public email.
	Email *string `json:"email,omitempty"`
	// A list of owners of the organization's enterprise account.
	EnterpriseOwners *OrganizationEnterpriseOwnerConnection `json:"enterpriseOwners"`
	// The estimated next GitHub Sponsors payout for this user/organization in cents (USD).
	EstimatedNextSponsorsPayoutInCents int32 `json:"estimatedNextSponsorsPayoutInCents"`
	// True if this user/organization has a GitHub Sponsors listing.
	HasSponsorsListing bool `json:"hasSponsorsListing"`
	// The Node ID of the Organization object
	Id string `json:"id"`
	// The interaction ability settings for this organization.
	InteractionAbility *RepositoryInteractionAbility `json:"interactionAbility,omitempty"`
	// The setting value for whether the organization has an IP allow list enabled.
	IpAllowListEnabledSetting IpAllowListEnabledSettingValue `json:"ipAllowListEnabledSetting"`
	// The IP addresses that are allowed to access resources owned by the organization.
	IpAllowListEntries *IpAllowListEntryConnection `json:"ipAllowListEntries"`
	// The setting value for whether the organization has IP allow list configuration for installed GitHub Apps enabled.
	IpAllowListForInstalledAppsEnabledSetting IpAllowListForInstalledAppsEnabledSettingValue `json:"ipAllowListForInstalledAppsEnabledSetting"`
	// Whether the given account is sponsoring this user/organization.
	IsSponsoredBy bool `json:"isSponsoredBy"`
	// True if the viewer is sponsored by this user/organization.
	IsSponsoringViewer bool `json:"isSponsoringViewer"`
	// Whether the organization has verified its profile email and website.
	IsVerified bool `json:"isVerified"`
	// A list of the organization's issue types
	IssueTypes *IssueTypeConnection `json:"issueTypes,omitempty"`
	// Showcases a selection of repositories and gists that the profile owner has
	// either curated or that have been selected automatically based on popularity.
	ItemShowcase *ProfileItemShowcase `json:"itemShowcase"`
	// Calculate how much each sponsor has ever paid total to this maintainer via
	// GitHub Sponsors. Does not include sponsorships paid via Patreon.
	LifetimeReceivedSponsorshipValues *SponsorAndLifetimeValueConnection `json:"lifetimeReceivedSponsorshipValues"`
	// The organization's public profile location.
	Location *string `json:"location,omitempty"`
	// The organization's login name.
	Login string `json:"login"`
	// A list of all mannequins for this organization.
	Mannequins *MannequinConnection `json:"mannequins"`
	// Get the status messages members of this entity have set that are either public or visible only to the organization.
	MemberStatuses *UserStatusConnection `json:"memberStatuses"`
	// Members can fork private repositories in this organization
	MembersCanForkPrivateRepositories bool `json:"membersCanForkPrivateRepositories"`
	// A list of users who are members of this organization.
	MembersWithRole *OrganizationMemberConnection `json:"membersWithRole"`
	// The estimated monthly GitHub Sponsors income for this user/organization in cents (USD).
	MonthlyEstimatedSponsorsIncomeInCents int32 `json:"monthlyEstimatedSponsorsIncomeInCents"`
	// The organization's public profile name.
	Name *string `json:"name,omitempty"`
	// The HTTP path creating a new team
	NewTeamResourcePath URI `json:"newTeamResourcePath"`
	// The HTTP URL creating a new team
	NewTeamUrl URI `json:"newTeamUrl"`
	// Indicates if email notification delivery for this organization is restricted to verified or approved domains.
	NotificationDeliveryRestrictionEnabledSetting NotificationRestrictionSettingValue `json:"notificationDeliveryRestrictionEnabledSetting"`
	// The billing email for the organization.
	OrganizationBillingEmail *string `json:"organizationBillingEmail,omitempty"`
	// A list of packages under the owner.
	Packages *PackageConnection `json:"packages"`
	// A list of users who have been invited to join this organization.
	PendingMembers *UserConnection `json:"pendingMembers"`
	// A list of repositories and gists this profile owner can pin to their profile.
	PinnableItems *PinnableItemConnection `json:"pinnableItems"`
	// A list of repositories and gists this profile owner has pinned to their profile
	PinnedItems *PinnableItemConnection `json:"pinnedItems"`
	// Returns how many more items this profile owner can pin to their profile.
	PinnedItemsRemaining int32 `json:"pinnedItemsRemaining"`
	// Find project by number.
	Project *Project `json:"project,omitempty"`
	// Find a project by number.
	ProjectV2 *ProjectV2 `json:"projectV2,omitempty"`
	// A list of projects under the owner.
	Projects *ProjectConnection `json:"projects"`
	// The HTTP path listing organization's projects
	ProjectsResourcePath URI `json:"projectsResourcePath"`
	// The HTTP URL listing organization's projects
	ProjectsUrl URI `json:"projectsUrl"`
	// A list of projects under the owner.
	ProjectsV2 *ProjectV2Connection `json:"projectsV2"`
	// Recent projects that this user has modified in the context of the owner.
	RecentProjects *ProjectV2Connection `json:"recentProjects"`
	// A list of repositories that the user owns.
	Repositories *RepositoryConnection `json:"repositories"`
	// Find Repository.
	Repository *Repository `json:"repository,omitempty"`
	// Discussion comments this user has authored.
	RepositoryDiscussionComments *DiscussionCommentConnection `json:"repositoryDiscussionComments"`
	// Discussions this user has started.
	RepositoryDiscussions *DiscussionConnection `json:"repositoryDiscussions"`
	// A list of all repository migrations for this organization.
	RepositoryMigrations *RepositoryMigrationConnection `json:"repositoryMigrations"`
	// When true the organization requires all members, billing managers, and outside
	// collaborators to enable two-factor authentication.
	RequiresTwoFactorAuthentication *bool `json:"requiresTwoFactorAuthentication,omitempty"`
	// The HTTP path for this organization.
	ResourcePath URI `json:"resourcePath"`
	// Returns a single ruleset from the current organization by ID.
	Ruleset *RepositoryRuleset `json:"ruleset,omitempty"`
	// A list of rulesets for this organization.
	Rulesets *RepositoryRulesetConnection `json:"rulesets,omitempty"`
	// The Organization's SAML identity provider. Visible to (1) organization owners,
	// (2) organization owners' personal access tokens (classic) with read:org or
	// admin:org scope, (3) GitHub App with an installation token with read or write
	// access to members.
	SamlIdentityProvider *OrganizationIdentityProvider `json:"samlIdentityProvider,omitempty"`
	// List of users and organizations this entity is sponsoring.
	Sponsoring *SponsorConnection `json:"sponsoring"`
	// List of sponsors for this user or organization.
	Sponsors *SponsorConnection `json:"sponsors"`
	// Events involving this sponsorable, such as new sponsorships.
	SponsorsActivities *SponsorsActivityConnection `json:"sponsorsActivities"`
	// The GitHub Sponsors listing for this user or organization.
	SponsorsListing *SponsorsListing `json:"sponsorsListing,omitempty"`
	// The sponsorship from the viewer to this user/organization; that is, the sponsorship where you're the sponsor.
	SponsorshipForViewerAsSponsor *Sponsorship `json:"sponsorshipForViewerAsSponsor,omitempty"`
	// The sponsorship from this user/organization to the viewer; that is, the sponsorship you're receiving.
	SponsorshipForViewerAsSponsorable *Sponsorship `json:"sponsorshipForViewerAsSponsorable,omitempty"`
	// List of sponsorship updates sent from this sponsorable to sponsors.
	SponsorshipNewsletters *SponsorshipNewsletterConnection `json:"sponsorshipNewsletters"`
	// The sponsorships where this user or organization is the maintainer receiving the funds.
	SponsorshipsAsMaintainer *SponsorshipConnection `json:"sponsorshipsAsMaintainer"`
	// The sponsorships where this user or organization is the funder.
	SponsorshipsAsSponsor *SponsorshipConnection `json:"sponsorshipsAsSponsor"`
	// Find an organization's team by its slug.
	Team *Team `json:"team,omitempty"`
	// A list of teams in this organization.
	Teams *TeamConnection `json:"teams"`
	// The HTTP path listing organization's teams
	TeamsResourcePath URI `json:"teamsResourcePath"`
	// The HTTP URL listing organization's teams
	TeamsUrl URI `json:"teamsUrl"`
	// The amount in United States cents (e.g., 500 = $5.00 USD) that this entity has
	// spent on GitHub to fund sponsorships. Only returns a value when viewed by the
	// user themselves or by a user who can manage sponsorships for the requested organization.
	TotalSponsorshipAmountAsSponsorInCents *int32 `json:"totalSponsorshipAmountAsSponsorInCents,omitempty"`
	// The organization's Twitter username.
	TwitterUsername *string `json:"twitterUsername,omitempty"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The HTTP URL for this organization.
	Url URI `json:"url"`
	// Organization is adminable by the viewer.
	ViewerCanAdminister bool `json:"viewerCanAdminister"`
	// Can the viewer pin repositories and gists to the profile?
	ViewerCanChangePinnedItems bool `json:"viewerCanChangePinnedItems"`
	// Can the current viewer create new projects on this owner.
	ViewerCanCreateProjects bool `json:"viewerCanCreateProjects"`
	// Viewer can create repositories on this organization
	ViewerCanCreateRepositories bool `json:"viewerCanCreateRepositories"`
	// Viewer can create teams on this organization.
	ViewerCanCreateTeams bool `json:"viewerCanCreateTeams"`
	// Whether or not the viewer is able to sponsor this user/organization.
	ViewerCanSponsor bool `json:"viewerCanSponsor"`
	// Viewer is an active member of this organization.
	ViewerIsAMember bool `json:"viewerIsAMember"`
	// Whether or not this Organization is followed by the viewer.
	ViewerIsFollowing bool `json:"viewerIsFollowing"`
	// True if the viewer is sponsoring this user/organization.
	ViewerIsSponsoring bool `json:"viewerIsSponsoring"`
	// Whether contributors are required to sign off on web-based commits for repositories in this organization.
	WebCommitSignoffRequired bool `json:"webCommitSignoffRequired"`
	// The organization's public profile URL.
	WebsiteUrl *URI `json:"websiteUrl,omitempty"`
}

func (*Organization) isAssignee() {}

func (*Organization) isAuditEntryActor() {}

func (*Organization) isIpAllowListOwner() {}

func (*Organization) isActor() {}

func (*Organization) isMemberStatusable() {}

func (*Organization) isNode() {}

func (*Organization) isPackageOwner() {}

func (*Organization) isProfileOwner() {}

func (*Organization) isProjectOwner() {}

func (*Organization) isProjectV2Owner() {}

func (*Organization) isProjectV2Recent() {}

func (*Organization) isRepositoryDiscussionAuthor() {}

func (*Organization) isRepositoryDiscussionCommentAuthor() {}

func (*Organization) isRepositoryOwner() {}

func (*Organization) isSponsorable() {}

func (*Organization) isUniformResourceLocatable() {}

func (*Organization) isOrganizationOrUser() {}

func (*Organization) isPermissionGranter() {}

func (*Organization) isReactor() {}

func (*Organization) isRuleSource() {}

func (*Organization) isSearchResultItem() {}

func (*Organization) isSponsor() {}

func (*Organization) isSponsorableItem() {}

func (*Organization) isVerifiableDomainOwner() {}

// An audit entry in an organization audit log.
type OrganizationAuditEntry struct {
	// Underlying value of the GraphQL union
	Value OrganizationAuditEntryValue `json:"-"`
}

func (base *OrganizationAuditEntry) UnmarshalJSON(b []byte) error {
	type Raw OrganizationAuditEntry
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "MembersCanDeleteReposClearAuditEntry":
		base.Value = new(MembersCanDeleteReposClearAuditEntry)
	case "MembersCanDeleteReposDisableAuditEntry":
		base.Value = new(MembersCanDeleteReposDisableAuditEntry)
	case "MembersCanDeleteReposEnableAuditEntry":
		base.Value = new(MembersCanDeleteReposEnableAuditEntry)
	case "OauthApplicationCreateAuditEntry":
		base.Value = new(OauthApplicationCreateAuditEntry)
	case "OrgAddBillingManagerAuditEntry":
		base.Value = new(OrgAddBillingManagerAuditEntry)
	case "OrgAddMemberAuditEntry":
		base.Value = new(OrgAddMemberAuditEntry)
	case "OrgBlockUserAuditEntry":
		base.Value = new(OrgBlockUserAuditEntry)
	case "OrgConfigDisableCollaboratorsOnlyAuditEntry":
		base.Value = new(OrgConfigDisableCollaboratorsOnlyAuditEntry)
	case "OrgConfigEnableCollaboratorsOnlyAuditEntry":
		base.Value = new(OrgConfigEnableCollaboratorsOnlyAuditEntry)
	case "OrgCreateAuditEntry":
		base.Value = new(OrgCreateAuditEntry)
	case "OrgDisableOauthAppRestrictionsAuditEntry":
		base.Value = new(OrgDisableOauthAppRestrictionsAuditEntry)
	case "OrgDisableSamlAuditEntry":
		base.Value = new(OrgDisableSamlAuditEntry)
	case "OrgDisableTwoFactorRequirementAuditEntry":
		base.Value = new(OrgDisableTwoFactorRequirementAuditEntry)
	case "OrgEnableOauthAppRestrictionsAuditEntry":
		base.Value = new(OrgEnableOauthAppRestrictionsAuditEntry)
	case "OrgEnableSamlAuditEntry":
		base.Value = new(OrgEnableSamlAuditEntry)
	case "OrgEnableTwoFactorRequirementAuditEntry":
		base.Value = new(OrgEnableTwoFactorRequirementAuditEntry)
	case "OrgInviteMemberAuditEntry":
		base.Value = new(OrgInviteMemberAuditEntry)
	case "OrgInviteToBusinessAuditEntry":
		base.Value = new(OrgInviteToBusinessAuditEntry)
	case "OrgOauthAppAccessApprovedAuditEntry":
		base.Value = new(OrgOauthAppAccessApprovedAuditEntry)
	case "OrgOauthAppAccessBlockedAuditEntry":
		base.Value = new(OrgOauthAppAccessBlockedAuditEntry)
	case "OrgOauthAppAccessDeniedAuditEntry":
		base.Value = new(OrgOauthAppAccessDeniedAuditEntry)
	case "OrgOauthAppAccessRequestedAuditEntry":
		base.Value = new(OrgOauthAppAccessRequestedAuditEntry)
	case "OrgOauthAppAccessUnblockedAuditEntry":
		base.Value = new(OrgOauthAppAccessUnblockedAuditEntry)
	case "OrgRemoveBillingManagerAuditEntry":
		base.Value = new(OrgRemoveBillingManagerAuditEntry)
	case "OrgRemoveMemberAuditEntry":
		base.Value = new(OrgRemoveMemberAuditEntry)
	case "OrgRemoveOutsideCollaboratorAuditEntry":
		base.Value = new(OrgRemoveOutsideCollaboratorAuditEntry)
	case "OrgRestoreMemberAuditEntry":
		base.Value = new(OrgRestoreMemberAuditEntry)
	case "OrgUnblockUserAuditEntry":
		base.Value = new(OrgUnblockUserAuditEntry)
	case "OrgUpdateDefaultRepositoryPermissionAuditEntry":
		base.Value = new(OrgUpdateDefaultRepositoryPermissionAuditEntry)
	case "OrgUpdateMemberAuditEntry":
		base.Value = new(OrgUpdateMemberAuditEntry)
	case "OrgUpdateMemberRepositoryCreationPermissionAuditEntry":
		base.Value = new(OrgUpdateMemberRepositoryCreationPermissionAuditEntry)
	case "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry":
		base.Value = new(OrgUpdateMemberRepositoryInvitationPermissionAuditEntry)
	case "PrivateRepositoryForkingDisableAuditEntry":
		base.Value = new(PrivateRepositoryForkingDisableAuditEntry)
	case "PrivateRepositoryForkingEnableAuditEntry":
		base.Value = new(PrivateRepositoryForkingEnableAuditEntry)
	case "RepoAccessAuditEntry":
		base.Value = new(RepoAccessAuditEntry)
	case "RepoAddMemberAuditEntry":
		base.Value = new(RepoAddMemberAuditEntry)
	case "RepoAddTopicAuditEntry":
		base.Value = new(RepoAddTopicAuditEntry)
	case "RepoArchivedAuditEntry":
		base.Value = new(RepoArchivedAuditEntry)
	case "RepoChangeMergeSettingAuditEntry":
		base.Value = new(RepoChangeMergeSettingAuditEntry)
	case "RepoConfigDisableAnonymousGitAccessAuditEntry":
		base.Value = new(RepoConfigDisableAnonymousGitAccessAuditEntry)
	case "RepoConfigDisableCollaboratorsOnlyAuditEntry":
		base.Value = new(RepoConfigDisableCollaboratorsOnlyAuditEntry)
	case "RepoConfigDisableContributorsOnlyAuditEntry":
		base.Value = new(RepoConfigDisableContributorsOnlyAuditEntry)
	case "RepoConfigDisableSockpuppetDisallowedAuditEntry":
		base.Value = new(RepoConfigDisableSockpuppetDisallowedAuditEntry)
	case "RepoConfigEnableAnonymousGitAccessAuditEntry":
		base.Value = new(RepoConfigEnableAnonymousGitAccessAuditEntry)
	case "RepoConfigEnableCollaboratorsOnlyAuditEntry":
		base.Value = new(RepoConfigEnableCollaboratorsOnlyAuditEntry)
	case "RepoConfigEnableContributorsOnlyAuditEntry":
		base.Value = new(RepoConfigEnableContributorsOnlyAuditEntry)
	case "RepoConfigEnableSockpuppetDisallowedAuditEntry":
		base.Value = new(RepoConfigEnableSockpuppetDisallowedAuditEntry)
	case "RepoConfigLockAnonymousGitAccessAuditEntry":
		base.Value = new(RepoConfigLockAnonymousGitAccessAuditEntry)
	case "RepoConfigUnlockAnonymousGitAccessAuditEntry":
		base.Value = new(RepoConfigUnlockAnonymousGitAccessAuditEntry)
	case "RepoCreateAuditEntry":
		base.Value = new(RepoCreateAuditEntry)
	case "RepoDestroyAuditEntry":
		base.Value = new(RepoDestroyAuditEntry)
	case "RepoRemoveMemberAuditEntry":
		base.Value = new(RepoRemoveMemberAuditEntry)
	case "RepoRemoveTopicAuditEntry":
		base.Value = new(RepoRemoveTopicAuditEntry)
	case "RepositoryVisibilityChangeDisableAuditEntry":
		base.Value = new(RepositoryVisibilityChangeDisableAuditEntry)
	case "RepositoryVisibilityChangeEnableAuditEntry":
		base.Value = new(RepositoryVisibilityChangeEnableAuditEntry)
	case "TeamAddMemberAuditEntry":
		base.Value = new(TeamAddMemberAuditEntry)
	case "TeamAddRepositoryAuditEntry":
		base.Value = new(TeamAddRepositoryAuditEntry)
	case "TeamChangeParentTeamAuditEntry":
		base.Value = new(TeamChangeParentTeamAuditEntry)
	case "TeamRemoveMemberAuditEntry":
		base.Value = new(TeamRemoveMemberAuditEntry)
	case "TeamRemoveRepositoryAuditEntry":
		base.Value = new(TeamRemoveRepositoryAuditEntry)
	case "":
		return fmt.Errorf("gqlclient: union OrganizationAuditEntry: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union OrganizationAuditEntry: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// OrganizationAuditEntryValue is one of: MembersCanDeleteReposClearAuditEntry | MembersCanDeleteReposDisableAuditEntry | MembersCanDeleteReposEnableAuditEntry | OauthApplicationCreateAuditEntry | OrgAddBillingManagerAuditEntry | OrgAddMemberAuditEntry | OrgBlockUserAuditEntry | OrgConfigDisableCollaboratorsOnlyAuditEntry | OrgConfigEnableCollaboratorsOnlyAuditEntry | OrgCreateAuditEntry | OrgDisableOauthAppRestrictionsAuditEntry | OrgDisableSamlAuditEntry | OrgDisableTwoFactorRequirementAuditEntry | OrgEnableOauthAppRestrictionsAuditEntry | OrgEnableSamlAuditEntry | OrgEnableTwoFactorRequirementAuditEntry | OrgInviteMemberAuditEntry | OrgInviteToBusinessAuditEntry | OrgOauthAppAccessApprovedAuditEntry | OrgOauthAppAccessBlockedAuditEntry | OrgOauthAppAccessDeniedAuditEntry | OrgOauthAppAccessRequestedAuditEntry | OrgOauthAppAccessUnblockedAuditEntry | OrgRemoveBillingManagerAuditEntry | OrgRemoveMemberAuditEntry | OrgRemoveOutsideCollaboratorAuditEntry | OrgRestoreMemberAuditEntry | OrgUnblockUserAuditEntry | OrgUpdateDefaultRepositoryPermissionAuditEntry | OrgUpdateMemberAuditEntry | OrgUpdateMemberRepositoryCreationPermissionAuditEntry | OrgUpdateMemberRepositoryInvitationPermissionAuditEntry | PrivateRepositoryForkingDisableAuditEntry | PrivateRepositoryForkingEnableAuditEntry | RepoAccessAuditEntry | RepoAddMemberAuditEntry | RepoAddTopicAuditEntry | RepoArchivedAuditEntry | RepoChangeMergeSettingAuditEntry | RepoConfigDisableAnonymousGitAccessAuditEntry | RepoConfigDisableCollaboratorsOnlyAuditEntry | RepoConfigDisableContributorsOnlyAuditEntry | RepoConfigDisableSockpuppetDisallowedAuditEntry | RepoConfigEnableAnonymousGitAccessAuditEntry | RepoConfigEnableCollaboratorsOnlyAuditEntry | RepoConfigEnableContributorsOnlyAuditEntry | RepoConfigEnableSockpuppetDisallowedAuditEntry | RepoConfigLockAnonymousGitAccessAuditEntry | RepoConfigUnlockAnonymousGitAccessAuditEntry | RepoCreateAuditEntry | RepoDestroyAuditEntry | RepoRemoveMemberAuditEntry | RepoRemoveTopicAuditEntry | RepositoryVisibilityChangeDisableAuditEntry | RepositoryVisibilityChangeEnableAuditEntry | TeamAddMemberAuditEntry | TeamAddRepositoryAuditEntry | TeamChangeParentTeamAuditEntry | TeamRemoveMemberAuditEntry | TeamRemoveRepositoryAuditEntry
type OrganizationAuditEntryValue interface {
	isOrganizationAuditEntry()
}

// The connection type for OrganizationAuditEntry.
type OrganizationAuditEntryConnection struct {
	// A list of edges.
	Edges []*OrganizationAuditEntryEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*OrganizationAuditEntry `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// Metadata for an audit entry with action org.*
type OrganizationAuditEntryData struct {
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`

	// Underlying value of the GraphQL interface
	Value OrganizationAuditEntryDataValue `json:"-"`
}

func (base *OrganizationAuditEntryData) UnmarshalJSON(b []byte) error {
	type Raw OrganizationAuditEntryData
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "MembersCanDeleteReposClearAuditEntry":
		base.Value = new(MembersCanDeleteReposClearAuditEntry)
	case "MembersCanDeleteReposDisableAuditEntry":
		base.Value = new(MembersCanDeleteReposDisableAuditEntry)
	case "MembersCanDeleteReposEnableAuditEntry":
		base.Value = new(MembersCanDeleteReposEnableAuditEntry)
	case "OauthApplicationCreateAuditEntry":
		base.Value = new(OauthApplicationCreateAuditEntry)
	case "OrgAddBillingManagerAuditEntry":
		base.Value = new(OrgAddBillingManagerAuditEntry)
	case "OrgAddMemberAuditEntry":
		base.Value = new(OrgAddMemberAuditEntry)
	case "OrgBlockUserAuditEntry":
		base.Value = new(OrgBlockUserAuditEntry)
	case "OrgConfigDisableCollaboratorsOnlyAuditEntry":
		base.Value = new(OrgConfigDisableCollaboratorsOnlyAuditEntry)
	case "OrgConfigEnableCollaboratorsOnlyAuditEntry":
		base.Value = new(OrgConfigEnableCollaboratorsOnlyAuditEntry)
	case "OrgCreateAuditEntry":
		base.Value = new(OrgCreateAuditEntry)
	case "OrgDisableOauthAppRestrictionsAuditEntry":
		base.Value = new(OrgDisableOauthAppRestrictionsAuditEntry)
	case "OrgDisableSamlAuditEntry":
		base.Value = new(OrgDisableSamlAuditEntry)
	case "OrgDisableTwoFactorRequirementAuditEntry":
		base.Value = new(OrgDisableTwoFactorRequirementAuditEntry)
	case "OrgEnableOauthAppRestrictionsAuditEntry":
		base.Value = new(OrgEnableOauthAppRestrictionsAuditEntry)
	case "OrgEnableSamlAuditEntry":
		base.Value = new(OrgEnableSamlAuditEntry)
	case "OrgEnableTwoFactorRequirementAuditEntry":
		base.Value = new(OrgEnableTwoFactorRequirementAuditEntry)
	case "OrgInviteMemberAuditEntry":
		base.Value = new(OrgInviteMemberAuditEntry)
	case "OrgInviteToBusinessAuditEntry":
		base.Value = new(OrgInviteToBusinessAuditEntry)
	case "OrgOauthAppAccessApprovedAuditEntry":
		base.Value = new(OrgOauthAppAccessApprovedAuditEntry)
	case "OrgOauthAppAccessBlockedAuditEntry":
		base.Value = new(OrgOauthAppAccessBlockedAuditEntry)
	case "OrgOauthAppAccessDeniedAuditEntry":
		base.Value = new(OrgOauthAppAccessDeniedAuditEntry)
	case "OrgOauthAppAccessRequestedAuditEntry":
		base.Value = new(OrgOauthAppAccessRequestedAuditEntry)
	case "OrgOauthAppAccessUnblockedAuditEntry":
		base.Value = new(OrgOauthAppAccessUnblockedAuditEntry)
	case "OrgRemoveBillingManagerAuditEntry":
		base.Value = new(OrgRemoveBillingManagerAuditEntry)
	case "OrgRemoveMemberAuditEntry":
		base.Value = new(OrgRemoveMemberAuditEntry)
	case "OrgRemoveOutsideCollaboratorAuditEntry":
		base.Value = new(OrgRemoveOutsideCollaboratorAuditEntry)
	case "OrgRestoreMemberAuditEntry":
		base.Value = new(OrgRestoreMemberAuditEntry)
	case "OrgRestoreMemberMembershipOrganizationAuditEntryData":
		base.Value = new(OrgRestoreMemberMembershipOrganizationAuditEntryData)
	case "OrgUnblockUserAuditEntry":
		base.Value = new(OrgUnblockUserAuditEntry)
	case "OrgUpdateDefaultRepositoryPermissionAuditEntry":
		base.Value = new(OrgUpdateDefaultRepositoryPermissionAuditEntry)
	case "OrgUpdateMemberAuditEntry":
		base.Value = new(OrgUpdateMemberAuditEntry)
	case "OrgUpdateMemberRepositoryCreationPermissionAuditEntry":
		base.Value = new(OrgUpdateMemberRepositoryCreationPermissionAuditEntry)
	case "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry":
		base.Value = new(OrgUpdateMemberRepositoryInvitationPermissionAuditEntry)
	case "PrivateRepositoryForkingDisableAuditEntry":
		base.Value = new(PrivateRepositoryForkingDisableAuditEntry)
	case "PrivateRepositoryForkingEnableAuditEntry":
		base.Value = new(PrivateRepositoryForkingEnableAuditEntry)
	case "RepoAccessAuditEntry":
		base.Value = new(RepoAccessAuditEntry)
	case "RepoAddMemberAuditEntry":
		base.Value = new(RepoAddMemberAuditEntry)
	case "RepoAddTopicAuditEntry":
		base.Value = new(RepoAddTopicAuditEntry)
	case "RepoArchivedAuditEntry":
		base.Value = new(RepoArchivedAuditEntry)
	case "RepoChangeMergeSettingAuditEntry":
		base.Value = new(RepoChangeMergeSettingAuditEntry)
	case "RepoConfigDisableAnonymousGitAccessAuditEntry":
		base.Value = new(RepoConfigDisableAnonymousGitAccessAuditEntry)
	case "RepoConfigDisableCollaboratorsOnlyAuditEntry":
		base.Value = new(RepoConfigDisableCollaboratorsOnlyAuditEntry)
	case "RepoConfigDisableContributorsOnlyAuditEntry":
		base.Value = new(RepoConfigDisableContributorsOnlyAuditEntry)
	case "RepoConfigDisableSockpuppetDisallowedAuditEntry":
		base.Value = new(RepoConfigDisableSockpuppetDisallowedAuditEntry)
	case "RepoConfigEnableAnonymousGitAccessAuditEntry":
		base.Value = new(RepoConfigEnableAnonymousGitAccessAuditEntry)
	case "RepoConfigEnableCollaboratorsOnlyAuditEntry":
		base.Value = new(RepoConfigEnableCollaboratorsOnlyAuditEntry)
	case "RepoConfigEnableContributorsOnlyAuditEntry":
		base.Value = new(RepoConfigEnableContributorsOnlyAuditEntry)
	case "RepoConfigEnableSockpuppetDisallowedAuditEntry":
		base.Value = new(RepoConfigEnableSockpuppetDisallowedAuditEntry)
	case "RepoConfigLockAnonymousGitAccessAuditEntry":
		base.Value = new(RepoConfigLockAnonymousGitAccessAuditEntry)
	case "RepoConfigUnlockAnonymousGitAccessAuditEntry":
		base.Value = new(RepoConfigUnlockAnonymousGitAccessAuditEntry)
	case "RepoCreateAuditEntry":
		base.Value = new(RepoCreateAuditEntry)
	case "RepoDestroyAuditEntry":
		base.Value = new(RepoDestroyAuditEntry)
	case "RepoRemoveMemberAuditEntry":
		base.Value = new(RepoRemoveMemberAuditEntry)
	case "RepoRemoveTopicAuditEntry":
		base.Value = new(RepoRemoveTopicAuditEntry)
	case "RepositoryVisibilityChangeDisableAuditEntry":
		base.Value = new(RepositoryVisibilityChangeDisableAuditEntry)
	case "RepositoryVisibilityChangeEnableAuditEntry":
		base.Value = new(RepositoryVisibilityChangeEnableAuditEntry)
	case "TeamAddMemberAuditEntry":
		base.Value = new(TeamAddMemberAuditEntry)
	case "TeamAddRepositoryAuditEntry":
		base.Value = new(TeamAddRepositoryAuditEntry)
	case "TeamChangeParentTeamAuditEntry":
		base.Value = new(TeamChangeParentTeamAuditEntry)
	case "TeamRemoveMemberAuditEntry":
		base.Value = new(TeamRemoveMemberAuditEntry)
	case "TeamRemoveRepositoryAuditEntry":
		base.Value = new(TeamRemoveRepositoryAuditEntry)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface OrganizationAuditEntryData: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// OrganizationAuditEntryDataValue is one of: MembersCanDeleteReposClearAuditEntry | MembersCanDeleteReposDisableAuditEntry | MembersCanDeleteReposEnableAuditEntry | OauthApplicationCreateAuditEntry | OrgAddBillingManagerAuditEntry | OrgAddMemberAuditEntry | OrgBlockUserAuditEntry | OrgConfigDisableCollaboratorsOnlyAuditEntry | OrgConfigEnableCollaboratorsOnlyAuditEntry | OrgCreateAuditEntry | OrgDisableOauthAppRestrictionsAuditEntry | OrgDisableSamlAuditEntry | OrgDisableTwoFactorRequirementAuditEntry | OrgEnableOauthAppRestrictionsAuditEntry | OrgEnableSamlAuditEntry | OrgEnableTwoFactorRequirementAuditEntry | OrgInviteMemberAuditEntry | OrgInviteToBusinessAuditEntry | OrgOauthAppAccessApprovedAuditEntry | OrgOauthAppAccessBlockedAuditEntry | OrgOauthAppAccessDeniedAuditEntry | OrgOauthAppAccessRequestedAuditEntry | OrgOauthAppAccessUnblockedAuditEntry | OrgRemoveBillingManagerAuditEntry | OrgRemoveMemberAuditEntry | OrgRemoveOutsideCollaboratorAuditEntry | OrgRestoreMemberAuditEntry | OrgRestoreMemberMembershipOrganizationAuditEntryData | OrgUnblockUserAuditEntry | OrgUpdateDefaultRepositoryPermissionAuditEntry | OrgUpdateMemberAuditEntry | OrgUpdateMemberRepositoryCreationPermissionAuditEntry | OrgUpdateMemberRepositoryInvitationPermissionAuditEntry | PrivateRepositoryForkingDisableAuditEntry | PrivateRepositoryForkingEnableAuditEntry | RepoAccessAuditEntry | RepoAddMemberAuditEntry | RepoAddTopicAuditEntry | RepoArchivedAuditEntry | RepoChangeMergeSettingAuditEntry | RepoConfigDisableAnonymousGitAccessAuditEntry | RepoConfigDisableCollaboratorsOnlyAuditEntry | RepoConfigDisableContributorsOnlyAuditEntry | RepoConfigDisableSockpuppetDisallowedAuditEntry | RepoConfigEnableAnonymousGitAccessAuditEntry | RepoConfigEnableCollaboratorsOnlyAuditEntry | RepoConfigEnableContributorsOnlyAuditEntry | RepoConfigEnableSockpuppetDisallowedAuditEntry | RepoConfigLockAnonymousGitAccessAuditEntry | RepoConfigUnlockAnonymousGitAccessAuditEntry | RepoCreateAuditEntry | RepoDestroyAuditEntry | RepoRemoveMemberAuditEntry | RepoRemoveTopicAuditEntry | RepositoryVisibilityChangeDisableAuditEntry | RepositoryVisibilityChangeEnableAuditEntry | TeamAddMemberAuditEntry | TeamAddRepositoryAuditEntry | TeamChangeParentTeamAuditEntry | TeamRemoveMemberAuditEntry | TeamRemoveRepositoryAuditEntry
type OrganizationAuditEntryDataValue interface {
	isOrganizationAuditEntryData()
}

// An edge in a connection.
type OrganizationAuditEntryEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *OrganizationAuditEntry `json:"node,omitempty"`
}

// A list of organizations managed by an enterprise.
type OrganizationConnection struct {
	// A list of edges.
	Edges []*OrganizationEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*Organization `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type OrganizationEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *Organization `json:"node,omitempty"`
}

// The connection type for User.
type OrganizationEnterpriseOwnerConnection struct {
	// A list of edges.
	Edges []*OrganizationEnterpriseOwnerEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*User `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An enterprise owner in the context of an organization that is part of the enterprise.
type OrganizationEnterpriseOwnerEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *User `json:"node,omitempty"`
	// The role of the owner with respect to the organization.
	OrganizationRole RoleInOrganization `json:"organizationRole"`
}

// An Identity Provider configured to provision SAML and SCIM identities for
// Organizations. Visible to (1) organization owners, (2) organization owners'
// personal access tokens (classic) with read:org or admin:org scope, (3) GitHub
// App with an installation token with read or write access to members.
type OrganizationIdentityProvider struct {
	// The digest algorithm used to sign SAML requests for the Identity Provider.
	DigestMethod *URI `json:"digestMethod,omitempty"`
	// External Identities provisioned by this Identity Provider
	ExternalIdentities *ExternalIdentityConnection `json:"externalIdentities"`
	// The Node ID of the OrganizationIdentityProvider object
	Id string `json:"id"`
	// The x509 certificate used by the Identity Provider to sign assertions and responses.
	IdpCertificate *X509Certificate `json:"idpCertificate,omitempty"`
	// The Issuer Entity ID for the SAML Identity Provider
	Issuer *string `json:"issuer,omitempty"`
	// Organization this Identity Provider belongs to
	Organization *Organization `json:"organization,omitempty"`
	// The signature algorithm used to sign SAML requests for the Identity Provider.
	SignatureMethod *URI `json:"signatureMethod,omitempty"`
	// The URL endpoint for the Identity Provider's SAML SSO.
	SsoUrl *URI `json:"ssoUrl,omitempty"`
}

func (*OrganizationIdentityProvider) isNode() {}

// An Invitation for a user to an organization.
type OrganizationInvitation struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The email address of the user invited to the organization.
	Email *string `json:"email,omitempty"`
	// The Node ID of the OrganizationInvitation object
	Id string `json:"id"`
	// The source of the invitation.
	InvitationSource OrganizationInvitationSource `json:"invitationSource"`
	// The type of invitation that was sent (e.g. email, user).
	InvitationType OrganizationInvitationType `json:"invitationType"`
	// The user who was invited to the organization.
	Invitee *User `json:"invitee,omitempty"`
	// The user who created the invitation.
	Inviter *User `json:"inviter"`
	// The user who created the invitation.
	InviterActor *User `json:"inviterActor,omitempty"`
	// The organization the invite is for
	Organization *Organization `json:"organization"`
	// The user's pending role in the organization (e.g. member, owner).
	Role OrganizationInvitationRole `json:"role"`
}

func (*OrganizationInvitation) isNode() {}

// The connection type for OrganizationInvitation.
type OrganizationInvitationConnection struct {
	// A list of edges.
	Edges []*OrganizationInvitationEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*OrganizationInvitation `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type OrganizationInvitationEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *OrganizationInvitation `json:"node,omitempty"`
}

// The possible organization invitation roles.
type OrganizationInvitationRole string

const (
	// The user is invited to be an admin of the organization.
	OrganizationInvitationRoleAdmin OrganizationInvitationRole = "ADMIN"
	// The user is invited to be a billing manager of the organization.
	OrganizationInvitationRoleBillingManager OrganizationInvitationRole = "BILLING_MANAGER"
	// The user is invited to be a direct member of the organization.
	OrganizationInvitationRoleDirectMember OrganizationInvitationRole = "DIRECT_MEMBER"
	// The user's previous role will be reinstated.
	OrganizationInvitationRoleReinstate OrganizationInvitationRole = "REINSTATE"
)

// The possible organization invitation sources.
type OrganizationInvitationSource string

const (
	// The invitation was created from the web interface or from API
	OrganizationInvitationSourceMember OrganizationInvitationSource = "MEMBER"
	// The invitation was created from SCIM
	OrganizationInvitationSourceScim OrganizationInvitationSource = "SCIM"
	// The invitation was sent before this feature was added
	OrganizationInvitationSourceUnknown OrganizationInvitationSource = "UNKNOWN"
)

// The possible organization invitation types.
type OrganizationInvitationType string

const (
	// The invitation was to an email address.
	OrganizationInvitationTypeEmail OrganizationInvitationType = "EMAIL"
	// The invitation was to an existing user.
	OrganizationInvitationTypeUser OrganizationInvitationType = "USER"
)

// A list of users who belong to the organization.
type OrganizationMemberConnection struct {
	// A list of edges.
	Edges []*OrganizationMemberEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*User `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// Represents a user within an organization.
type OrganizationMemberEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// Whether the organization member has two factor enabled or not. Returns null if information is not available to viewer.
	HasTwoFactorEnabled *bool `json:"hasTwoFactorEnabled,omitempty"`
	// The item at the end of the edge.
	Node *User `json:"node,omitempty"`
	// The role this user has in the organization.
	Role *OrganizationMemberRole `json:"role,omitempty"`
}

// The possible roles within an organization for its members.
type OrganizationMemberRole string

const (
	// The user is an administrator of the organization.
	OrganizationMemberRoleAdmin OrganizationMemberRole = "ADMIN"
	// The user is a member of the organization.
	OrganizationMemberRoleMember OrganizationMemberRole = "MEMBER"
)

// The possible values for the members can create repositories setting on an organization.
type OrganizationMembersCanCreateRepositoriesSettingValue string

const (
	// Members will be able to create public and private repositories.
	OrganizationMembersCanCreateRepositoriesSettingValueAll OrganizationMembersCanCreateRepositoriesSettingValue = "ALL"
	// Members will not be able to create public or private repositories.
	OrganizationMembersCanCreateRepositoriesSettingValueDisabled OrganizationMembersCanCreateRepositoriesSettingValue = "DISABLED"
	// Members will be able to create only internal repositories.
	OrganizationMembersCanCreateRepositoriesSettingValueInternal OrganizationMembersCanCreateRepositoriesSettingValue = "INTERNAL"
	// Members will be able to create only private repositories.
	OrganizationMembersCanCreateRepositoriesSettingValuePrivate OrganizationMembersCanCreateRepositoriesSettingValue = "PRIVATE"
)

// A GitHub Enterprise Importer (GEI) organization migration.
type OrganizationMigration struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *string `json:"databaseId,omitempty"`
	// The reason the organization migration failed.
	FailureReason *string `json:"failureReason,omitempty"`
	// The Node ID of the OrganizationMigration object
	Id string `json:"id"`
	// The remaining amount of repos to be migrated.
	RemainingRepositoriesCount *int32 `json:"remainingRepositoriesCount,omitempty"`
	// The name of the source organization to be migrated.
	SourceOrgName string `json:"sourceOrgName"`
	// The URL of the source organization to migrate.
	SourceOrgUrl URI `json:"sourceOrgUrl"`
	// The migration state.
	State OrganizationMigrationState `json:"state"`
	// The name of the target organization.
	TargetOrgName string `json:"targetOrgName"`
	// The total amount of repositories to be migrated.
	TotalRepositoriesCount *int32 `json:"totalRepositoriesCount,omitempty"`
}

func (*OrganizationMigration) isNode() {}

// The Octoshift Organization migration state.
type OrganizationMigrationState string

const (
	// The Octoshift migration has failed.
	OrganizationMigrationStateFailed OrganizationMigrationState = "FAILED"
	// The Octoshift migration has invalid credentials.
	OrganizationMigrationStateFailedValidation OrganizationMigrationState = "FAILED_VALIDATION"
	// The Octoshift migration is in progress.
	OrganizationMigrationStateInProgress OrganizationMigrationState = "IN_PROGRESS"
	// The Octoshift migration has not started.
	OrganizationMigrationStateNotStarted OrganizationMigrationState = "NOT_STARTED"
	// The Octoshift migration needs to have its credentials validated.
	OrganizationMigrationStatePendingValidation OrganizationMigrationState = "PENDING_VALIDATION"
	// The Octoshift migration is performing post repository migrations.
	OrganizationMigrationStatePostRepoMigration OrganizationMigrationState = "POST_REPO_MIGRATION"
	// The Octoshift migration is performing pre repository migrations.
	OrganizationMigrationStatePreRepoMigration OrganizationMigrationState = "PRE_REPO_MIGRATION"
	// The Octoshift migration has been queued.
	OrganizationMigrationStateQueued OrganizationMigrationState = "QUEUED"
	// The Octoshift org migration is performing repository migrations.
	OrganizationMigrationStateRepoMigration OrganizationMigrationState = "REPO_MIGRATION"
	// The Octoshift migration has succeeded.
	OrganizationMigrationStateSucceeded OrganizationMigrationState = "SUCCEEDED"
)

// Used for argument of CreateProjectV2 mutation.
type OrganizationOrUser struct {
	// Underlying value of the GraphQL union
	Value OrganizationOrUserValue `json:"-"`
}

func (base *OrganizationOrUser) UnmarshalJSON(b []byte) error {
	type Raw OrganizationOrUser
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Organization":
		base.Value = new(Organization)
	case "User":
		base.Value = new(User)
	case "":
		return fmt.Errorf("gqlclient: union OrganizationOrUser: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union OrganizationOrUser: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// OrganizationOrUserValue is one of: Organization | User
type OrganizationOrUserValue interface {
	isOrganizationOrUser()
}

// Ordering options for organization connections.
type OrganizationOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order organizations by.
	Field OrganizationOrderField `json:"field"`
}

// Properties by which organization connections can be ordered.
type OrganizationOrderField string

const (
	// Order organizations by creation time
	OrganizationOrderFieldCreatedAt OrganizationOrderField = "CREATED_AT"
	// Order organizations by login
	OrganizationOrderFieldLogin OrganizationOrderField = "LOGIN"
)

// An organization teams hovercard context
type OrganizationTeamsHovercardContext struct {
	// A string describing this context
	Message string `json:"message"`
	// An octicon to accompany this context
	Octicon string `json:"octicon"`
	// Teams in this organization the user is a member of that are relevant
	RelevantTeams *TeamConnection `json:"relevantTeams"`
	// The path for the full team list for this user
	TeamsResourcePath URI `json:"teamsResourcePath"`
	// The URL for the full team list for this user
	TeamsUrl URI `json:"teamsUrl"`
	// The total number of teams the user is on in the organization
	TotalTeamCount int32 `json:"totalTeamCount"`
}

func (*OrganizationTeamsHovercardContext) isHovercardContext() {}

// An organization list hovercard context
type OrganizationsHovercardContext struct {
	// A string describing this context
	Message string `json:"message"`
	// An octicon to accompany this context
	Octicon string `json:"octicon"`
	// Organizations this user is a member of that are relevant
	RelevantOrganizations *OrganizationConnection `json:"relevantOrganizations"`
	// The total number of organizations this user is in
	TotalOrganizationCount int32 `json:"totalOrganizationCount"`
}

func (*OrganizationsHovercardContext) isHovercardContext() {}

// Information for an uploaded package.
type Package struct {
	// The Node ID of the Package object
	Id string `json:"id"`
	// Find the latest version for the package.
	LatestVersion *PackageVersion `json:"latestVersion,omitempty"`
	// Identifies the name of the package.
	Name string `json:"name"`
	// Identifies the type of the package.
	PackageType PackageType `json:"packageType"`
	// The repository this package belongs to.
	Repository *Repository `json:"repository,omitempty"`
	// Statistics about package activity.
	Statistics *PackageStatistics `json:"statistics,omitempty"`
	// Find package version by version string.
	Version *PackageVersion `json:"version,omitempty"`
	// list of versions for this package
	Versions *PackageVersionConnection `json:"versions"`
}

func (*Package) isNode() {}

// The connection type for Package.
type PackageConnection struct {
	// A list of edges.
	Edges []*PackageEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*Package `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type PackageEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *Package `json:"node,omitempty"`
}

// A file in a package version.
type PackageFile struct {
	// The Node ID of the PackageFile object
	Id string `json:"id"`
	// MD5 hash of the file.
	Md5 *string `json:"md5,omitempty"`
	// Name of the file.
	Name string `json:"name"`
	// The package version this file belongs to.
	PackageVersion *PackageVersion `json:"packageVersion,omitempty"`
	// SHA1 hash of the file.
	Sha1 *string `json:"sha1,omitempty"`
	// SHA256 hash of the file.
	Sha256 *string `json:"sha256,omitempty"`
	// Size of the file in bytes.
	Size *int32 `json:"size,omitempty"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// URL to download the asset.
	Url *URI `json:"url,omitempty"`
}

func (*PackageFile) isNode() {}

// The connection type for PackageFile.
type PackageFileConnection struct {
	// A list of edges.
	Edges []*PackageFileEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*PackageFile `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type PackageFileEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *PackageFile `json:"node,omitempty"`
}

// Ways in which lists of package files can be ordered upon return.
type PackageFileOrder struct {
	// The direction in which to order package files by the specified field.
	Direction *OrderDirection `json:"direction,omitempty"`
	// The field in which to order package files by.
	Field *PackageFileOrderField `json:"field,omitempty"`
}

// Properties by which package file connections can be ordered.
type PackageFileOrderField string

const (
	// Order package files by creation time
	PackageFileOrderFieldCreatedAt PackageFileOrderField = "CREATED_AT"
)

// Ways in which lists of packages can be ordered upon return.
type PackageOrder struct {
	// The direction in which to order packages by the specified field.
	Direction *OrderDirection `json:"direction,omitempty"`
	// The field in which to order packages by.
	Field *PackageOrderField `json:"field,omitempty"`
}

// Properties by which package connections can be ordered.
type PackageOrderField string

const (
	// Order packages by creation time
	PackageOrderFieldCreatedAt PackageOrderField = "CREATED_AT"
)

// Represents an owner of a package.
type PackageOwner struct {
	// The Node ID of the PackageOwner object
	Id string `json:"id"`
	// A list of packages under the owner.
	Packages *PackageConnection `json:"packages"`

	// Underlying value of the GraphQL interface
	Value PackageOwnerValue `json:"-"`
}

func (base *PackageOwner) UnmarshalJSON(b []byte) error {
	type Raw PackageOwner
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Organization":
		base.Value = new(Organization)
	case "Repository":
		base.Value = new(Repository)
	case "User":
		base.Value = new(User)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface PackageOwner: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// PackageOwnerValue is one of: Organization | Repository | User
type PackageOwnerValue interface {
	isPackageOwner()
}

// Represents a object that contains package activity statistics such as downloads.
type PackageStatistics struct {
	// Number of times the package was downloaded since it was created.
	DownloadsTotalCount int32 `json:"downloadsTotalCount"`
}

// A version tag contains the mapping between a tag name and a version.
type PackageTag struct {
	// The Node ID of the PackageTag object
	Id string `json:"id"`
	// Identifies the tag name of the version.
	Name string `json:"name"`
	// Version that the tag is associated with.
	Version *PackageVersion `json:"version,omitempty"`
}

func (*PackageTag) isNode() {}

// The possible types of a package.
type PackageType string

const (
	// A debian package.
	PackageTypeDebian PackageType = "DEBIAN"
	// A docker image.
	PackageTypeDocker PackageType = "DOCKER"
	// A maven package.
	PackageTypeMaven PackageType = "MAVEN"
	// An npm package.
	PackageTypeNpm PackageType = "NPM"
	// A nuget package.
	PackageTypeNuget PackageType = "NUGET"
	// A python package.
	PackageTypePypi PackageType = "PYPI"
	// A rubygems package.
	PackageTypeRubygems PackageType = "RUBYGEMS"
)

// Information about a specific package version.
type PackageVersion struct {
	// List of files associated with this package version
	Files *PackageFileConnection `json:"files"`
	// The Node ID of the PackageVersion object
	Id string `json:"id"`
	// The package associated with this version.
	Package *Package `json:"package,omitempty"`
	// The platform this version was built for.
	Platform *string `json:"platform,omitempty"`
	// Whether or not this version is a pre-release.
	PreRelease bool `json:"preRelease"`
	// The README of this package version.
	Readme *string `json:"readme,omitempty"`
	// The release associated with this package version.
	Release *Release `json:"release,omitempty"`
	// Statistics about package activity.
	Statistics *PackageVersionStatistics `json:"statistics,omitempty"`
	// The package version summary.
	Summary *string `json:"summary,omitempty"`
	// The version string.
	Version string `json:"version"`
}

func (*PackageVersion) isNode() {}

// The connection type for PackageVersion.
type PackageVersionConnection struct {
	// A list of edges.
	Edges []*PackageVersionEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*PackageVersion `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type PackageVersionEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *PackageVersion `json:"node,omitempty"`
}

// Ways in which lists of package versions can be ordered upon return.
type PackageVersionOrder struct {
	// The direction in which to order package versions by the specified field.
	Direction *OrderDirection `json:"direction,omitempty"`
	// The field in which to order package versions by.
	Field *PackageVersionOrderField `json:"field,omitempty"`
}

// Properties by which package version connections can be ordered.
type PackageVersionOrderField string

const (
	// Order package versions by creation time
	PackageVersionOrderFieldCreatedAt PackageVersionOrderField = "CREATED_AT"
)

// Represents a object that contains package version activity statistics such as downloads.
type PackageVersionStatistics struct {
	// Number of times the package was downloaded since it was created.
	DownloadsTotalCount int32 `json:"downloadsTotalCount"`
}

// Information about pagination in a connection.
type PageInfo struct {
	// When paginating forwards, the cursor to continue.
	EndCursor *string `json:"endCursor,omitempty"`
	// When paginating forwards, are there more items?
	HasNextPage bool `json:"hasNextPage"`
	// When paginating backwards, are there more items?
	HasPreviousPage bool `json:"hasPreviousPage"`
	// When paginating backwards, the cursor to continue.
	StartCursor *string `json:"startCursor,omitempty"`
}

// Represents a 'parent_issue_added' event on a given issue.
type ParentIssueAddedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the ParentIssueAddedEvent object
	Id string `json:"id"`
	// The parent issue added.
	Parent *Issue `json:"parent,omitempty"`
}

func (*ParentIssueAddedEvent) isIssueTimelineItems() {}

func (*ParentIssueAddedEvent) isNode() {}

func (*ParentIssueAddedEvent) isPullRequestTimelineItems() {}

// Represents a 'parent_issue_removed' event on a given issue.
type ParentIssueRemovedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the ParentIssueRemovedEvent object
	Id string `json:"id"`
	// The parent issue removed.
	Parent *Issue `json:"parent,omitempty"`
}

func (*ParentIssueRemovedEvent) isIssueTimelineItems() {}

func (*ParentIssueRemovedEvent) isNode() {}

func (*ParentIssueRemovedEvent) isPullRequestTimelineItems() {}

// The possible types of patch statuses.
type PatchStatus string

const (
	// The file was added. Git status 'A'.
	PatchStatusAdded PatchStatus = "ADDED"
	// The file's type was changed. Git status 'T'.
	PatchStatusChanged PatchStatus = "CHANGED"
	// The file was copied. Git status 'C'.
	PatchStatusCopied PatchStatus = "COPIED"
	// The file was deleted. Git status 'D'.
	PatchStatusDeleted PatchStatus = "DELETED"
	// The file's contents were changed. Git status 'M'.
	PatchStatusModified PatchStatus = "MODIFIED"
	// The file was renamed. Git status 'R'.
	PatchStatusRenamed PatchStatus = "RENAMED"
)

// Types that can grant permissions on a repository to a user
type PermissionGranter struct {
	// Underlying value of the GraphQL union
	Value PermissionGranterValue `json:"-"`
}

func (base *PermissionGranter) UnmarshalJSON(b []byte) error {
	type Raw PermissionGranter
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Organization":
		base.Value = new(Organization)
	case "Repository":
		base.Value = new(Repository)
	case "Team":
		base.Value = new(Team)
	case "":
		return fmt.Errorf("gqlclient: union PermissionGranter: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union PermissionGranter: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// PermissionGranterValue is one of: Organization | Repository | Team
type PermissionGranterValue interface {
	isPermissionGranter()
}

// A level of permission and source for a user's access to a repository.
type PermissionSource struct {
	// The organization the repository belongs to.
	Organization *Organization `json:"organization"`
	// The level of access this source has granted to the user.
	Permission DefaultRepositoryPermissionField `json:"permission"`
	// The name of the role this source has granted to the user.
	RoleName *string `json:"roleName,omitempty"`
	// The source of this permission.
	Source PermissionGranter `json:"source"`
}

// Autogenerated input type of PinEnvironment
type PinEnvironmentInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the environment to modify
	EnvironmentId string `json:"environmentId"`
	// The desired state of the environment. If true, environment will be pinned. If false, it will be unpinned.
	Pinned bool `json:"pinned"`
}

// Autogenerated return type of PinEnvironment.
type PinEnvironmentPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The environment that was pinned
	Environment *Environment `json:"environment,omitempty"`
	// The pinned environment if we pinned
	PinnedEnvironment *PinnedEnvironment `json:"pinnedEnvironment,omitempty"`
}

// Autogenerated input type of PinIssue
type PinIssueInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the issue to be pinned
	IssueId string `json:"issueId"`
}

// Autogenerated return type of PinIssue.
type PinIssuePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The issue that was pinned
	Issue *Issue `json:"issue,omitempty"`
}

// Types that can be pinned to a profile page.
type PinnableItem struct {
	// Underlying value of the GraphQL union
	Value PinnableItemValue `json:"-"`
}

func (base *PinnableItem) UnmarshalJSON(b []byte) error {
	type Raw PinnableItem
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Gist":
		base.Value = new(Gist)
	case "Repository":
		base.Value = new(Repository)
	case "":
		return fmt.Errorf("gqlclient: union PinnableItem: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union PinnableItem: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// PinnableItemValue is one of: Gist | Repository
type PinnableItemValue interface {
	isPinnableItem()
}

// The connection type for PinnableItem.
type PinnableItemConnection struct {
	// A list of edges.
	Edges []*PinnableItemEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*PinnableItem `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type PinnableItemEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *PinnableItem `json:"node,omitempty"`
}

// Represents items that can be pinned to a profile page or dashboard.
type PinnableItemType string

const (
	// A gist.
	PinnableItemTypeGist PinnableItemType = "GIST"
	// An issue.
	PinnableItemTypeIssue PinnableItemType = "ISSUE"
	// An organization.
	PinnableItemTypeOrganization PinnableItemType = "ORGANIZATION"
	// A project.
	PinnableItemTypeProject PinnableItemType = "PROJECT"
	// A pull request.
	PinnableItemTypePullRequest PinnableItemType = "PULL_REQUEST"
	// A repository.
	PinnableItemTypeRepository PinnableItemType = "REPOSITORY"
	// A team.
	PinnableItemTypeTeam PinnableItemType = "TEAM"
	// A user.
	PinnableItemTypeUser PinnableItemType = "USER"
)

// A Pinned Discussion is a discussion pinned to a repository's index page.
type PinnedDiscussion struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The discussion that was pinned.
	Discussion *Discussion `json:"discussion"`
	// Color stops of the chosen gradient
	GradientStopColors []string `json:"gradientStopColors"`
	// The Node ID of the PinnedDiscussion object
	Id string `json:"id"`
	// Background texture pattern
	Pattern PinnedDiscussionPattern `json:"pattern"`
	// The actor that pinned this discussion.
	PinnedBy *Actor `json:"pinnedBy"`
	// Preconfigured background gradient option
	PreconfiguredGradient *PinnedDiscussionGradient `json:"preconfiguredGradient,omitempty"`
	// The repository associated with this node.
	Repository *Repository `json:"repository"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
}

func (*PinnedDiscussion) isNode() {}

func (*PinnedDiscussion) isRepositoryNode() {}

// The connection type for PinnedDiscussion.
type PinnedDiscussionConnection struct {
	// A list of edges.
	Edges []*PinnedDiscussionEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*PinnedDiscussion `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type PinnedDiscussionEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *PinnedDiscussion `json:"node,omitempty"`
}

// Preconfigured gradients that may be used to style discussions pinned within a repository.
type PinnedDiscussionGradient string

const (
	// A gradient of blue to mint
	PinnedDiscussionGradientBlueMint PinnedDiscussionGradient = "BLUE_MINT"
	// A gradient of blue to purple
	PinnedDiscussionGradientBluePurple PinnedDiscussionGradient = "BLUE_PURPLE"
	// A gradient of pink to blue
	PinnedDiscussionGradientPinkBlue PinnedDiscussionGradient = "PINK_BLUE"
	// A gradient of purple to coral
	PinnedDiscussionGradientPurpleCoral PinnedDiscussionGradient = "PURPLE_CORAL"
	// A gradient of red to orange
	PinnedDiscussionGradientRedOrange PinnedDiscussionGradient = "RED_ORANGE"
)

// Preconfigured background patterns that may be used to style discussions pinned within a repository.
type PinnedDiscussionPattern string

const (
	// An upward-facing chevron pattern
	PinnedDiscussionPatternChevronUp PinnedDiscussionPattern = "CHEVRON_UP"
	// A hollow dot pattern
	PinnedDiscussionPatternDot PinnedDiscussionPattern = "DOT"
	// A solid dot pattern
	PinnedDiscussionPatternDotFill PinnedDiscussionPattern = "DOT_FILL"
	// A heart pattern
	PinnedDiscussionPatternHeartFill PinnedDiscussionPattern = "HEART_FILL"
	// A plus sign pattern
	PinnedDiscussionPatternPlus PinnedDiscussionPattern = "PLUS"
	// A lightning bolt pattern
	PinnedDiscussionPatternZap PinnedDiscussionPattern = "ZAP"
)

// Represents a pinned environment on a given repository
type PinnedEnvironment struct {
	// Identifies the date and time when the pinned environment was created
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// Identifies the environment associated.
	Environment *Environment `json:"environment"`
	// The Node ID of the PinnedEnvironment object
	Id string `json:"id"`
	// Identifies the position of the pinned environment.
	Position int32 `json:"position"`
	// The repository that this environment was pinned to.
	Repository *Repository `json:"repository"`
}

func (*PinnedEnvironment) isNode() {}

// The connection type for PinnedEnvironment.
type PinnedEnvironmentConnection struct {
	// A list of edges.
	Edges []*PinnedEnvironmentEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*PinnedEnvironment `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type PinnedEnvironmentEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *PinnedEnvironment `json:"node,omitempty"`
}

// Ordering options for pinned environments
type PinnedEnvironmentOrder struct {
	// The direction in which to order pinned environments by the specified field.
	Direction OrderDirection `json:"direction"`
	// The field to order pinned environments by.
	Field PinnedEnvironmentOrderField `json:"field"`
}

// Properties by which pinned environments connections can be ordered
type PinnedEnvironmentOrderField string

const (
	// Order pinned environments by position
	PinnedEnvironmentOrderFieldPosition PinnedEnvironmentOrderField = "POSITION"
)

// Represents a 'pinned' event on a given issue or pull request.
type PinnedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the PinnedEvent object
	Id string `json:"id"`
	// Identifies the issue associated with the event.
	Issue *Issue `json:"issue"`
}

func (*PinnedEvent) isIssueTimelineItems() {}

func (*PinnedEvent) isNode() {}

func (*PinnedEvent) isPullRequestTimelineItems() {}

// A Pinned Issue is a issue pinned to a repository's index page.
type PinnedIssue struct {
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// Identifies the primary key from the database as a BigInt.
	FullDatabaseId *BigInt `json:"fullDatabaseId,omitempty"`
	// The Node ID of the PinnedIssue object
	Id string `json:"id"`
	// The issue that was pinned.
	Issue *Issue `json:"issue"`
	// The actor that pinned this issue.
	PinnedBy *Actor `json:"pinnedBy"`
	// The repository that this issue was pinned to.
	Repository *Repository `json:"repository"`
}

func (*PinnedIssue) isNode() {}

// The connection type for PinnedIssue.
type PinnedIssueConnection struct {
	// A list of edges.
	Edges []*PinnedIssueEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*PinnedIssue `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type PinnedIssueEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *PinnedIssue `json:"node,omitempty"`
}

// An ISO-8601 encoded UTC date string with millisecond precision.
type PreciseDateTime string

// Audit log entry for a private_repository_forking.disable event.
type PrivateRepositoryForkingDisableAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The HTTP path for this enterprise.
	EnterpriseResourcePath *URI `json:"enterpriseResourcePath,omitempty"`
	// The slug of the enterprise.
	EnterpriseSlug *string `json:"enterpriseSlug,omitempty"`
	// The HTTP URL for this enterprise.
	EnterpriseUrl *URI `json:"enterpriseUrl,omitempty"`
	// The Node ID of the PrivateRepositoryForkingDisableAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The repository associated with the action
	Repository *Repository `json:"repository,omitempty"`
	// The name of the repository
	RepositoryName *string `json:"repositoryName,omitempty"`
	// The HTTP path for the repository
	RepositoryResourcePath *URI `json:"repositoryResourcePath,omitempty"`
	// The HTTP URL for the repository
	RepositoryUrl *URI `json:"repositoryUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*PrivateRepositoryForkingDisableAuditEntry) isOrganizationAuditEntry() {}

func (*PrivateRepositoryForkingDisableAuditEntry) isAuditEntry() {}

func (*PrivateRepositoryForkingDisableAuditEntry) isEnterpriseAuditEntryData() {}

func (*PrivateRepositoryForkingDisableAuditEntry) isNode() {}

func (*PrivateRepositoryForkingDisableAuditEntry) isOrganizationAuditEntryData() {}

func (*PrivateRepositoryForkingDisableAuditEntry) isRepositoryAuditEntryData() {}

// Audit log entry for a private_repository_forking.enable event.
type PrivateRepositoryForkingEnableAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The HTTP path for this enterprise.
	EnterpriseResourcePath *URI `json:"enterpriseResourcePath,omitempty"`
	// The slug of the enterprise.
	EnterpriseSlug *string `json:"enterpriseSlug,omitempty"`
	// The HTTP URL for this enterprise.
	EnterpriseUrl *URI `json:"enterpriseUrl,omitempty"`
	// The Node ID of the PrivateRepositoryForkingEnableAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The repository associated with the action
	Repository *Repository `json:"repository,omitempty"`
	// The name of the repository
	RepositoryName *string `json:"repositoryName,omitempty"`
	// The HTTP path for the repository
	RepositoryResourcePath *URI `json:"repositoryResourcePath,omitempty"`
	// The HTTP URL for the repository
	RepositoryUrl *URI `json:"repositoryUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*PrivateRepositoryForkingEnableAuditEntry) isOrganizationAuditEntry() {}

func (*PrivateRepositoryForkingEnableAuditEntry) isAuditEntry() {}

func (*PrivateRepositoryForkingEnableAuditEntry) isEnterpriseAuditEntryData() {}

func (*PrivateRepositoryForkingEnableAuditEntry) isNode() {}

func (*PrivateRepositoryForkingEnableAuditEntry) isOrganizationAuditEntryData() {}

func (*PrivateRepositoryForkingEnableAuditEntry) isRepositoryAuditEntryData() {}

// A curatable list of repositories relating to a repository owner, which defaults
// to showing the most popular repositories they own.
type ProfileItemShowcase struct {
	// Whether or not the owner has pinned any repositories or gists.
	HasPinnedItems bool `json:"hasPinnedItems"`
	// The repositories and gists in the showcase. If the profile owner has any
	// pinned items, those will be returned. Otherwise, the profile owner's popular
	// repositories will be returned.
	Items *PinnableItemConnection `json:"items"`
}

// Represents any entity on GitHub that has a profile page.
type ProfileOwner struct {
	// Determine if this repository owner has any items that can be pinned to their profile.
	AnyPinnableItems bool `json:"anyPinnableItems"`
	// The public profile email.
	Email *string `json:"email,omitempty"`
	// The Node ID of the ProfileOwner object
	Id string `json:"id"`
	// Showcases a selection of repositories and gists that the profile owner has
	// either curated or that have been selected automatically based on popularity.
	ItemShowcase *ProfileItemShowcase `json:"itemShowcase"`
	// The public profile location.
	Location *string `json:"location,omitempty"`
	// The username used to login.
	Login string `json:"login"`
	// The public profile name.
	Name *string `json:"name,omitempty"`
	// A list of repositories and gists this profile owner can pin to their profile.
	PinnableItems *PinnableItemConnection `json:"pinnableItems"`
	// A list of repositories and gists this profile owner has pinned to their profile
	PinnedItems *PinnableItemConnection `json:"pinnedItems"`
	// Returns how many more items this profile owner can pin to their profile.
	PinnedItemsRemaining int32 `json:"pinnedItemsRemaining"`
	// Can the viewer pin repositories and gists to the profile?
	ViewerCanChangePinnedItems bool `json:"viewerCanChangePinnedItems"`
	// The public profile website URL.
	WebsiteUrl *URI `json:"websiteUrl,omitempty"`

	// Underlying value of the GraphQL interface
	Value ProfileOwnerValue `json:"-"`
}

func (base *ProfileOwner) UnmarshalJSON(b []byte) error {
	type Raw ProfileOwner
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Organization":
		base.Value = new(Organization)
	case "User":
		base.Value = new(User)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface ProfileOwner: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// ProfileOwnerValue is one of: Organization | User
type ProfileOwnerValue interface {
	isProfileOwner()
}

// Projects manage issues, pull requests and notes within a project owner.
type Project struct {
	// The project's description body.
	Body *string `json:"body,omitempty"`
	// The projects description body rendered to HTML.
	BodyHTML HTML `json:"bodyHTML"`
	// Indicates if the object is closed (definition of closed may depend on type)
	Closed bool `json:"closed"`
	// Identifies the date and time when the object was closed.
	ClosedAt *DateTime `json:"closedAt,omitempty"`
	// List of columns in the project
	Columns *ProjectColumnConnection `json:"columns"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The actor who originally created the project.
	Creator *Actor `json:"creator,omitempty"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The Node ID of the Project object
	Id string `json:"id"`
	// The project's name.
	Name string `json:"name"`
	// The project's number.
	Number int32 `json:"number"`
	// The project's owner. Currently limited to repositories, organizations, and users.
	Owner *ProjectOwner `json:"owner"`
	// List of pending cards in this project
	PendingCards *ProjectCardConnection `json:"pendingCards"`
	// Project progress details.
	Progress *ProjectProgress `json:"progress"`
	// The HTTP path for this project
	ResourcePath URI `json:"resourcePath"`
	// Whether the project is open or closed.
	State ProjectState `json:"state"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The HTTP URL for this project
	Url URI `json:"url"`
	// Indicates if the object can be closed by the viewer.
	ViewerCanClose bool `json:"viewerCanClose"`
	// Indicates if the object can be reopened by the viewer.
	ViewerCanReopen bool `json:"viewerCanReopen"`
	// Check if the current viewer can update this object.
	ViewerCanUpdate bool `json:"viewerCanUpdate"`
}

func (*Project) isClosable() {}

func (*Project) isNode() {}

func (*Project) isUpdatable() {}

// A card in a project.
type ProjectCard struct {
	// The project column this card is associated under. A card may only belong to one
	// project column at a time. The column field will be null if the card is created
	// in a pending state and has yet to be associated with a column. Once cards are
	// associated with a column, they will not become pending in the future.
	Column *ProjectColumn `json:"column,omitempty"`
	// The card content item
	Content *ProjectCardItem `json:"content,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The actor who created this card
	Creator *Actor `json:"creator,omitempty"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The Node ID of the ProjectCard object
	Id string `json:"id"`
	// Whether the card is archived
	IsArchived bool `json:"isArchived"`
	// The card note
	Note *string `json:"note,omitempty"`
	// The project that contains this card.
	Project *Project `json:"project"`
	// The HTTP path for this card
	ResourcePath URI `json:"resourcePath"`
	// The state of ProjectCard
	State *ProjectCardState `json:"state,omitempty"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The HTTP URL for this card
	Url URI `json:"url"`
}

func (*ProjectCard) isNode() {}

// The possible archived states of a project card.
type ProjectCardArchivedState string

const (
	// A project card that is archived
	ProjectCardArchivedStateArchived ProjectCardArchivedState = "ARCHIVED"
	// A project card that is not archived
	ProjectCardArchivedStateNotArchived ProjectCardArchivedState = "NOT_ARCHIVED"
)

// The connection type for ProjectCard.
type ProjectCardConnection struct {
	// A list of edges.
	Edges []*ProjectCardEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*ProjectCard `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type ProjectCardEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *ProjectCard `json:"node,omitempty"`
}

// An issue or PR and its owning repository to be used in a project card.
type ProjectCardImport struct {
	// The issue or pull request number.
	Number int32 `json:"number"`
	// Repository name with owner (owner/repository).
	Repository string `json:"repository"`
}

// Types that can be inside Project Cards.
type ProjectCardItem struct {
	// Underlying value of the GraphQL union
	Value ProjectCardItemValue `json:"-"`
}

func (base *ProjectCardItem) UnmarshalJSON(b []byte) error {
	type Raw ProjectCardItem
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Issue":
		base.Value = new(Issue)
	case "PullRequest":
		base.Value = new(PullRequest)
	case "":
		return fmt.Errorf("gqlclient: union ProjectCardItem: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union ProjectCardItem: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// ProjectCardItemValue is one of: Issue | PullRequest
type ProjectCardItemValue interface {
	isProjectCardItem()
}

// Various content states of a ProjectCard
type ProjectCardState string

const (
	// The card has content only.
	ProjectCardStateContentOnly ProjectCardState = "CONTENT_ONLY"
	// The card has a note only.
	ProjectCardStateNoteOnly ProjectCardState = "NOTE_ONLY"
	// The card is redacted.
	ProjectCardStateRedacted ProjectCardState = "REDACTED"
)

// A column inside a project.
type ProjectColumn struct {
	// List of cards in the column
	Cards *ProjectCardConnection `json:"cards"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The Node ID of the ProjectColumn object
	Id string `json:"id"`
	// The project column's name.
	Name string `json:"name"`
	// The project that contains this column.
	Project *Project `json:"project"`
	// The semantic purpose of the column
	Purpose *ProjectColumnPurpose `json:"purpose,omitempty"`
	// The HTTP path for this project column
	ResourcePath URI `json:"resourcePath"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The HTTP URL for this project column
	Url URI `json:"url"`
}

func (*ProjectColumn) isNode() {}

// The connection type for ProjectColumn.
type ProjectColumnConnection struct {
	// A list of edges.
	Edges []*ProjectColumnEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*ProjectColumn `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type ProjectColumnEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *ProjectColumn `json:"node,omitempty"`
}

// A project column and a list of its issues and PRs.
type ProjectColumnImport struct {
	// The name of the column.
	ColumnName string `json:"columnName"`
	// A list of issues and pull requests in the column.
	Issues []ProjectCardImport `json:"issues,omitempty"`
	// The position of the column, starting from 0.
	Position int32 `json:"position"`
}

// The semantic purpose of the column - todo, in progress, or done.
type ProjectColumnPurpose string

const (
	// The column contains cards which are complete
	ProjectColumnPurposeDone ProjectColumnPurpose = "DONE"
	// The column contains cards which are currently being worked on
	ProjectColumnPurposeInProgress ProjectColumnPurpose = "IN_PROGRESS"
	// The column contains cards still to be worked on
	ProjectColumnPurposeTodo ProjectColumnPurpose = "TODO"
)

// A list of projects associated with the owner.
type ProjectConnection struct {
	// A list of edges.
	Edges []*ProjectEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*Project `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type ProjectEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *Project `json:"node,omitempty"`
}

// Ways in which lists of projects can be ordered upon return.
type ProjectOrder struct {
	// The direction in which to order projects by the specified field.
	Direction OrderDirection `json:"direction"`
	// The field in which to order projects by.
	Field ProjectOrderField `json:"field"`
}

// Properties by which project connections can be ordered.
type ProjectOrderField string

const (
	// Order projects by creation time
	ProjectOrderFieldCreatedAt ProjectOrderField = "CREATED_AT"
	// Order projects by name
	ProjectOrderFieldName ProjectOrderField = "NAME"
	// Order projects by update time
	ProjectOrderFieldUpdatedAt ProjectOrderField = "UPDATED_AT"
)

// Represents an owner of a Project.
type ProjectOwner struct {
	// The Node ID of the ProjectOwner object
	Id string `json:"id"`
	// Find project by number.
	Project *Project `json:"project,omitempty"`
	// A list of projects under the owner.
	Projects *ProjectConnection `json:"projects"`
	// The HTTP path listing owners projects
	ProjectsResourcePath URI `json:"projectsResourcePath"`
	// The HTTP URL listing owners projects
	ProjectsUrl URI `json:"projectsUrl"`
	// Can the current viewer create new projects on this owner.
	ViewerCanCreateProjects bool `json:"viewerCanCreateProjects"`

	// Underlying value of the GraphQL interface
	Value ProjectOwnerValue `json:"-"`
}

func (base *ProjectOwner) UnmarshalJSON(b []byte) error {
	type Raw ProjectOwner
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Organization":
		base.Value = new(Organization)
	case "Repository":
		base.Value = new(Repository)
	case "User":
		base.Value = new(User)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface ProjectOwner: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// ProjectOwnerValue is one of: Organization | Repository | User
type ProjectOwnerValue interface {
	isProjectOwner()
}

// Project progress stats.
type ProjectProgress struct {
	// The number of done cards.
	DoneCount int32 `json:"doneCount"`
	// The percentage of done cards.
	DonePercentage float64 `json:"donePercentage"`
	// Whether progress tracking is enabled and cards with purpose exist for this project
	Enabled bool `json:"enabled"`
	// The number of in-progress cards.
	InProgressCount int32 `json:"inProgressCount"`
	// The percentage of in-progress cards.
	InProgressPercentage float64 `json:"inProgressPercentage"`
	// The number of to do cards.
	TodoCount int32 `json:"todoCount"`
	// The percentage of to do cards.
	TodoPercentage float64 `json:"todoPercentage"`
}

// State of the project; either 'open' or 'closed'
type ProjectState string

const (
	// The project is closed.
	ProjectStateClosed ProjectState = "CLOSED"
	// The project is open.
	ProjectStateOpen ProjectState = "OPEN"
)

// GitHub-provided templates for Projects
type ProjectTemplate string

const (
	// Create a board with v2 triggers to automatically move cards across To do, In progress and Done columns.
	ProjectTemplateAutomatedKanbanV2 ProjectTemplate = "AUTOMATED_KANBAN_V2"
	// Create a board with triggers to automatically move cards across columns with review automation.
	ProjectTemplateAutomatedReviewsKanban ProjectTemplate = "AUTOMATED_REVIEWS_KANBAN"
	// Create a board with columns for To do, In progress and Done.
	ProjectTemplateBasicKanban ProjectTemplate = "BASIC_KANBAN"
	// Create a board to triage and prioritize bugs with To do, priority, and Done columns.
	ProjectTemplateBugTriage ProjectTemplate = "BUG_TRIAGE"
)

// New projects that manage issues, pull requests and drafts using tables and boards.
type ProjectV2 struct {
	// Returns true if the project is closed.
	Closed bool `json:"closed"`
	// Identifies the date and time when the object was closed.
	ClosedAt *DateTime `json:"closedAt,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The actor who originally created the project.
	Creator *Actor `json:"creator,omitempty"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// A field of the project
	Field *ProjectV2FieldConfiguration `json:"field,omitempty"`
	// List of fields and their constraints in the project
	Fields *ProjectV2FieldConfigurationConnection `json:"fields"`
	// Identifies the primary key from the database as a BigInt.
	FullDatabaseId *BigInt `json:"fullDatabaseId,omitempty"`
	// The Node ID of the ProjectV2 object
	Id string `json:"id"`
	// List of items in the project
	Items *ProjectV2ItemConnection `json:"items"`
	// The project's number.
	Number int32 `json:"number"`
	// The project's owner. Currently limited to organizations and users.
	Owner *ProjectV2Owner `json:"owner"`
	// Returns true if the project is public.
	Public bool `json:"public"`
	// The project's readme.
	Readme *string `json:"readme,omitempty"`
	// The repositories the project is linked to.
	Repositories *RepositoryConnection `json:"repositories"`
	// The HTTP path for this project
	ResourcePath URI `json:"resourcePath"`
	// The project's short description.
	ShortDescription *string `json:"shortDescription,omitempty"`
	// List of the status updates in the project.
	StatusUpdates *ProjectV2StatusUpdateConnection `json:"statusUpdates"`
	// The teams the project is linked to.
	Teams *TeamConnection `json:"teams"`
	// Returns true if this project is a template.
	Template bool `json:"template"`
	// The project's name.
	Title string `json:"title"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The HTTP URL for this project
	Url URI `json:"url"`
	// A view of the project
	View *ProjectV2View `json:"view,omitempty"`
	// Indicates if the object can be closed by the viewer.
	ViewerCanClose bool `json:"viewerCanClose"`
	// Indicates if the object can be reopened by the viewer.
	ViewerCanReopen bool `json:"viewerCanReopen"`
	// Check if the current viewer can update this object.
	ViewerCanUpdate bool `json:"viewerCanUpdate"`
	// List of views in the project
	Views *ProjectV2ViewConnection `json:"views"`
	// A workflow of the project
	Workflow *ProjectV2Workflow `json:"workflow,omitempty"`
	// List of the workflows in the project
	Workflows *ProjectV2WorkflowConnection `json:"workflows"`
}

func (*ProjectV2) isCloser() {}

func (*ProjectV2) isClosable() {}

func (*ProjectV2) isNode() {}

func (*ProjectV2) isUpdatable() {}

// Possible collaborators for a project.
type ProjectV2Actor struct {
	// Underlying value of the GraphQL union
	Value ProjectV2ActorValue `json:"-"`
}

func (base *ProjectV2Actor) UnmarshalJSON(b []byte) error {
	type Raw ProjectV2Actor
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Team":
		base.Value = new(Team)
	case "User":
		base.Value = new(User)
	case "":
		return fmt.Errorf("gqlclient: union ProjectV2Actor: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union ProjectV2Actor: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// ProjectV2ActorValue is one of: Team | User
type ProjectV2ActorValue interface {
	isProjectV2Actor()
}

// The connection type for ProjectV2Actor.
type ProjectV2ActorConnection struct {
	// A list of edges.
	Edges []*ProjectV2ActorEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*ProjectV2Actor `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type ProjectV2ActorEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *ProjectV2Actor `json:"node,omitempty"`
}

// A collaborator to update on a project. Only one of the userId or teamId should be provided.
type ProjectV2Collaborator struct {
	// The role to grant the collaborator
	Role ProjectV2Roles `json:"role"`
	// The ID of the team as a collaborator.
	TeamId string `json:"teamId,omitempty"`
	// The ID of the user as a collaborator.
	UserId string `json:"userId,omitempty"`
}

// The connection type for ProjectV2.
type ProjectV2Connection struct {
	// A list of edges.
	Edges []*ProjectV2Edge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*ProjectV2 `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// The type of a project field.
type ProjectV2CustomFieldType string

const (
	// Date
	ProjectV2CustomFieldTypeDate ProjectV2CustomFieldType = "DATE"
	// Iteration
	ProjectV2CustomFieldTypeIteration ProjectV2CustomFieldType = "ITERATION"
	// Number
	ProjectV2CustomFieldTypeNumber ProjectV2CustomFieldType = "NUMBER"
	// Single Select
	ProjectV2CustomFieldTypeSingleSelect ProjectV2CustomFieldType = "SINGLE_SELECT"
	// Text
	ProjectV2CustomFieldTypeText ProjectV2CustomFieldType = "TEXT"
)

// An edge in a connection.
type ProjectV2Edge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *ProjectV2 `json:"node,omitempty"`
}

// A field inside a project.
type ProjectV2Field struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The field's type.
	DataType ProjectV2FieldType `json:"dataType"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The Node ID of the ProjectV2Field object
	Id string `json:"id"`
	// The project field's name.
	Name string `json:"name"`
	// The project that contains this field.
	Project *ProjectV2 `json:"project"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
}

func (*ProjectV2Field) isNode() {}

func (*ProjectV2Field) isProjectV2FieldCommon() {}

func (*ProjectV2Field) isProjectV2FieldConfiguration() {}

// Common fields across different project field types
type ProjectV2FieldCommon struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The field's type.
	DataType ProjectV2FieldType `json:"dataType"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The Node ID of the ProjectV2FieldCommon object
	Id string `json:"id"`
	// The project field's name.
	Name string `json:"name"`
	// The project that contains this field.
	Project *ProjectV2 `json:"project"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`

	// Underlying value of the GraphQL interface
	Value ProjectV2FieldCommonValue `json:"-"`
}

func (base *ProjectV2FieldCommon) UnmarshalJSON(b []byte) error {
	type Raw ProjectV2FieldCommon
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "ProjectV2Field":
		base.Value = new(ProjectV2Field)
	case "ProjectV2IterationField":
		base.Value = new(ProjectV2IterationField)
	case "ProjectV2SingleSelectField":
		base.Value = new(ProjectV2SingleSelectField)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface ProjectV2FieldCommon: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// ProjectV2FieldCommonValue is one of: ProjectV2Field | ProjectV2IterationField | ProjectV2SingleSelectField
type ProjectV2FieldCommonValue interface {
	isProjectV2FieldCommon()
}

// Configurations for project fields.
type ProjectV2FieldConfiguration struct {
	// Underlying value of the GraphQL union
	Value ProjectV2FieldConfigurationValue `json:"-"`
}

func (base *ProjectV2FieldConfiguration) UnmarshalJSON(b []byte) error {
	type Raw ProjectV2FieldConfiguration
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "ProjectV2Field":
		base.Value = new(ProjectV2Field)
	case "ProjectV2IterationField":
		base.Value = new(ProjectV2IterationField)
	case "ProjectV2SingleSelectField":
		base.Value = new(ProjectV2SingleSelectField)
	case "":
		return fmt.Errorf("gqlclient: union ProjectV2FieldConfiguration: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union ProjectV2FieldConfiguration: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// ProjectV2FieldConfigurationValue is one of: ProjectV2Field | ProjectV2IterationField | ProjectV2SingleSelectField
type ProjectV2FieldConfigurationValue interface {
	isProjectV2FieldConfiguration()
}

// The connection type for ProjectV2FieldConfiguration.
type ProjectV2FieldConfigurationConnection struct {
	// A list of edges.
	Edges []*ProjectV2FieldConfigurationEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*ProjectV2FieldConfiguration `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type ProjectV2FieldConfigurationEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *ProjectV2FieldConfiguration `json:"node,omitempty"`
}

// The connection type for ProjectV2Field.
type ProjectV2FieldConnection struct {
	// A list of edges.
	Edges []*ProjectV2FieldEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*ProjectV2Field `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type ProjectV2FieldEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *ProjectV2Field `json:"node,omitempty"`
}

// Ordering options for project v2 field connections
type ProjectV2FieldOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order the project v2 fields by.
	Field ProjectV2FieldOrderField `json:"field"`
}

// Properties by which project v2 field connections can be ordered.
type ProjectV2FieldOrderField string

const (
	// Order project v2 fields by creation time
	ProjectV2FieldOrderFieldCreatedAt ProjectV2FieldOrderField = "CREATED_AT"
	// Order project v2 fields by name
	ProjectV2FieldOrderFieldName ProjectV2FieldOrderField = "NAME"
	// Order project v2 fields by position
	ProjectV2FieldOrderFieldPosition ProjectV2FieldOrderField = "POSITION"
)

// The type of a project field.
type ProjectV2FieldType string

const (
	// Assignees
	ProjectV2FieldTypeAssignees ProjectV2FieldType = "ASSIGNEES"
	// Date
	ProjectV2FieldTypeDate ProjectV2FieldType = "DATE"
	// Issue type
	ProjectV2FieldTypeIssueType ProjectV2FieldType = "ISSUE_TYPE"
	// Iteration
	ProjectV2FieldTypeIteration ProjectV2FieldType = "ITERATION"
	// Labels
	ProjectV2FieldTypeLabels ProjectV2FieldType = "LABELS"
	// Linked Pull Requests
	ProjectV2FieldTypeLinkedPullRequests ProjectV2FieldType = "LINKED_PULL_REQUESTS"
	// Milestone
	ProjectV2FieldTypeMilestone ProjectV2FieldType = "MILESTONE"
	// Number
	ProjectV2FieldTypeNumber ProjectV2FieldType = "NUMBER"
	// Parent issue
	ProjectV2FieldTypeParentIssue ProjectV2FieldType = "PARENT_ISSUE"
	// Repository
	ProjectV2FieldTypeRepository ProjectV2FieldType = "REPOSITORY"
	// Reviewers
	ProjectV2FieldTypeReviewers ProjectV2FieldType = "REVIEWERS"
	// Single Select
	ProjectV2FieldTypeSingleSelect ProjectV2FieldType = "SINGLE_SELECT"
	// Sub-issues progress
	ProjectV2FieldTypeSubIssuesProgress ProjectV2FieldType = "SUB_ISSUES_PROGRESS"
	// Text
	ProjectV2FieldTypeText ProjectV2FieldType = "TEXT"
	// Title
	ProjectV2FieldTypeTitle ProjectV2FieldType = "TITLE"
	// Tracked by
	ProjectV2FieldTypeTrackedBy ProjectV2FieldType = "TRACKED_BY"
	// Tracks
	ProjectV2FieldTypeTracks ProjectV2FieldType = "TRACKS"
)

// The values that can be used to update a field of an item inside a Project. Only 1 value can be updated at a time.
type ProjectV2FieldValue struct {
	// The ISO 8601 date to set on the field.
	Date *Date `json:"date,omitempty"`
	// The id of the iteration to set on the field.
	IterationId *string `json:"iterationId,omitempty"`
	// The number to set on the field.
	Number *float64 `json:"number,omitempty"`
	// The id of the single select option to set on the field.
	SingleSelectOptionId *string `json:"singleSelectOptionId,omitempty"`
	// The text to set on the field.
	Text *string `json:"text,omitempty"`
}

// Ways in which to filter lists of projects.
type ProjectV2Filters struct {
	// List project v2 filtered by the state given.
	State *ProjectV2State `json:"state,omitempty"`
}

// An item within a Project.
type ProjectV2Item struct {
	// The content of the referenced draft issue, issue, or pull request
	Content *ProjectV2ItemContent `json:"content,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The actor who created the item.
	Creator *Actor `json:"creator,omitempty"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The field value of the first project field which matches the 'name' argument that is set on the item.
	FieldValueByName *ProjectV2ItemFieldValue `json:"fieldValueByName,omitempty"`
	// The field values that are set on the item.
	FieldValues *ProjectV2ItemFieldValueConnection `json:"fieldValues"`
	// Identifies the primary key from the database as a BigInt.
	FullDatabaseId *BigInt `json:"fullDatabaseId,omitempty"`
	// The Node ID of the ProjectV2Item object
	Id string `json:"id"`
	// Whether the item is archived.
	IsArchived bool `json:"isArchived"`
	// The project that contains this item.
	Project *ProjectV2 `json:"project"`
	// The type of the item.
	Type ProjectV2ItemType `json:"type"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
}

func (*ProjectV2Item) isNode() {}

// The connection type for ProjectV2Item.
type ProjectV2ItemConnection struct {
	// A list of edges.
	Edges []*ProjectV2ItemEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*ProjectV2Item `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// Types that can be inside Project Items.
type ProjectV2ItemContent struct {
	// Underlying value of the GraphQL union
	Value ProjectV2ItemContentValue `json:"-"`
}

func (base *ProjectV2ItemContent) UnmarshalJSON(b []byte) error {
	type Raw ProjectV2ItemContent
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "DraftIssue":
		base.Value = new(DraftIssue)
	case "Issue":
		base.Value = new(Issue)
	case "PullRequest":
		base.Value = new(PullRequest)
	case "":
		return fmt.Errorf("gqlclient: union ProjectV2ItemContent: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union ProjectV2ItemContent: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// ProjectV2ItemContentValue is one of: DraftIssue | Issue | PullRequest
type ProjectV2ItemContentValue interface {
	isProjectV2ItemContent()
}

// An edge in a connection.
type ProjectV2ItemEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *ProjectV2Item `json:"node,omitempty"`
}

// The value of a date field in a Project item.
type ProjectV2ItemFieldDateValue struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The actor who created the item.
	Creator *Actor `json:"creator,omitempty"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// Date value for the field
	Date *Date `json:"date,omitempty"`
	// The project field that contains this value.
	Field ProjectV2FieldConfiguration `json:"field"`
	// The Node ID of the ProjectV2ItemFieldDateValue object
	Id string `json:"id"`
	// The project item that contains this value.
	Item *ProjectV2Item `json:"item"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
}

func (*ProjectV2ItemFieldDateValue) isNode() {}

func (*ProjectV2ItemFieldDateValue) isProjectV2ItemFieldValueCommon() {}

func (*ProjectV2ItemFieldDateValue) isProjectV2ItemFieldValue() {}

// The value of an iteration field in a Project item.
type ProjectV2ItemFieldIterationValue struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The actor who created the item.
	Creator *Actor `json:"creator,omitempty"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The duration of the iteration in days.
	Duration int32 `json:"duration"`
	// The project field that contains this value.
	Field ProjectV2FieldConfiguration `json:"field"`
	// The Node ID of the ProjectV2ItemFieldIterationValue object
	Id string `json:"id"`
	// The project item that contains this value.
	Item *ProjectV2Item `json:"item"`
	// The ID of the iteration.
	IterationId string `json:"iterationId"`
	// The start date of the iteration.
	StartDate Date `json:"startDate"`
	// The title of the iteration.
	Title string `json:"title"`
	// The title of the iteration, with HTML.
	TitleHTML string `json:"titleHTML"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
}

func (*ProjectV2ItemFieldIterationValue) isNode() {}

func (*ProjectV2ItemFieldIterationValue) isProjectV2ItemFieldValueCommon() {}

func (*ProjectV2ItemFieldIterationValue) isProjectV2ItemFieldValue() {}

// The value of the labels field in a Project item.
type ProjectV2ItemFieldLabelValue struct {
	// The field that contains this value.
	Field ProjectV2FieldConfiguration `json:"field"`
	// Labels value of a field
	Labels *LabelConnection `json:"labels,omitempty"`
}

func (*ProjectV2ItemFieldLabelValue) isProjectV2ItemFieldValue() {}

// The value of a milestone field in a Project item.
type ProjectV2ItemFieldMilestoneValue struct {
	// The field that contains this value.
	Field ProjectV2FieldConfiguration `json:"field"`
	// Milestone value of a field
	Milestone *Milestone `json:"milestone,omitempty"`
}

func (*ProjectV2ItemFieldMilestoneValue) isProjectV2ItemFieldValue() {}

// The value of a number field in a Project item.
type ProjectV2ItemFieldNumberValue struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The actor who created the item.
	Creator *Actor `json:"creator,omitempty"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The project field that contains this value.
	Field ProjectV2FieldConfiguration `json:"field"`
	// The Node ID of the ProjectV2ItemFieldNumberValue object
	Id string `json:"id"`
	// The project item that contains this value.
	Item *ProjectV2Item `json:"item"`
	// Number as a float(8)
	Number *float64 `json:"number,omitempty"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
}

func (*ProjectV2ItemFieldNumberValue) isNode() {}

func (*ProjectV2ItemFieldNumberValue) isProjectV2ItemFieldValueCommon() {}

func (*ProjectV2ItemFieldNumberValue) isProjectV2ItemFieldValue() {}

// The value of a pull request field in a Project item.
type ProjectV2ItemFieldPullRequestValue struct {
	// The field that contains this value.
	Field ProjectV2FieldConfiguration `json:"field"`
	// The pull requests for this field
	PullRequests *PullRequestConnection `json:"pullRequests,omitempty"`
}

func (*ProjectV2ItemFieldPullRequestValue) isProjectV2ItemFieldValue() {}

// The value of a repository field in a Project item.
type ProjectV2ItemFieldRepositoryValue struct {
	// The field that contains this value.
	Field ProjectV2FieldConfiguration `json:"field"`
	// The repository for this field.
	Repository *Repository `json:"repository,omitempty"`
}

func (*ProjectV2ItemFieldRepositoryValue) isProjectV2ItemFieldValue() {}

// The value of a reviewers field in a Project item.
type ProjectV2ItemFieldReviewerValue struct {
	// The field that contains this value.
	Field ProjectV2FieldConfiguration `json:"field"`
	// The reviewers for this field.
	Reviewers *RequestedReviewerConnection `json:"reviewers,omitempty"`
}

func (*ProjectV2ItemFieldReviewerValue) isProjectV2ItemFieldValue() {}

// The value of a single select field in a Project item.
type ProjectV2ItemFieldSingleSelectValue struct {
	// The color applied to the selected single-select option.
	Color ProjectV2SingleSelectFieldOptionColor `json:"color"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The actor who created the item.
	Creator *Actor `json:"creator,omitempty"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// A plain-text description of the selected single-select option, such as what the option means.
	Description *string `json:"description,omitempty"`
	// The description of the selected single-select option, including HTML tags.
	DescriptionHTML *string `json:"descriptionHTML,omitempty"`
	// The project field that contains this value.
	Field ProjectV2FieldConfiguration `json:"field"`
	// The Node ID of the ProjectV2ItemFieldSingleSelectValue object
	Id string `json:"id"`
	// The project item that contains this value.
	Item *ProjectV2Item `json:"item"`
	// The name of the selected single select option.
	Name *string `json:"name,omitempty"`
	// The html name of the selected single select option.
	NameHTML *string `json:"nameHTML,omitempty"`
	// The id of the selected single select option.
	OptionId *string `json:"optionId,omitempty"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
}

func (*ProjectV2ItemFieldSingleSelectValue) isNode() {}

func (*ProjectV2ItemFieldSingleSelectValue) isProjectV2ItemFieldValueCommon() {}

func (*ProjectV2ItemFieldSingleSelectValue) isProjectV2ItemFieldValue() {}

// The value of a text field in a Project item.
type ProjectV2ItemFieldTextValue struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The actor who created the item.
	Creator *Actor `json:"creator,omitempty"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The project field that contains this value.
	Field ProjectV2FieldConfiguration `json:"field"`
	// The Node ID of the ProjectV2ItemFieldTextValue object
	Id string `json:"id"`
	// The project item that contains this value.
	Item *ProjectV2Item `json:"item"`
	// Text value of a field
	Text *string `json:"text,omitempty"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
}

func (*ProjectV2ItemFieldTextValue) isNode() {}

func (*ProjectV2ItemFieldTextValue) isProjectV2ItemFieldValueCommon() {}

func (*ProjectV2ItemFieldTextValue) isProjectV2ItemFieldValue() {}

// The value of a user field in a Project item.
type ProjectV2ItemFieldUserValue struct {
	// The field that contains this value.
	Field ProjectV2FieldConfiguration `json:"field"`
	// The users for this field
	Users *UserConnection `json:"users,omitempty"`
}

func (*ProjectV2ItemFieldUserValue) isProjectV2ItemFieldValue() {}

// Project field values
type ProjectV2ItemFieldValue struct {
	// Underlying value of the GraphQL union
	Value ProjectV2ItemFieldValueValue `json:"-"`
}

func (base *ProjectV2ItemFieldValue) UnmarshalJSON(b []byte) error {
	type Raw ProjectV2ItemFieldValue
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "ProjectV2ItemFieldDateValue":
		base.Value = new(ProjectV2ItemFieldDateValue)
	case "ProjectV2ItemFieldIterationValue":
		base.Value = new(ProjectV2ItemFieldIterationValue)
	case "ProjectV2ItemFieldLabelValue":
		base.Value = new(ProjectV2ItemFieldLabelValue)
	case "ProjectV2ItemFieldMilestoneValue":
		base.Value = new(ProjectV2ItemFieldMilestoneValue)
	case "ProjectV2ItemFieldNumberValue":
		base.Value = new(ProjectV2ItemFieldNumberValue)
	case "ProjectV2ItemFieldPullRequestValue":
		base.Value = new(ProjectV2ItemFieldPullRequestValue)
	case "ProjectV2ItemFieldRepositoryValue":
		base.Value = new(ProjectV2ItemFieldRepositoryValue)
	case "ProjectV2ItemFieldReviewerValue":
		base.Value = new(ProjectV2ItemFieldReviewerValue)
	case "ProjectV2ItemFieldSingleSelectValue":
		base.Value = new(ProjectV2ItemFieldSingleSelectValue)
	case "ProjectV2ItemFieldTextValue":
		base.Value = new(ProjectV2ItemFieldTextValue)
	case "ProjectV2ItemFieldUserValue":
		base.Value = new(ProjectV2ItemFieldUserValue)
	case "":
		return fmt.Errorf("gqlclient: union ProjectV2ItemFieldValue: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union ProjectV2ItemFieldValue: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// ProjectV2ItemFieldValueValue is one of: ProjectV2ItemFieldDateValue | ProjectV2ItemFieldIterationValue | ProjectV2ItemFieldLabelValue | ProjectV2ItemFieldMilestoneValue | ProjectV2ItemFieldNumberValue | ProjectV2ItemFieldPullRequestValue | ProjectV2ItemFieldRepositoryValue | ProjectV2ItemFieldReviewerValue | ProjectV2ItemFieldSingleSelectValue | ProjectV2ItemFieldTextValue | ProjectV2ItemFieldUserValue
type ProjectV2ItemFieldValueValue interface {
	isProjectV2ItemFieldValue()
}

// Common fields across different project field value types
type ProjectV2ItemFieldValueCommon struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The actor who created the item.
	Creator *Actor `json:"creator,omitempty"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The project field that contains this value.
	Field ProjectV2FieldConfiguration `json:"field"`
	// The Node ID of the ProjectV2ItemFieldValueCommon object
	Id string `json:"id"`
	// The project item that contains this value.
	Item *ProjectV2Item `json:"item"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`

	// Underlying value of the GraphQL interface
	Value ProjectV2ItemFieldValueCommonValue `json:"-"`
}

func (base *ProjectV2ItemFieldValueCommon) UnmarshalJSON(b []byte) error {
	type Raw ProjectV2ItemFieldValueCommon
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "ProjectV2ItemFieldDateValue":
		base.Value = new(ProjectV2ItemFieldDateValue)
	case "ProjectV2ItemFieldIterationValue":
		base.Value = new(ProjectV2ItemFieldIterationValue)
	case "ProjectV2ItemFieldNumberValue":
		base.Value = new(ProjectV2ItemFieldNumberValue)
	case "ProjectV2ItemFieldSingleSelectValue":
		base.Value = new(ProjectV2ItemFieldSingleSelectValue)
	case "ProjectV2ItemFieldTextValue":
		base.Value = new(ProjectV2ItemFieldTextValue)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface ProjectV2ItemFieldValueCommon: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// ProjectV2ItemFieldValueCommonValue is one of: ProjectV2ItemFieldDateValue | ProjectV2ItemFieldIterationValue | ProjectV2ItemFieldNumberValue | ProjectV2ItemFieldSingleSelectValue | ProjectV2ItemFieldTextValue
type ProjectV2ItemFieldValueCommonValue interface {
	isProjectV2ItemFieldValueCommon()
}

// The connection type for ProjectV2ItemFieldValue.
type ProjectV2ItemFieldValueConnection struct {
	// A list of edges.
	Edges []*ProjectV2ItemFieldValueEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*ProjectV2ItemFieldValue `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type ProjectV2ItemFieldValueEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *ProjectV2ItemFieldValue `json:"node,omitempty"`
}

// Ordering options for project v2 item field value connections
type ProjectV2ItemFieldValueOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order the project v2 item field values by.
	Field ProjectV2ItemFieldValueOrderField `json:"field"`
}

// Properties by which project v2 item field value connections can be ordered.
type ProjectV2ItemFieldValueOrderField string

const (
	// Order project v2 item field values by the their position in the project
	ProjectV2ItemFieldValueOrderFieldPosition ProjectV2ItemFieldValueOrderField = "POSITION"
)

// Ordering options for project v2 item connections
type ProjectV2ItemOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order the project v2 items by.
	Field ProjectV2ItemOrderField `json:"field"`
}

// Properties by which project v2 item connections can be ordered.
type ProjectV2ItemOrderField string

const (
	// Order project v2 items by the their position in the project
	ProjectV2ItemOrderFieldPosition ProjectV2ItemOrderField = "POSITION"
)

// The type of a project item.
type ProjectV2ItemType string

const (
	// Draft Issue
	ProjectV2ItemTypeDraftIssue ProjectV2ItemType = "DRAFT_ISSUE"
	// Issue
	ProjectV2ItemTypeIssue ProjectV2ItemType = "ISSUE"
	// Pull Request
	ProjectV2ItemTypePullRequest ProjectV2ItemType = "PULL_REQUEST"
	// Redacted Item
	ProjectV2ItemTypeRedacted ProjectV2ItemType = "REDACTED"
)

// Represents an iteration
type ProjectV2Iteration struct {
	// The duration of the iteration, in days.
	Duration int32 `json:"duration"`
	// The start date for the iteration.
	StartDate Date `json:"startDate"`
	// The title for the iteration.
	Title string `json:"title"`
}

// An iteration field inside a project.
type ProjectV2IterationField struct {
	// Iteration configuration settings
	Configuration *ProjectV2IterationFieldConfiguration `json:"configuration"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The field's type.
	DataType ProjectV2FieldType `json:"dataType"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The Node ID of the ProjectV2IterationField object
	Id string `json:"id"`
	// The project field's name.
	Name string `json:"name"`
	// The project that contains this field.
	Project *ProjectV2 `json:"project"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
}

func (*ProjectV2IterationField) isProjectV2FieldConfiguration() {}

func (*ProjectV2IterationField) isNode() {}

func (*ProjectV2IterationField) isProjectV2FieldCommon() {}

// Iteration field configuration for a project.
type ProjectV2IterationFieldConfiguration struct {
	// The iteration's completed iterations
	CompletedIterations []ProjectV2IterationFieldIteration `json:"completedIterations"`
	// The iteration's duration in days
	Duration int32 `json:"duration"`
	// The iteration's iterations
	Iterations []ProjectV2IterationFieldIteration `json:"iterations"`
	// The iteration's start day of the week
	StartDay int32 `json:"startDay"`
}

// Represents an iteration field configuration.
type ProjectV2IterationFieldConfigurationInput struct {
	// The duration of each iteration, in days.
	Duration int32 `json:"duration"`
	// Zero or more iterations for the field.
	Iterations []ProjectV2Iteration `json:"iterations"`
	// The start date for the first iteration.
	StartDate Date `json:"startDate"`
}

// Iteration field iteration settings for a project.
type ProjectV2IterationFieldIteration struct {
	// The iteration's duration in days
	Duration int32 `json:"duration"`
	// The iteration's ID.
	Id string `json:"id"`
	// The iteration's start date
	StartDate Date `json:"startDate"`
	// The iteration's title.
	Title string `json:"title"`
	// The iteration's html title.
	TitleHTML string `json:"titleHTML"`
}

// Ways in which lists of projects can be ordered upon return.
type ProjectV2Order struct {
	// The direction in which to order projects by the specified field.
	Direction OrderDirection `json:"direction"`
	// The field in which to order projects by.
	Field ProjectV2OrderField `json:"field"`
}

// Properties by which projects can be ordered.
type ProjectV2OrderField string

const (
	// The project's date and time of creation
	ProjectV2OrderFieldCreatedAt ProjectV2OrderField = "CREATED_AT"
	// The project's number
	ProjectV2OrderFieldNumber ProjectV2OrderField = "NUMBER"
	// The project's title
	ProjectV2OrderFieldTitle ProjectV2OrderField = "TITLE"
	// The project's date and time of update
	ProjectV2OrderFieldUpdatedAt ProjectV2OrderField = "UPDATED_AT"
)

// Represents an owner of a project.
type ProjectV2Owner struct {
	// The Node ID of the ProjectV2Owner object
	Id string `json:"id"`
	// Find a project by number.
	ProjectV2 *ProjectV2 `json:"projectV2,omitempty"`
	// A list of projects under the owner.
	ProjectsV2 *ProjectV2Connection `json:"projectsV2"`

	// Underlying value of the GraphQL interface
	Value ProjectV2OwnerValue `json:"-"`
}

func (base *ProjectV2Owner) UnmarshalJSON(b []byte) error {
	type Raw ProjectV2Owner
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Issue":
		base.Value = new(Issue)
	case "Organization":
		base.Value = new(Organization)
	case "PullRequest":
		base.Value = new(PullRequest)
	case "User":
		base.Value = new(User)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface ProjectV2Owner: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// ProjectV2OwnerValue is one of: Issue | Organization | PullRequest | User
type ProjectV2OwnerValue interface {
	isProjectV2Owner()
}

// The possible roles of a collaborator on a project.
type ProjectV2PermissionLevel string

const (
	// The collaborator can view, edit, and maange the settings of the project
	ProjectV2PermissionLevelAdmin ProjectV2PermissionLevel = "ADMIN"
	// The collaborator can view the project
	ProjectV2PermissionLevelRead ProjectV2PermissionLevel = "READ"
	// The collaborator can view and edit the project
	ProjectV2PermissionLevelWrite ProjectV2PermissionLevel = "WRITE"
)

// Recent projects for the owner.
type ProjectV2Recent struct {
	// Recent projects that this user has modified in the context of the owner.
	RecentProjects *ProjectV2Connection `json:"recentProjects"`

	// Underlying value of the GraphQL interface
	Value ProjectV2RecentValue `json:"-"`
}

func (base *ProjectV2Recent) UnmarshalJSON(b []byte) error {
	type Raw ProjectV2Recent
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Organization":
		base.Value = new(Organization)
	case "Repository":
		base.Value = new(Repository)
	case "User":
		base.Value = new(User)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface ProjectV2Recent: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// ProjectV2RecentValue is one of: Organization | Repository | User
type ProjectV2RecentValue interface {
	isProjectV2Recent()
}

// The possible roles of a collaborator on a project.
type ProjectV2Roles string

const (
	// The collaborator can view, edit, and maange the settings of the project
	ProjectV2RolesAdmin ProjectV2Roles = "ADMIN"
	// The collaborator has no direct access to the project
	ProjectV2RolesNone ProjectV2Roles = "NONE"
	// The collaborator can view the project
	ProjectV2RolesReader ProjectV2Roles = "READER"
	// The collaborator can view and edit the project
	ProjectV2RolesWriter ProjectV2Roles = "WRITER"
)

// A single select field inside a project.
type ProjectV2SingleSelectField struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The field's type.
	DataType ProjectV2FieldType `json:"dataType"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The Node ID of the ProjectV2SingleSelectField object
	Id string `json:"id"`
	// The project field's name.
	Name string `json:"name"`
	// Options for the single select field
	Options []ProjectV2SingleSelectFieldOption `json:"options"`
	// The project that contains this field.
	Project *ProjectV2 `json:"project"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
}

func (*ProjectV2SingleSelectField) isProjectV2FieldConfiguration() {}

func (*ProjectV2SingleSelectField) isNode() {}

func (*ProjectV2SingleSelectField) isProjectV2FieldCommon() {}

// Single select field option for a configuration for a project.
type ProjectV2SingleSelectFieldOption struct {
	// The option's display color.
	Color ProjectV2SingleSelectFieldOptionColor `json:"color"`
	// The option's plain-text description.
	Description string `json:"description"`
	// The option's description, possibly containing HTML.
	DescriptionHTML string `json:"descriptionHTML"`
	// The option's ID.
	Id string `json:"id"`
	// The option's name.
	Name string `json:"name"`
	// The option's html name.
	NameHTML string `json:"nameHTML"`
}

// The display color of a single-select field option.
type ProjectV2SingleSelectFieldOptionColor string

const (
	// BLUE
	ProjectV2SingleSelectFieldOptionColorBlue ProjectV2SingleSelectFieldOptionColor = "BLUE"
	// GRAY
	ProjectV2SingleSelectFieldOptionColorGray ProjectV2SingleSelectFieldOptionColor = "GRAY"
	// GREEN
	ProjectV2SingleSelectFieldOptionColorGreen ProjectV2SingleSelectFieldOptionColor = "GREEN"
	// ORANGE
	ProjectV2SingleSelectFieldOptionColorOrange ProjectV2SingleSelectFieldOptionColor = "ORANGE"
	// PINK
	ProjectV2SingleSelectFieldOptionColorPink ProjectV2SingleSelectFieldOptionColor = "PINK"
	// PURPLE
	ProjectV2SingleSelectFieldOptionColorPurple ProjectV2SingleSelectFieldOptionColor = "PURPLE"
	// RED
	ProjectV2SingleSelectFieldOptionColorRed ProjectV2SingleSelectFieldOptionColor = "RED"
	// YELLOW
	ProjectV2SingleSelectFieldOptionColorYellow ProjectV2SingleSelectFieldOptionColor = "YELLOW"
)

// Represents a single select field option
type ProjectV2SingleSelectFieldOptionInput struct {
	// The display color of the option
	Color ProjectV2SingleSelectFieldOptionColor `json:"color"`
	// The description text of the option
	Description string `json:"description"`
	// The name of the option
	Name string `json:"name"`
}

// Represents a sort by field and direction.
type ProjectV2SortBy struct {
	// The direction of the sorting. Possible values are ASC and DESC.
	Direction OrderDirection `json:"direction"`
	// The field by which items are sorted.
	Field *ProjectV2Field `json:"field"`
}

// The connection type for ProjectV2SortBy.
type ProjectV2SortByConnection struct {
	// A list of edges.
	Edges []*ProjectV2SortByEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*ProjectV2SortBy `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type ProjectV2SortByEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *ProjectV2SortBy `json:"node,omitempty"`
}

// Represents a sort by field and direction.
type ProjectV2SortByField struct {
	// The direction of the sorting. Possible values are ASC and DESC.
	Direction OrderDirection `json:"direction"`
	// The field by which items are sorted.
	Field ProjectV2FieldConfiguration `json:"field"`
}

// The connection type for ProjectV2SortByField.
type ProjectV2SortByFieldConnection struct {
	// A list of edges.
	Edges []*ProjectV2SortByFieldEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*ProjectV2SortByField `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type ProjectV2SortByFieldEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *ProjectV2SortByField `json:"node,omitempty"`
}

// The possible states of a project v2.
type ProjectV2State string

const (
	// A project v2 that has been closed
	ProjectV2StateClosed ProjectV2State = "CLOSED"
	// A project v2 that is still open
	ProjectV2StateOpen ProjectV2State = "OPEN"
)

// Ways in which project v2 status updates can be ordered.
type ProjectV2StatusOrder struct {
	// The direction in which to order nodes.
	Direction OrderDirection `json:"direction"`
	// The field by which to order nodes.
	Field ProjectV2StatusUpdateOrderField `json:"field"`
}

// A status update within a project.
type ProjectV2StatusUpdate struct {
	// The body of the status update.
	Body *string `json:"body,omitempty"`
	// The body of the status update rendered to HTML.
	BodyHTML *HTML `json:"bodyHTML,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The actor who created the status update.
	Creator *Actor `json:"creator,omitempty"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// Identifies the primary key from the database as a BigInt.
	FullDatabaseId *BigInt `json:"fullDatabaseId,omitempty"`
	// The Node ID of the ProjectV2StatusUpdate object
	Id string `json:"id"`
	// The project that contains this status update.
	Project *ProjectV2 `json:"project"`
	// The start date of the status update.
	StartDate *Date `json:"startDate,omitempty"`
	// The status of the status update.
	Status *ProjectV2StatusUpdateStatus `json:"status,omitempty"`
	// The target date of the status update.
	TargetDate *Date `json:"targetDate,omitempty"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
}

func (*ProjectV2StatusUpdate) isNode() {}

// The connection type for ProjectV2StatusUpdate.
type ProjectV2StatusUpdateConnection struct {
	// A list of edges.
	Edges []*ProjectV2StatusUpdateEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*ProjectV2StatusUpdate `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type ProjectV2StatusUpdateEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *ProjectV2StatusUpdate `json:"node,omitempty"`
}

// Properties by which project v2 status updates can be ordered.
type ProjectV2StatusUpdateOrderField string

const (
	// Allows chronological ordering of project v2 status updates.
	ProjectV2StatusUpdateOrderFieldCreatedAt ProjectV2StatusUpdateOrderField = "CREATED_AT"
)

// The possible statuses of a project v2.
type ProjectV2StatusUpdateStatus string

const (
	// A project v2 that is at risk and encountering some challenges.
	ProjectV2StatusUpdateStatusAtRisk ProjectV2StatusUpdateStatus = "AT_RISK"
	// A project v2 that is complete.
	ProjectV2StatusUpdateStatusComplete ProjectV2StatusUpdateStatus = "COMPLETE"
	// A project v2 that is inactive.
	ProjectV2StatusUpdateStatusInactive ProjectV2StatusUpdateStatus = "INACTIVE"
	// A project v2 that is off track and needs attention.
	ProjectV2StatusUpdateStatusOffTrack ProjectV2StatusUpdateStatus = "OFF_TRACK"
	// A project v2 that is on track with no risks.
	ProjectV2StatusUpdateStatusOnTrack ProjectV2StatusUpdateStatus = "ON_TRACK"
)

// A view within a ProjectV2.
type ProjectV2View struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The view's visible fields.
	Fields *ProjectV2FieldConfigurationConnection `json:"fields,omitempty"`
	// The project view's filter.
	Filter *string `json:"filter,omitempty"`
	// Identifies the primary key from the database as a BigInt.
	FullDatabaseId *BigInt `json:"fullDatabaseId,omitempty"`
	// The view's group-by field.
	GroupBy *ProjectV2FieldConnection `json:"groupBy,omitempty"`
	// The view's group-by field.
	GroupByFields *ProjectV2FieldConfigurationConnection `json:"groupByFields,omitempty"`
	// The Node ID of the ProjectV2View object
	Id string `json:"id"`
	// The project view's layout.
	Layout ProjectV2ViewLayout `json:"layout"`
	// The project view's name.
	Name string `json:"name"`
	// The project view's number.
	Number int32 `json:"number"`
	// The project that contains this view.
	Project *ProjectV2 `json:"project"`
	// The view's sort-by config.
	SortBy *ProjectV2SortByConnection `json:"sortBy,omitempty"`
	// The view's sort-by config.
	SortByFields *ProjectV2SortByFieldConnection `json:"sortByFields,omitempty"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The view's vertical-group-by field.
	VerticalGroupBy *ProjectV2FieldConnection `json:"verticalGroupBy,omitempty"`
	// The view's vertical-group-by field.
	VerticalGroupByFields *ProjectV2FieldConfigurationConnection `json:"verticalGroupByFields,omitempty"`
	// The view's visible fields.
	VisibleFields *ProjectV2FieldConnection `json:"visibleFields,omitempty"`
}

func (*ProjectV2View) isNode() {}

// The connection type for ProjectV2View.
type ProjectV2ViewConnection struct {
	// A list of edges.
	Edges []*ProjectV2ViewEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*ProjectV2View `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type ProjectV2ViewEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *ProjectV2View `json:"node,omitempty"`
}

// The layout of a project v2 view.
type ProjectV2ViewLayout string

const (
	// Board layout
	ProjectV2ViewLayoutBoardLayout ProjectV2ViewLayout = "BOARD_LAYOUT"
	// Roadmap layout
	ProjectV2ViewLayoutRoadmapLayout ProjectV2ViewLayout = "ROADMAP_LAYOUT"
	// Table layout
	ProjectV2ViewLayoutTableLayout ProjectV2ViewLayout = "TABLE_LAYOUT"
)

// Ordering options for project v2 view connections
type ProjectV2ViewOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order the project v2 views by.
	Field ProjectV2ViewOrderField `json:"field"`
}

// Properties by which project v2 view connections can be ordered.
type ProjectV2ViewOrderField string

const (
	// Order project v2 views by creation time
	ProjectV2ViewOrderFieldCreatedAt ProjectV2ViewOrderField = "CREATED_AT"
	// Order project v2 views by name
	ProjectV2ViewOrderFieldName ProjectV2ViewOrderField = "NAME"
	// Order project v2 views by position
	ProjectV2ViewOrderFieldPosition ProjectV2ViewOrderField = "POSITION"
)

// A workflow inside a project.
type ProjectV2Workflow struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// Whether the workflow is enabled.
	Enabled bool `json:"enabled"`
	// Identifies the primary key from the database as a BigInt.
	FullDatabaseId *BigInt `json:"fullDatabaseId,omitempty"`
	// The Node ID of the ProjectV2Workflow object
	Id string `json:"id"`
	// The name of the workflow.
	Name string `json:"name"`
	// The number of the workflow.
	Number int32 `json:"number"`
	// The project that contains this workflow.
	Project *ProjectV2 `json:"project"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
}

func (*ProjectV2Workflow) isNode() {}

// The connection type for ProjectV2Workflow.
type ProjectV2WorkflowConnection struct {
	// A list of edges.
	Edges []*ProjectV2WorkflowEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*ProjectV2Workflow `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type ProjectV2WorkflowEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *ProjectV2Workflow `json:"node,omitempty"`
}

// Ordering options for project v2 workflows connections
type ProjectV2WorkflowOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order the project v2 workflows by.
	Field ProjectV2WorkflowsOrderField `json:"field"`
}

// Properties by which project workflows can be ordered.
type ProjectV2WorkflowsOrderField string

const (
	// The date and time of the workflow creation
	ProjectV2WorkflowsOrderFieldCreatedAt ProjectV2WorkflowsOrderField = "CREATED_AT"
	// The name of the workflow
	ProjectV2WorkflowsOrderFieldName ProjectV2WorkflowsOrderField = "NAME"
	// The number of the workflow
	ProjectV2WorkflowsOrderFieldNumber ProjectV2WorkflowsOrderField = "NUMBER"
	// The date and time of the workflow update
	ProjectV2WorkflowsOrderFieldUpdatedAt ProjectV2WorkflowsOrderField = "UPDATED_AT"
)

// A property that must match
type PropertyTargetDefinition struct {
	// The name of the property
	Name string `json:"name"`
	// The values to match for
	PropertyValues []string `json:"propertyValues"`
	// The source of the property. Choose 'custom' or 'system'. Defaults to 'custom' if not specified
	Source *string `json:"source,omitempty"`
}

// A property that must match
type PropertyTargetDefinitionInput struct {
	// The name of the property
	Name string `json:"name"`
	// The values to match for
	PropertyValues []string `json:"propertyValues"`
	// The source of the property. Choose 'custom' or 'system'. Defaults to 'custom' if not specified
	Source *string `json:"source,omitempty"`
}

// A user's public key.
type PublicKey struct {
	// The last time this authorization was used to perform an action. Values will be null for keys not owned by the user.
	AccessedAt *DateTime `json:"accessedAt,omitempty"`
	// Identifies the date and time when the key was created. Keys created before
	// March 5th, 2014 have inaccurate values. Values will be null for keys not owned by the user.
	CreatedAt *DateTime `json:"createdAt,omitempty"`
	// The fingerprint for this PublicKey.
	Fingerprint string `json:"fingerprint"`
	// The Node ID of the PublicKey object
	Id string `json:"id"`
	// Whether this PublicKey is read-only or not. Values will be null for keys not owned by the user.
	IsReadOnly *bool `json:"isReadOnly,omitempty"`
	// The public key string.
	Key string `json:"key"`
	// Identifies the date and time when the key was updated. Keys created before
	// March 5th, 2014 may have inaccurate values. Values will be null for keys not
	// owned by the user.
	UpdatedAt *DateTime `json:"updatedAt,omitempty"`
}

func (*PublicKey) isNode() {}

// The connection type for PublicKey.
type PublicKeyConnection struct {
	// A list of edges.
	Edges []*PublicKeyEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*PublicKey `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type PublicKeyEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *PublicKey `json:"node,omitempty"`
}

// Autogenerated input type of PublishSponsorsTier
type PublishSponsorsTierInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the draft tier to publish.
	TierId string `json:"tierId"`
}

// Autogenerated return type of PublishSponsorsTier.
type PublishSponsorsTierPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The tier that was published.
	SponsorsTier *SponsorsTier `json:"sponsorsTier,omitempty"`
}

// A repository pull request.
type PullRequest struct {
	// Reason that the conversation was locked.
	ActiveLockReason *LockReason `json:"activeLockReason,omitempty"`
	// The number of additions in this pull request.
	Additions int32 `json:"additions"`
	// A list of actors assigned to this object.
	AssignedActors *AssigneeConnection `json:"assignedActors"`
	// A list of Users assigned to this object.
	Assignees *UserConnection `json:"assignees"`
	// The actor who authored the comment.
	Author *Actor `json:"author,omitempty"`
	// Author's association with the subject of the comment.
	AuthorAssociation CommentAuthorAssociation `json:"authorAssociation"`
	// Returns the auto-merge request object if one exists for this pull request.
	AutoMergeRequest *AutoMergeRequest `json:"autoMergeRequest,omitempty"`
	// Identifies the base Ref associated with the pull request.
	BaseRef *Ref `json:"baseRef,omitempty"`
	// Identifies the name of the base Ref associated with the pull request, even if the ref has been deleted.
	BaseRefName string `json:"baseRefName"`
	// Identifies the oid of the base ref associated with the pull request, even if the ref has been deleted.
	BaseRefOid GitObjectID `json:"baseRefOid"`
	// The repository associated with this pull request's base Ref.
	BaseRepository *Repository `json:"baseRepository,omitempty"`
	// The body as Markdown.
	Body string `json:"body"`
	// The body rendered to HTML.
	BodyHTML HTML `json:"bodyHTML"`
	// The body rendered to text.
	BodyText string `json:"bodyText"`
	// Whether or not the pull request is rebaseable.
	CanBeRebased bool `json:"canBeRebased"`
	// The number of changed files in this pull request.
	ChangedFiles int32 `json:"changedFiles"`
	// The HTTP path for the checks of this pull request.
	ChecksResourcePath URI `json:"checksResourcePath"`
	// The HTTP URL for the checks of this pull request.
	ChecksUrl URI `json:"checksUrl"`
	// `true` if the pull request is closed
	Closed bool `json:"closed"`
	// Identifies the date and time when the object was closed.
	ClosedAt *DateTime `json:"closedAt,omitempty"`
	// List of issues that may be closed by this pull request
	ClosingIssuesReferences *IssueConnection `json:"closingIssuesReferences,omitempty"`
	// A list of comments associated with the pull request.
	Comments *IssueCommentConnection `json:"comments"`
	// A list of commits present in this pull request's head branch not present in the base branch.
	Commits *PullRequestCommitConnection `json:"commits"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Check if this comment was created via an email reply.
	CreatedViaEmail bool `json:"createdViaEmail"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The number of deletions in this pull request.
	Deletions int32 `json:"deletions"`
	// The actor who edited this pull request's body.
	Editor *Actor `json:"editor,omitempty"`
	// Lists the files changed within this pull request.
	Files *PullRequestChangedFileConnection `json:"files,omitempty"`
	// Identifies the primary key from the database as a BigInt.
	FullDatabaseId *BigInt `json:"fullDatabaseId,omitempty"`
	// Identifies the head Ref associated with the pull request.
	HeadRef *Ref `json:"headRef,omitempty"`
	// Identifies the name of the head Ref associated with the pull request, even if the ref has been deleted.
	HeadRefName string `json:"headRefName"`
	// Identifies the oid of the head ref associated with the pull request, even if the ref has been deleted.
	HeadRefOid GitObjectID `json:"headRefOid"`
	// The repository associated with this pull request's head Ref.
	HeadRepository *Repository `json:"headRepository,omitempty"`
	// The owner of the repository associated with this pull request's head Ref.
	HeadRepositoryOwner *RepositoryOwner `json:"headRepositoryOwner,omitempty"`
	// The hovercard information for this issue
	Hovercard *Hovercard `json:"hovercard"`
	// The Node ID of the PullRequest object
	Id string `json:"id"`
	// Check if this comment was edited and includes an edit with the creation data
	IncludesCreatedEdit bool `json:"includesCreatedEdit"`
	// The head and base repositories are different.
	IsCrossRepository bool `json:"isCrossRepository"`
	// Identifies if the pull request is a draft.
	IsDraft bool `json:"isDraft"`
	// Indicates whether the pull request is in a merge queue
	IsInMergeQueue bool `json:"isInMergeQueue"`
	// Indicates whether the pull request's base ref has a merge queue enabled.
	IsMergeQueueEnabled bool `json:"isMergeQueueEnabled"`
	// Is this pull request read by the viewer
	IsReadByViewer *bool `json:"isReadByViewer,omitempty"`
	// A list of labels associated with the object.
	Labels *LabelConnection `json:"labels,omitempty"`
	// The moment the editor made the last edit
	LastEditedAt *DateTime `json:"lastEditedAt,omitempty"`
	// A list of latest reviews per user associated with the pull request.
	LatestOpinionatedReviews *PullRequestReviewConnection `json:"latestOpinionatedReviews,omitempty"`
	// A list of latest reviews per user associated with the pull request that are not also pending review.
	LatestReviews *PullRequestReviewConnection `json:"latestReviews,omitempty"`
	// `true` if the pull request is locked
	Locked bool `json:"locked"`
	// Indicates whether maintainers can modify the pull request.
	MaintainerCanModify bool `json:"maintainerCanModify"`
	// The commit that was created when this pull request was merged.
	MergeCommit *Commit `json:"mergeCommit,omitempty"`
	// The merge queue for the pull request's base branch
	MergeQueue *MergeQueue `json:"mergeQueue,omitempty"`
	// The merge queue entry of the pull request in the base branch's merge queue
	MergeQueueEntry *MergeQueueEntry `json:"mergeQueueEntry,omitempty"`
	// Detailed information about the current pull request merge state status.
	MergeStateStatus MergeStateStatus `json:"mergeStateStatus"`
	// Whether or not the pull request can be merged based on the existence of merge conflicts.
	Mergeable MergeableState `json:"mergeable"`
	// Whether or not the pull request was merged.
	Merged bool `json:"merged"`
	// The date and time that the pull request was merged.
	MergedAt *DateTime `json:"mergedAt,omitempty"`
	// The actor who merged the pull request.
	MergedBy *Actor `json:"mergedBy,omitempty"`
	// Identifies the milestone associated with the pull request.
	Milestone *Milestone `json:"milestone,omitempty"`
	// Identifies the pull request number.
	Number int32 `json:"number"`
	// A list of Users that are participating in the Pull Request conversation.
	Participants *UserConnection `json:"participants"`
	// The permalink to the pull request.
	Permalink URI `json:"permalink"`
	// The commit that GitHub automatically generated to test if this pull request
	// could be merged. This field will not return a value if the pull request is
	// merged, or if the test merge commit is still being generated. See the
	// `mergeable` field for more details on the mergeability of the pull request.
	PotentialMergeCommit *Commit `json:"potentialMergeCommit,omitempty"`
	// List of project cards associated with this pull request.
	ProjectCards *ProjectCardConnection `json:"projectCards"`
	// List of project items associated with this pull request.
	ProjectItems *ProjectV2ItemConnection `json:"projectItems"`
	// Find a project by number.
	ProjectV2 *ProjectV2 `json:"projectV2,omitempty"`
	// A list of projects under the owner.
	ProjectsV2 *ProjectV2Connection `json:"projectsV2"`
	// Identifies when the comment was published at.
	PublishedAt *DateTime `json:"publishedAt,omitempty"`
	// A list of reactions grouped by content left on the subject.
	ReactionGroups []ReactionGroup `json:"reactionGroups,omitempty"`
	// A list of Reactions left on the Issue.
	Reactions *ReactionConnection `json:"reactions"`
	// The repository associated with this node.
	Repository *Repository `json:"repository"`
	// The HTTP path for this pull request.
	ResourcePath URI `json:"resourcePath"`
	// The HTTP path for reverting this pull request.
	RevertResourcePath URI `json:"revertResourcePath"`
	// The HTTP URL for reverting this pull request.
	RevertUrl URI `json:"revertUrl"`
	// The current status of this pull request with respect to code review.
	ReviewDecision *PullRequestReviewDecision `json:"reviewDecision,omitempty"`
	// A list of review requests associated with the pull request.
	ReviewRequests *ReviewRequestConnection `json:"reviewRequests,omitempty"`
	// The list of all review threads for this pull request.
	ReviewThreads *PullRequestReviewThreadConnection `json:"reviewThreads"`
	// A list of reviews associated with the pull request.
	Reviews *PullRequestReviewConnection `json:"reviews,omitempty"`
	// Identifies the state of the pull request.
	State PullRequestState `json:"state"`
	// Check and Status rollup information for the PR's head ref.
	StatusCheckRollup *StatusCheckRollup `json:"statusCheckRollup,omitempty"`
	// A list of suggested actors to assign to this object
	SuggestedActors *AssigneeConnection `json:"suggestedActors"`
	// A list of reviewer suggestions based on commit history and past review comments.
	SuggestedReviewers []*SuggestedReviewer `json:"suggestedReviewers"`
	// A list of events, comments, commits, etc. associated with the pull request.
	Timeline *PullRequestTimelineConnection `json:"timeline"`
	// A list of events, comments, commits, etc. associated with the pull request.
	TimelineItems *PullRequestTimelineItemsConnection `json:"timelineItems"`
	// Identifies the pull request title.
	Title string `json:"title"`
	// Identifies the pull request title rendered to HTML.
	TitleHTML HTML `json:"titleHTML"`
	// Returns a count of how many comments this pull request has received.
	TotalCommentsCount *int32 `json:"totalCommentsCount,omitempty"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The HTTP URL for this pull request.
	Url URI `json:"url"`
	// A list of edits to this content.
	UserContentEdits *UserContentEditConnection `json:"userContentEdits,omitempty"`
	// Whether or not the viewer can apply suggestion.
	ViewerCanApplySuggestion bool `json:"viewerCanApplySuggestion"`
	// Indicates if the object can be closed by the viewer.
	ViewerCanClose bool `json:"viewerCanClose"`
	// Check if the viewer can restore the deleted head ref.
	ViewerCanDeleteHeadRef bool `json:"viewerCanDeleteHeadRef"`
	// Whether or not the viewer can disable auto-merge
	ViewerCanDisableAutoMerge bool `json:"viewerCanDisableAutoMerge"`
	// Can the viewer edit files within this pull request.
	ViewerCanEditFiles bool `json:"viewerCanEditFiles"`
	// Whether or not the viewer can enable auto-merge
	ViewerCanEnableAutoMerge bool `json:"viewerCanEnableAutoMerge"`
	// Indicates if the viewer can edit labels for this object.
	ViewerCanLabel bool `json:"viewerCanLabel"`
	// Indicates whether the viewer can bypass branch protections and merge the pull request immediately
	ViewerCanMergeAsAdmin bool `json:"viewerCanMergeAsAdmin"`
	// Can user react to this subject
	ViewerCanReact bool `json:"viewerCanReact"`
	// Indicates if the object can be reopened by the viewer.
	ViewerCanReopen bool `json:"viewerCanReopen"`
	// Check if the viewer is able to change their subscription status for the repository.
	ViewerCanSubscribe bool `json:"viewerCanSubscribe"`
	// Check if the current viewer can update this object.
	ViewerCanUpdate bool `json:"viewerCanUpdate"`
	// Whether or not the viewer can update the head ref of this PR, by merging or rebasing the base ref.
	// If the head ref is up to date or unable to be updated by this user, this will return false.
	ViewerCanUpdateBranch bool `json:"viewerCanUpdateBranch"`
	// Reasons why the current viewer can not update this comment.
	ViewerCannotUpdateReasons []CommentCannotUpdateReason `json:"viewerCannotUpdateReasons"`
	// Did the viewer author this comment.
	ViewerDidAuthor bool `json:"viewerDidAuthor"`
	// The latest review given from the viewer.
	ViewerLatestReview *PullRequestReview `json:"viewerLatestReview,omitempty"`
	// The person who has requested the viewer for review on this pull request.
	ViewerLatestReviewRequest *ReviewRequest `json:"viewerLatestReviewRequest,omitempty"`
	// The merge body text for the viewer and method.
	ViewerMergeBodyText string `json:"viewerMergeBodyText"`
	// The merge headline text for the viewer and method.
	ViewerMergeHeadlineText string `json:"viewerMergeHeadlineText"`
	// Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
	ViewerSubscription *SubscriptionState `json:"viewerSubscription,omitempty"`
}

func (*PullRequest) isCloser() {}

func (*PullRequest) isIssueOrPullRequest() {}

func (*PullRequest) isMilestoneItem() {}

func (*PullRequest) isProjectCardItem() {}

func (*PullRequest) isProjectV2ItemContent() {}

func (*PullRequest) isAssignable() {}

func (*PullRequest) isClosable() {}

func (*PullRequest) isComment() {}

func (*PullRequest) isLabelable() {}

func (*PullRequest) isLockable() {}

func (*PullRequest) isNode() {}

func (*PullRequest) isProjectV2Owner() {}

func (*PullRequest) isReactable() {}

func (*PullRequest) isRepositoryNode() {}

func (*PullRequest) isSubscribable() {}

func (*PullRequest) isUniformResourceLocatable() {}

func (*PullRequest) isUpdatable() {}

func (*PullRequest) isUpdatableComment() {}

func (*PullRequest) isReferencedSubject() {}

func (*PullRequest) isRenamedTitleSubject() {}

func (*PullRequest) isSearchResultItem() {}

// Array of allowed merge methods. Allowed values include `merge`, `squash`, and `rebase`. At least one option must be enabled.
type PullRequestAllowedMergeMethods string

const (
	// Add all commits from the head branch to the base branch with a merge commit.
	PullRequestAllowedMergeMethodsMerge PullRequestAllowedMergeMethods = "MERGE"
	// Add all commits from the head branch onto the base branch individually.
	PullRequestAllowedMergeMethodsRebase PullRequestAllowedMergeMethods = "REBASE"
	// Combine all commits from the head branch into a single commit in the base branch.
	PullRequestAllowedMergeMethodsSquash PullRequestAllowedMergeMethods = "SQUASH"
)

// The possible methods for updating a pull request's head branch with the base branch.
type PullRequestBranchUpdateMethod string

const (
	// Update branch via merge
	PullRequestBranchUpdateMethodMerge PullRequestBranchUpdateMethod = "MERGE"
	// Update branch via rebase
	PullRequestBranchUpdateMethodRebase PullRequestBranchUpdateMethod = "REBASE"
)

// A file changed in a pull request.
type PullRequestChangedFile struct {
	// The number of additions to the file.
	Additions int32 `json:"additions"`
	// How the file was changed in this PullRequest
	ChangeType PatchStatus `json:"changeType"`
	// The number of deletions to the file.
	Deletions int32 `json:"deletions"`
	// The path of the file.
	Path string `json:"path"`
	// The state of the file for the viewer.
	ViewerViewedState FileViewedState `json:"viewerViewedState"`
}

// The connection type for PullRequestChangedFile.
type PullRequestChangedFileConnection struct {
	// A list of edges.
	Edges []*PullRequestChangedFileEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*PullRequestChangedFile `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type PullRequestChangedFileEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *PullRequestChangedFile `json:"node,omitempty"`
}

// Represents a Git commit part of a pull request.
type PullRequestCommit struct {
	// The Git commit object
	Commit *Commit `json:"commit"`
	// The Node ID of the PullRequestCommit object
	Id string `json:"id"`
	// The pull request this commit belongs to
	PullRequest *PullRequest `json:"pullRequest"`
	// The HTTP path for this pull request commit
	ResourcePath URI `json:"resourcePath"`
	// The HTTP URL for this pull request commit
	Url URI `json:"url"`
}

func (*PullRequestCommit) isNode() {}

func (*PullRequestCommit) isUniformResourceLocatable() {}

func (*PullRequestCommit) isPullRequestTimelineItems() {}

// Represents a commit comment thread part of a pull request.
type PullRequestCommitCommentThread struct {
	// The comments that exist in this thread.
	Comments *CommitCommentConnection `json:"comments"`
	// The commit the comments were made on.
	Commit *Commit `json:"commit"`
	// The Node ID of the PullRequestCommitCommentThread object
	Id string `json:"id"`
	// The file the comments were made on.
	Path *string `json:"path,omitempty"`
	// The position in the diff for the commit that the comment was made on.
	Position *int32 `json:"position,omitempty"`
	// The pull request this commit comment thread belongs to
	PullRequest *PullRequest `json:"pullRequest"`
	// The repository associated with this node.
	Repository *Repository `json:"repository"`
}

func (*PullRequestCommitCommentThread) isNode() {}

func (*PullRequestCommitCommentThread) isRepositoryNode() {}

func (*PullRequestCommitCommentThread) isPullRequestTimelineItems() {}

// The connection type for PullRequestCommit.
type PullRequestCommitConnection struct {
	// A list of edges.
	Edges []*PullRequestCommitEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*PullRequestCommit `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type PullRequestCommitEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *PullRequestCommit `json:"node,omitempty"`
}

// The connection type for PullRequest.
type PullRequestConnection struct {
	// A list of edges.
	Edges []*PullRequestEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*PullRequest `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// This aggregates pull requests opened by a user within one repository.
type PullRequestContributionsByRepository struct {
	// The pull request contributions.
	Contributions *CreatedPullRequestContributionConnection `json:"contributions"`
	// The repository in which the pull requests were opened.
	Repository *Repository `json:"repository"`
}

// An edge in a connection.
type PullRequestEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *PullRequest `json:"node,omitempty"`
}

// Represents available types of methods to use when merging a pull request.
type PullRequestMergeMethod string

const (
	// Add all commits from the head branch to the base branch with a merge commit.
	PullRequestMergeMethodMerge PullRequestMergeMethod = "MERGE"
	// Add all commits from the head branch onto the base branch individually.
	PullRequestMergeMethodRebase PullRequestMergeMethod = "REBASE"
	// Combine all commits from the head branch into a single commit in the base branch.
	PullRequestMergeMethodSquash PullRequestMergeMethod = "SQUASH"
)

// Ways in which lists of issues can be ordered upon return.
type PullRequestOrder struct {
	// The direction in which to order pull requests by the specified field.
	Direction OrderDirection `json:"direction"`
	// The field in which to order pull requests by.
	Field PullRequestOrderField `json:"field"`
}

// Properties by which pull_requests connections can be ordered.
type PullRequestOrderField string

const (
	// Order pull_requests by creation time
	PullRequestOrderFieldCreatedAt PullRequestOrderField = "CREATED_AT"
	// Order pull_requests by update time
	PullRequestOrderFieldUpdatedAt PullRequestOrderField = "UPDATED_AT"
)

// Require all commits be made to a non-target branch and submitted via a pull request before they can be merged.
type PullRequestParameters struct {
	// Array of allowed merge methods. Allowed values include `merge`, `squash`, and
	// `rebase`. At least one option must be enabled.
	AllowedMergeMethods []PullRequestAllowedMergeMethods `json:"allowedMergeMethods,omitempty"`
	// Automatically request review from Copilot for new pull requests, if the author has access to Copilot code review.
	AutomaticCopilotCodeReviewEnabled bool `json:"automaticCopilotCodeReviewEnabled"`
	// New, reviewable commits pushed will dismiss previous pull request review approvals.
	DismissStaleReviewsOnPush bool `json:"dismissStaleReviewsOnPush"`
	// Require an approving review in pull requests that modify files that have a designated code owner.
	RequireCodeOwnerReview bool `json:"requireCodeOwnerReview"`
	// Whether the most recent reviewable push must be approved by someone other than the person who pushed it.
	RequireLastPushApproval bool `json:"requireLastPushApproval"`
	// The number of approving reviews that are required before a pull request can be merged.
	RequiredApprovingReviewCount int32 `json:"requiredApprovingReviewCount"`
	// All conversations on code must be resolved before a pull request can be merged.
	RequiredReviewThreadResolution bool `json:"requiredReviewThreadResolution"`
}

func (*PullRequestParameters) isRuleParameters() {}

// Require all commits be made to a non-target branch and submitted via a pull request before they can be merged.
type PullRequestParametersInput struct {
	// Array of allowed merge methods. Allowed values include `merge`, `squash`, and
	// `rebase`. At least one option must be enabled.
	AllowedMergeMethods []PullRequestAllowedMergeMethods `json:"allowedMergeMethods,omitempty"`
	// Automatically request review from Copilot for new pull requests, if the author has access to Copilot code review.
	AutomaticCopilotCodeReviewEnabled *bool `json:"automaticCopilotCodeReviewEnabled,omitempty"`
	// New, reviewable commits pushed will dismiss previous pull request review approvals.
	DismissStaleReviewsOnPush bool `json:"dismissStaleReviewsOnPush"`
	// Require an approving review in pull requests that modify files that have a designated code owner.
	RequireCodeOwnerReview bool `json:"requireCodeOwnerReview"`
	// Whether the most recent reviewable push must be approved by someone other than the person who pushed it.
	RequireLastPushApproval bool `json:"requireLastPushApproval"`
	// The number of approving reviews that are required before a pull request can be merged.
	RequiredApprovingReviewCount int32 `json:"requiredApprovingReviewCount"`
	// All conversations on code must be resolved before a pull request can be merged.
	RequiredReviewThreadResolution bool `json:"requiredReviewThreadResolution"`
}

// A review object for a given pull request.
type PullRequestReview struct {
	// The actor who authored the comment.
	Author *Actor `json:"author,omitempty"`
	// Author's association with the subject of the comment.
	AuthorAssociation CommentAuthorAssociation `json:"authorAssociation"`
	// Indicates whether the author of this review has push access to the repository.
	AuthorCanPushToRepository bool `json:"authorCanPushToRepository"`
	// Identifies the pull request review body.
	Body string `json:"body"`
	// The body rendered to HTML.
	BodyHTML HTML `json:"bodyHTML"`
	// The body of this review rendered as plain text.
	BodyText string `json:"bodyText"`
	// A list of review comments for the current pull request review.
	Comments *PullRequestReviewCommentConnection `json:"comments"`
	// Identifies the commit associated with this pull request review.
	Commit *Commit `json:"commit,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Check if this comment was created via an email reply.
	CreatedViaEmail bool `json:"createdViaEmail"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The actor who edited the comment.
	Editor *Actor `json:"editor,omitempty"`
	// Identifies the primary key from the database as a BigInt.
	FullDatabaseId *BigInt `json:"fullDatabaseId,omitempty"`
	// The Node ID of the PullRequestReview object
	Id string `json:"id"`
	// Check if this comment was edited and includes an edit with the creation data
	IncludesCreatedEdit bool `json:"includesCreatedEdit"`
	// Returns whether or not a comment has been minimized.
	IsMinimized bool `json:"isMinimized"`
	// The moment the editor made the last edit
	LastEditedAt *DateTime `json:"lastEditedAt,omitempty"`
	// Returns why the comment was minimized. One of `abuse`, `off-topic`,
	// `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
	// formatting of these values differs from the inputs to the `MinimizeComment` mutation.
	MinimizedReason *string `json:"minimizedReason,omitempty"`
	// A list of teams that this review was made on behalf of.
	OnBehalfOf *TeamConnection `json:"onBehalfOf"`
	// Identifies when the comment was published at.
	PublishedAt *DateTime `json:"publishedAt,omitempty"`
	// Identifies the pull request associated with this pull request review.
	PullRequest *PullRequest `json:"pullRequest"`
	// A list of reactions grouped by content left on the subject.
	ReactionGroups []ReactionGroup `json:"reactionGroups,omitempty"`
	// A list of Reactions left on the Issue.
	Reactions *ReactionConnection `json:"reactions"`
	// The repository associated with this node.
	Repository *Repository `json:"repository"`
	// The HTTP path permalink for this PullRequestReview.
	ResourcePath URI `json:"resourcePath"`
	// Identifies the current state of the pull request review.
	State PullRequestReviewState `json:"state"`
	// Identifies when the Pull Request Review was submitted
	SubmittedAt *DateTime `json:"submittedAt,omitempty"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The HTTP URL permalink for this PullRequestReview.
	Url URI `json:"url"`
	// A list of edits to this content.
	UserContentEdits *UserContentEditConnection `json:"userContentEdits,omitempty"`
	// Check if the current viewer can delete this object.
	ViewerCanDelete bool `json:"viewerCanDelete"`
	// Check if the current viewer can minimize this object.
	ViewerCanMinimize bool `json:"viewerCanMinimize"`
	// Can user react to this subject
	ViewerCanReact bool `json:"viewerCanReact"`
	// Check if the current viewer can update this object.
	ViewerCanUpdate bool `json:"viewerCanUpdate"`
	// Reasons why the current viewer can not update this comment.
	ViewerCannotUpdateReasons []CommentCannotUpdateReason `json:"viewerCannotUpdateReasons"`
	// Did the viewer author this comment.
	ViewerDidAuthor bool `json:"viewerDidAuthor"`
}

func (*PullRequestReview) isComment() {}

func (*PullRequestReview) isDeletable() {}

func (*PullRequestReview) isMinimizable() {}

func (*PullRequestReview) isNode() {}

func (*PullRequestReview) isReactable() {}

func (*PullRequestReview) isRepositoryNode() {}

func (*PullRequestReview) isUpdatable() {}

func (*PullRequestReview) isUpdatableComment() {}

func (*PullRequestReview) isPullRequestTimelineItem() {}

func (*PullRequestReview) isPullRequestTimelineItems() {}

// A review comment associated with a given repository pull request.
type PullRequestReviewComment struct {
	// The actor who authored the comment.
	Author *Actor `json:"author,omitempty"`
	// Author's association with the subject of the comment.
	AuthorAssociation CommentAuthorAssociation `json:"authorAssociation"`
	// The comment body of this review comment.
	Body string `json:"body"`
	// The body rendered to HTML.
	BodyHTML HTML `json:"bodyHTML"`
	// The comment body of this review comment rendered as plain text.
	BodyText string `json:"bodyText"`
	// Identifies the commit associated with the comment.
	Commit *Commit `json:"commit,omitempty"`
	// Identifies when the comment was created.
	CreatedAt DateTime `json:"createdAt"`
	// Check if this comment was created via an email reply.
	CreatedViaEmail bool `json:"createdViaEmail"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The diff hunk to which the comment applies.
	DiffHunk string `json:"diffHunk"`
	// Identifies when the comment was created in a draft state.
	DraftedAt DateTime `json:"draftedAt"`
	// The actor who edited the comment.
	Editor *Actor `json:"editor,omitempty"`
	// Identifies the primary key from the database as a BigInt.
	FullDatabaseId *BigInt `json:"fullDatabaseId,omitempty"`
	// The Node ID of the PullRequestReviewComment object
	Id string `json:"id"`
	// Check if this comment was edited and includes an edit with the creation data
	IncludesCreatedEdit bool `json:"includesCreatedEdit"`
	// Returns whether or not a comment has been minimized.
	IsMinimized bool `json:"isMinimized"`
	// The moment the editor made the last edit
	LastEditedAt *DateTime `json:"lastEditedAt,omitempty"`
	// The end line number on the file to which the comment applies
	Line *int32 `json:"line,omitempty"`
	// Returns why the comment was minimized. One of `abuse`, `off-topic`,
	// `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
	// formatting of these values differs from the inputs to the `MinimizeComment` mutation.
	MinimizedReason *string `json:"minimizedReason,omitempty"`
	// Identifies the original commit associated with the comment.
	OriginalCommit *Commit `json:"originalCommit,omitempty"`
	// The end line number on the file to which the comment applied when it was first created
	OriginalLine *int32 `json:"originalLine,omitempty"`
	// The original line index in the diff to which the comment applies.
	OriginalPosition int32 `json:"originalPosition"`
	// The start line number on the file to which the comment applied when it was first created
	OriginalStartLine *int32 `json:"originalStartLine,omitempty"`
	// Identifies when the comment body is outdated
	Outdated bool `json:"outdated"`
	// The path to which the comment applies.
	Path string `json:"path"`
	// The line index in the diff to which the comment applies.
	Position *int32 `json:"position,omitempty"`
	// Identifies when the comment was published at.
	PublishedAt *DateTime `json:"publishedAt,omitempty"`
	// The pull request associated with this review comment.
	PullRequest *PullRequest `json:"pullRequest"`
	// The pull request review associated with this review comment.
	PullRequestReview *PullRequestReview `json:"pullRequestReview,omitempty"`
	// A list of reactions grouped by content left on the subject.
	ReactionGroups []ReactionGroup `json:"reactionGroups,omitempty"`
	// A list of Reactions left on the Issue.
	Reactions *ReactionConnection `json:"reactions"`
	// The comment this is a reply to.
	ReplyTo *PullRequestReviewComment `json:"replyTo,omitempty"`
	// The repository associated with this node.
	Repository *Repository `json:"repository"`
	// The HTTP path permalink for this review comment.
	ResourcePath URI `json:"resourcePath"`
	// The start line number on the file to which the comment applies
	StartLine *int32 `json:"startLine,omitempty"`
	// Identifies the state of the comment.
	State PullRequestReviewCommentState `json:"state"`
	// The level at which the comments in the corresponding thread are targeted, can be a diff line or a file
	SubjectType PullRequestReviewThreadSubjectType `json:"subjectType"`
	// Identifies when the comment was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The HTTP URL permalink for this review comment.
	Url URI `json:"url"`
	// A list of edits to this content.
	UserContentEdits *UserContentEditConnection `json:"userContentEdits,omitempty"`
	// Check if the current viewer can delete this object.
	ViewerCanDelete bool `json:"viewerCanDelete"`
	// Check if the current viewer can minimize this object.
	ViewerCanMinimize bool `json:"viewerCanMinimize"`
	// Can user react to this subject
	ViewerCanReact bool `json:"viewerCanReact"`
	// Check if the current viewer can update this object.
	ViewerCanUpdate bool `json:"viewerCanUpdate"`
	// Reasons why the current viewer can not update this comment.
	ViewerCannotUpdateReasons []CommentCannotUpdateReason `json:"viewerCannotUpdateReasons"`
	// Did the viewer author this comment.
	ViewerDidAuthor bool `json:"viewerDidAuthor"`
}

func (*PullRequestReviewComment) isComment() {}

func (*PullRequestReviewComment) isDeletable() {}

func (*PullRequestReviewComment) isMinimizable() {}

func (*PullRequestReviewComment) isNode() {}

func (*PullRequestReviewComment) isReactable() {}

func (*PullRequestReviewComment) isRepositoryNode() {}

func (*PullRequestReviewComment) isUpdatable() {}

func (*PullRequestReviewComment) isUpdatableComment() {}

func (*PullRequestReviewComment) isPullRequestTimelineItem() {}

// The connection type for PullRequestReviewComment.
type PullRequestReviewCommentConnection struct {
	// A list of edges.
	Edges []*PullRequestReviewCommentEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*PullRequestReviewComment `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type PullRequestReviewCommentEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *PullRequestReviewComment `json:"node,omitempty"`
}

// The possible states of a pull request review comment.
type PullRequestReviewCommentState string

const (
	// A comment that is part of a pending review
	PullRequestReviewCommentStatePending PullRequestReviewCommentState = "PENDING"
	// A comment that is part of a submitted review
	PullRequestReviewCommentStateSubmitted PullRequestReviewCommentState = "SUBMITTED"
)

// The connection type for PullRequestReview.
type PullRequestReviewConnection struct {
	// A list of edges.
	Edges []*PullRequestReviewEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*PullRequestReview `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// This aggregates pull request reviews made by a user within one repository.
type PullRequestReviewContributionsByRepository struct {
	// The pull request review contributions.
	Contributions *CreatedPullRequestReviewContributionConnection `json:"contributions"`
	// The repository in which the pull request reviews were made.
	Repository *Repository `json:"repository"`
}

// The review status of a pull request.
type PullRequestReviewDecision string

const (
	// The pull request has received an approving review.
	PullRequestReviewDecisionApproved PullRequestReviewDecision = "APPROVED"
	// Changes have been requested on the pull request.
	PullRequestReviewDecisionChangesRequested PullRequestReviewDecision = "CHANGES_REQUESTED"
	// A review is required before the pull request can be merged.
	PullRequestReviewDecisionReviewRequired PullRequestReviewDecision = "REVIEW_REQUIRED"
)

// An edge in a connection.
type PullRequestReviewEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *PullRequestReview `json:"node,omitempty"`
}

// The possible events to perform on a pull request review.
type PullRequestReviewEvent string

const (
	// Submit feedback and approve merging these changes.
	PullRequestReviewEventApprove PullRequestReviewEvent = "APPROVE"
	// Submit general feedback without explicit approval.
	PullRequestReviewEventComment PullRequestReviewEvent = "COMMENT"
	// Dismiss review so it now longer effects merging.
	PullRequestReviewEventDismiss PullRequestReviewEvent = "DISMISS"
	// Submit feedback that must be addressed before merging.
	PullRequestReviewEventRequestChanges PullRequestReviewEvent = "REQUEST_CHANGES"
)

// The possible states of a pull request review.
type PullRequestReviewState string

const (
	// A review allowing the pull request to merge.
	PullRequestReviewStateApproved PullRequestReviewState = "APPROVED"
	// A review blocking the pull request from merging.
	PullRequestReviewStateChangesRequested PullRequestReviewState = "CHANGES_REQUESTED"
	// An informational review.
	PullRequestReviewStateCommented PullRequestReviewState = "COMMENTED"
	// A review that has been dismissed.
	PullRequestReviewStateDismissed PullRequestReviewState = "DISMISSED"
	// A review that has not yet been submitted.
	PullRequestReviewStatePending PullRequestReviewState = "PENDING"
)

// A threaded list of comments for a given pull request.
type PullRequestReviewThread struct {
	// A list of pull request comments associated with the thread.
	Comments *PullRequestReviewCommentConnection `json:"comments"`
	// The side of the diff on which this thread was placed.
	DiffSide DiffSide `json:"diffSide"`
	// The Node ID of the PullRequestReviewThread object
	Id string `json:"id"`
	// Whether or not the thread has been collapsed (resolved)
	IsCollapsed bool `json:"isCollapsed"`
	// Indicates whether this thread was outdated by newer changes.
	IsOutdated bool `json:"isOutdated"`
	// Whether this thread has been resolved
	IsResolved bool `json:"isResolved"`
	// The line in the file to which this thread refers
	Line *int32 `json:"line,omitempty"`
	// The original line in the file to which this thread refers.
	OriginalLine *int32 `json:"originalLine,omitempty"`
	// The original start line in the file to which this thread refers (multi-line only).
	OriginalStartLine *int32 `json:"originalStartLine,omitempty"`
	// Identifies the file path of this thread.
	Path string `json:"path"`
	// Identifies the pull request associated with this thread.
	PullRequest *PullRequest `json:"pullRequest"`
	// Identifies the repository associated with this thread.
	Repository *Repository `json:"repository"`
	// The user who resolved this thread
	ResolvedBy *User `json:"resolvedBy,omitempty"`
	// The side of the diff that the first line of the thread starts on (multi-line only)
	StartDiffSide *DiffSide `json:"startDiffSide,omitempty"`
	// The start line in the file to which this thread refers (multi-line only)
	StartLine *int32 `json:"startLine,omitempty"`
	// The level at which the comments in the corresponding thread are targeted, can be a diff line or a file
	SubjectType PullRequestReviewThreadSubjectType `json:"subjectType"`
	// Indicates whether the current viewer can reply to this thread.
	ViewerCanReply bool `json:"viewerCanReply"`
	// Whether or not the viewer can resolve this thread
	ViewerCanResolve bool `json:"viewerCanResolve"`
	// Whether or not the viewer can unresolve this thread
	ViewerCanUnresolve bool `json:"viewerCanUnresolve"`
}

func (*PullRequestReviewThread) isNode() {}

func (*PullRequestReviewThread) isPullRequestTimelineItem() {}

func (*PullRequestReviewThread) isPullRequestTimelineItems() {}

// Review comment threads for a pull request review.
type PullRequestReviewThreadConnection struct {
	// A list of edges.
	Edges []*PullRequestReviewThreadEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*PullRequestReviewThread `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type PullRequestReviewThreadEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *PullRequestReviewThread `json:"node,omitempty"`
}

// The possible subject types of a pull request review comment.
type PullRequestReviewThreadSubjectType string

const (
	// A comment that has been made against the file of a pull request
	PullRequestReviewThreadSubjectTypeFile PullRequestReviewThreadSubjectType = "FILE"
	// A comment that has been made against the line of a pull request
	PullRequestReviewThreadSubjectTypeLine PullRequestReviewThreadSubjectType = "LINE"
)

// Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits.
type PullRequestRevisionMarker struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The last commit the viewer has seen.
	LastSeenCommit *Commit `json:"lastSeenCommit"`
	// The pull request to which the marker belongs.
	PullRequest *PullRequest `json:"pullRequest"`
}

func (*PullRequestRevisionMarker) isPullRequestTimelineItems() {}

// The possible states of a pull request.
type PullRequestState string

const (
	// A pull request that has been closed without being merged.
	PullRequestStateClosed PullRequestState = "CLOSED"
	// A pull request that has been closed by being merged.
	PullRequestStateMerged PullRequestState = "MERGED"
	// A pull request that is still open.
	PullRequestStateOpen PullRequestState = "OPEN"
)

// A repository pull request template.
type PullRequestTemplate struct {
	// The body of the template
	Body *string `json:"body,omitempty"`
	// The filename of the template
	Filename *string `json:"filename,omitempty"`
	// The repository the template belongs to
	Repository *Repository `json:"repository"`
}

// A threaded list of comments for a given pull request.
type PullRequestThread struct {
	// A list of pull request comments associated with the thread.
	Comments *PullRequestReviewCommentConnection `json:"comments"`
	// The side of the diff on which this thread was placed.
	DiffSide DiffSide `json:"diffSide"`
	// The Node ID of the PullRequestThread object
	Id string `json:"id"`
	// Whether or not the thread has been collapsed (resolved)
	IsCollapsed bool `json:"isCollapsed"`
	// Indicates whether this thread was outdated by newer changes.
	IsOutdated bool `json:"isOutdated"`
	// Whether this thread has been resolved
	IsResolved bool `json:"isResolved"`
	// The line in the file to which this thread refers
	Line *int32 `json:"line,omitempty"`
	// Identifies the file path of this thread.
	Path string `json:"path"`
	// Identifies the pull request associated with this thread.
	PullRequest *PullRequest `json:"pullRequest"`
	// Identifies the repository associated with this thread.
	Repository *Repository `json:"repository"`
	// The user who resolved this thread
	ResolvedBy *User `json:"resolvedBy,omitempty"`
	// The side of the diff that the first line of the thread starts on (multi-line only)
	StartDiffSide *DiffSide `json:"startDiffSide,omitempty"`
	// The line of the first file diff in the thread.
	StartLine *int32 `json:"startLine,omitempty"`
	// The level at which the comments in the corresponding thread are targeted, can be a diff line or a file
	SubjectType PullRequestReviewThreadSubjectType `json:"subjectType"`
	// Indicates whether the current viewer can reply to this thread.
	ViewerCanReply bool `json:"viewerCanReply"`
	// Whether or not the viewer can resolve this thread
	ViewerCanResolve bool `json:"viewerCanResolve"`
	// Whether or not the viewer can unresolve this thread
	ViewerCanUnresolve bool `json:"viewerCanUnresolve"`
}

func (*PullRequestThread) isNode() {}

// The connection type for PullRequestTimelineItem.
type PullRequestTimelineConnection struct {
	// A list of edges.
	Edges []*PullRequestTimelineItemEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*PullRequestTimelineItem `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An item in a pull request timeline
type PullRequestTimelineItem struct {
	// Underlying value of the GraphQL union
	Value PullRequestTimelineItemValue `json:"-"`
}

func (base *PullRequestTimelineItem) UnmarshalJSON(b []byte) error {
	type Raw PullRequestTimelineItem
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "AssignedEvent":
		base.Value = new(AssignedEvent)
	case "BaseRefDeletedEvent":
		base.Value = new(BaseRefDeletedEvent)
	case "BaseRefForcePushedEvent":
		base.Value = new(BaseRefForcePushedEvent)
	case "ClosedEvent":
		base.Value = new(ClosedEvent)
	case "Commit":
		base.Value = new(Commit)
	case "CommitCommentThread":
		base.Value = new(CommitCommentThread)
	case "CrossReferencedEvent":
		base.Value = new(CrossReferencedEvent)
	case "DemilestonedEvent":
		base.Value = new(DemilestonedEvent)
	case "DeployedEvent":
		base.Value = new(DeployedEvent)
	case "DeploymentEnvironmentChangedEvent":
		base.Value = new(DeploymentEnvironmentChangedEvent)
	case "HeadRefDeletedEvent":
		base.Value = new(HeadRefDeletedEvent)
	case "HeadRefForcePushedEvent":
		base.Value = new(HeadRefForcePushedEvent)
	case "HeadRefRestoredEvent":
		base.Value = new(HeadRefRestoredEvent)
	case "IssueComment":
		base.Value = new(IssueComment)
	case "LabeledEvent":
		base.Value = new(LabeledEvent)
	case "LockedEvent":
		base.Value = new(LockedEvent)
	case "MergedEvent":
		base.Value = new(MergedEvent)
	case "MilestonedEvent":
		base.Value = new(MilestonedEvent)
	case "PullRequestReview":
		base.Value = new(PullRequestReview)
	case "PullRequestReviewComment":
		base.Value = new(PullRequestReviewComment)
	case "PullRequestReviewThread":
		base.Value = new(PullRequestReviewThread)
	case "ReferencedEvent":
		base.Value = new(ReferencedEvent)
	case "RenamedTitleEvent":
		base.Value = new(RenamedTitleEvent)
	case "ReopenedEvent":
		base.Value = new(ReopenedEvent)
	case "ReviewDismissedEvent":
		base.Value = new(ReviewDismissedEvent)
	case "ReviewRequestRemovedEvent":
		base.Value = new(ReviewRequestRemovedEvent)
	case "ReviewRequestedEvent":
		base.Value = new(ReviewRequestedEvent)
	case "SubscribedEvent":
		base.Value = new(SubscribedEvent)
	case "UnassignedEvent":
		base.Value = new(UnassignedEvent)
	case "UnlabeledEvent":
		base.Value = new(UnlabeledEvent)
	case "UnlockedEvent":
		base.Value = new(UnlockedEvent)
	case "UnsubscribedEvent":
		base.Value = new(UnsubscribedEvent)
	case "UserBlockedEvent":
		base.Value = new(UserBlockedEvent)
	case "":
		return fmt.Errorf("gqlclient: union PullRequestTimelineItem: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union PullRequestTimelineItem: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// PullRequestTimelineItemValue is one of: AssignedEvent | BaseRefDeletedEvent | BaseRefForcePushedEvent | ClosedEvent | Commit | CommitCommentThread | CrossReferencedEvent | DemilestonedEvent | DeployedEvent | DeploymentEnvironmentChangedEvent | HeadRefDeletedEvent | HeadRefForcePushedEvent | HeadRefRestoredEvent | IssueComment | LabeledEvent | LockedEvent | MergedEvent | MilestonedEvent | PullRequestReview | PullRequestReviewComment | PullRequestReviewThread | ReferencedEvent | RenamedTitleEvent | ReopenedEvent | ReviewDismissedEvent | ReviewRequestRemovedEvent | ReviewRequestedEvent | SubscribedEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnsubscribedEvent | UserBlockedEvent
type PullRequestTimelineItemValue interface {
	isPullRequestTimelineItem()
}

// An edge in a connection.
type PullRequestTimelineItemEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *PullRequestTimelineItem `json:"node,omitempty"`
}

// An item in a pull request timeline
type PullRequestTimelineItems struct {
	// Underlying value of the GraphQL union
	Value PullRequestTimelineItemsValue `json:"-"`
}

func (base *PullRequestTimelineItems) UnmarshalJSON(b []byte) error {
	type Raw PullRequestTimelineItems
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "AddedToMergeQueueEvent":
		base.Value = new(AddedToMergeQueueEvent)
	case "AddedToProjectEvent":
		base.Value = new(AddedToProjectEvent)
	case "AssignedEvent":
		base.Value = new(AssignedEvent)
	case "AutoMergeDisabledEvent":
		base.Value = new(AutoMergeDisabledEvent)
	case "AutoMergeEnabledEvent":
		base.Value = new(AutoMergeEnabledEvent)
	case "AutoRebaseEnabledEvent":
		base.Value = new(AutoRebaseEnabledEvent)
	case "AutoSquashEnabledEvent":
		base.Value = new(AutoSquashEnabledEvent)
	case "AutomaticBaseChangeFailedEvent":
		base.Value = new(AutomaticBaseChangeFailedEvent)
	case "AutomaticBaseChangeSucceededEvent":
		base.Value = new(AutomaticBaseChangeSucceededEvent)
	case "BaseRefChangedEvent":
		base.Value = new(BaseRefChangedEvent)
	case "BaseRefDeletedEvent":
		base.Value = new(BaseRefDeletedEvent)
	case "BaseRefForcePushedEvent":
		base.Value = new(BaseRefForcePushedEvent)
	case "ClosedEvent":
		base.Value = new(ClosedEvent)
	case "CommentDeletedEvent":
		base.Value = new(CommentDeletedEvent)
	case "ConnectedEvent":
		base.Value = new(ConnectedEvent)
	case "ConvertToDraftEvent":
		base.Value = new(ConvertToDraftEvent)
	case "ConvertedNoteToIssueEvent":
		base.Value = new(ConvertedNoteToIssueEvent)
	case "ConvertedToDiscussionEvent":
		base.Value = new(ConvertedToDiscussionEvent)
	case "CrossReferencedEvent":
		base.Value = new(CrossReferencedEvent)
	case "DemilestonedEvent":
		base.Value = new(DemilestonedEvent)
	case "DeployedEvent":
		base.Value = new(DeployedEvent)
	case "DeploymentEnvironmentChangedEvent":
		base.Value = new(DeploymentEnvironmentChangedEvent)
	case "DisconnectedEvent":
		base.Value = new(DisconnectedEvent)
	case "HeadRefDeletedEvent":
		base.Value = new(HeadRefDeletedEvent)
	case "HeadRefForcePushedEvent":
		base.Value = new(HeadRefForcePushedEvent)
	case "HeadRefRestoredEvent":
		base.Value = new(HeadRefRestoredEvent)
	case "IssueComment":
		base.Value = new(IssueComment)
	case "IssueTypeAddedEvent":
		base.Value = new(IssueTypeAddedEvent)
	case "IssueTypeChangedEvent":
		base.Value = new(IssueTypeChangedEvent)
	case "IssueTypeRemovedEvent":
		base.Value = new(IssueTypeRemovedEvent)
	case "LabeledEvent":
		base.Value = new(LabeledEvent)
	case "LockedEvent":
		base.Value = new(LockedEvent)
	case "MarkedAsDuplicateEvent":
		base.Value = new(MarkedAsDuplicateEvent)
	case "MentionedEvent":
		base.Value = new(MentionedEvent)
	case "MergedEvent":
		base.Value = new(MergedEvent)
	case "MilestonedEvent":
		base.Value = new(MilestonedEvent)
	case "MovedColumnsInProjectEvent":
		base.Value = new(MovedColumnsInProjectEvent)
	case "ParentIssueAddedEvent":
		base.Value = new(ParentIssueAddedEvent)
	case "ParentIssueRemovedEvent":
		base.Value = new(ParentIssueRemovedEvent)
	case "PinnedEvent":
		base.Value = new(PinnedEvent)
	case "PullRequestCommit":
		base.Value = new(PullRequestCommit)
	case "PullRequestCommitCommentThread":
		base.Value = new(PullRequestCommitCommentThread)
	case "PullRequestReview":
		base.Value = new(PullRequestReview)
	case "PullRequestReviewThread":
		base.Value = new(PullRequestReviewThread)
	case "PullRequestRevisionMarker":
		base.Value = new(PullRequestRevisionMarker)
	case "ReadyForReviewEvent":
		base.Value = new(ReadyForReviewEvent)
	case "ReferencedEvent":
		base.Value = new(ReferencedEvent)
	case "RemovedFromMergeQueueEvent":
		base.Value = new(RemovedFromMergeQueueEvent)
	case "RemovedFromProjectEvent":
		base.Value = new(RemovedFromProjectEvent)
	case "RenamedTitleEvent":
		base.Value = new(RenamedTitleEvent)
	case "ReopenedEvent":
		base.Value = new(ReopenedEvent)
	case "ReviewDismissedEvent":
		base.Value = new(ReviewDismissedEvent)
	case "ReviewRequestRemovedEvent":
		base.Value = new(ReviewRequestRemovedEvent)
	case "ReviewRequestedEvent":
		base.Value = new(ReviewRequestedEvent)
	case "SubIssueAddedEvent":
		base.Value = new(SubIssueAddedEvent)
	case "SubIssueRemovedEvent":
		base.Value = new(SubIssueRemovedEvent)
	case "SubscribedEvent":
		base.Value = new(SubscribedEvent)
	case "TransferredEvent":
		base.Value = new(TransferredEvent)
	case "UnassignedEvent":
		base.Value = new(UnassignedEvent)
	case "UnlabeledEvent":
		base.Value = new(UnlabeledEvent)
	case "UnlockedEvent":
		base.Value = new(UnlockedEvent)
	case "UnmarkedAsDuplicateEvent":
		base.Value = new(UnmarkedAsDuplicateEvent)
	case "UnpinnedEvent":
		base.Value = new(UnpinnedEvent)
	case "UnsubscribedEvent":
		base.Value = new(UnsubscribedEvent)
	case "UserBlockedEvent":
		base.Value = new(UserBlockedEvent)
	case "":
		return fmt.Errorf("gqlclient: union PullRequestTimelineItems: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union PullRequestTimelineItems: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// PullRequestTimelineItemsValue is one of: AddedToMergeQueueEvent | AddedToProjectEvent | AssignedEvent | AutoMergeDisabledEvent | AutoMergeEnabledEvent | AutoRebaseEnabledEvent | AutoSquashEnabledEvent | AutomaticBaseChangeFailedEvent | AutomaticBaseChangeSucceededEvent | BaseRefChangedEvent | BaseRefDeletedEvent | BaseRefForcePushedEvent | ClosedEvent | CommentDeletedEvent | ConnectedEvent | ConvertToDraftEvent | ConvertedNoteToIssueEvent | ConvertedToDiscussionEvent | CrossReferencedEvent | DemilestonedEvent | DeployedEvent | DeploymentEnvironmentChangedEvent | DisconnectedEvent | HeadRefDeletedEvent | HeadRefForcePushedEvent | HeadRefRestoredEvent | IssueComment | IssueTypeAddedEvent | IssueTypeChangedEvent | IssueTypeRemovedEvent | LabeledEvent | LockedEvent | MarkedAsDuplicateEvent | MentionedEvent | MergedEvent | MilestonedEvent | MovedColumnsInProjectEvent | ParentIssueAddedEvent | ParentIssueRemovedEvent | PinnedEvent | PullRequestCommit | PullRequestCommitCommentThread | PullRequestReview | PullRequestReviewThread | PullRequestRevisionMarker | ReadyForReviewEvent | ReferencedEvent | RemovedFromMergeQueueEvent | RemovedFromProjectEvent | RenamedTitleEvent | ReopenedEvent | ReviewDismissedEvent | ReviewRequestRemovedEvent | ReviewRequestedEvent | SubIssueAddedEvent | SubIssueRemovedEvent | SubscribedEvent | TransferredEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnmarkedAsDuplicateEvent | UnpinnedEvent | UnsubscribedEvent | UserBlockedEvent
type PullRequestTimelineItemsValue interface {
	isPullRequestTimelineItems()
}

// The connection type for PullRequestTimelineItems.
type PullRequestTimelineItemsConnection struct {
	// A list of edges.
	Edges []*PullRequestTimelineItemsEdge `json:"edges,omitempty"`
	// Identifies the count of items after applying `before` and `after` filters.
	FilteredCount int32 `json:"filteredCount"`
	// A list of nodes.
	Nodes []*PullRequestTimelineItems `json:"nodes,omitempty"`
	// Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing.
	PageCount int32 `json:"pageCount"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
	// Identifies the date and time when the timeline was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
}

// An edge in a connection.
type PullRequestTimelineItemsEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *PullRequestTimelineItems `json:"node,omitempty"`
}

// The possible item types found in a timeline.
type PullRequestTimelineItemsItemType string

const (
	// Represents an 'added_to_merge_queue' event on a given pull request.
	PullRequestTimelineItemsItemTypeAddedToMergeQueueEvent PullRequestTimelineItemsItemType = "ADDED_TO_MERGE_QUEUE_EVENT"
	// Represents a 'added_to_project' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeAddedToProjectEvent PullRequestTimelineItemsItemType = "ADDED_TO_PROJECT_EVENT"
	// Represents an 'assigned' event on any assignable object.
	PullRequestTimelineItemsItemTypeAssignedEvent PullRequestTimelineItemsItemType = "ASSIGNED_EVENT"
	// Represents a 'automatic_base_change_failed' event on a given pull request.
	PullRequestTimelineItemsItemTypeAutomaticBaseChangeFailedEvent PullRequestTimelineItemsItemType = "AUTOMATIC_BASE_CHANGE_FAILED_EVENT"
	// Represents a 'automatic_base_change_succeeded' event on a given pull request.
	PullRequestTimelineItemsItemTypeAutomaticBaseChangeSucceededEvent PullRequestTimelineItemsItemType = "AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT"
	// Represents a 'auto_merge_disabled' event on a given pull request.
	PullRequestTimelineItemsItemTypeAutoMergeDisabledEvent PullRequestTimelineItemsItemType = "AUTO_MERGE_DISABLED_EVENT"
	// Represents a 'auto_merge_enabled' event on a given pull request.
	PullRequestTimelineItemsItemTypeAutoMergeEnabledEvent PullRequestTimelineItemsItemType = "AUTO_MERGE_ENABLED_EVENT"
	// Represents a 'auto_rebase_enabled' event on a given pull request.
	PullRequestTimelineItemsItemTypeAutoRebaseEnabledEvent PullRequestTimelineItemsItemType = "AUTO_REBASE_ENABLED_EVENT"
	// Represents a 'auto_squash_enabled' event on a given pull request.
	PullRequestTimelineItemsItemTypeAutoSquashEnabledEvent PullRequestTimelineItemsItemType = "AUTO_SQUASH_ENABLED_EVENT"
	// Represents a 'base_ref_changed' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeBaseRefChangedEvent PullRequestTimelineItemsItemType = "BASE_REF_CHANGED_EVENT"
	// Represents a 'base_ref_deleted' event on a given pull request.
	PullRequestTimelineItemsItemTypeBaseRefDeletedEvent PullRequestTimelineItemsItemType = "BASE_REF_DELETED_EVENT"
	// Represents a 'base_ref_force_pushed' event on a given pull request.
	PullRequestTimelineItemsItemTypeBaseRefForcePushedEvent PullRequestTimelineItemsItemType = "BASE_REF_FORCE_PUSHED_EVENT"
	// Represents a 'closed' event on any `Closable`.
	PullRequestTimelineItemsItemTypeClosedEvent PullRequestTimelineItemsItemType = "CLOSED_EVENT"
	// Represents a 'comment_deleted' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeCommentDeletedEvent PullRequestTimelineItemsItemType = "COMMENT_DELETED_EVENT"
	// Represents a 'connected' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeConnectedEvent PullRequestTimelineItemsItemType = "CONNECTED_EVENT"
	// Represents a 'converted_note_to_issue' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeConvertedNoteToIssueEvent PullRequestTimelineItemsItemType = "CONVERTED_NOTE_TO_ISSUE_EVENT"
	// Represents a 'converted_to_discussion' event on a given issue.
	PullRequestTimelineItemsItemTypeConvertedToDiscussionEvent PullRequestTimelineItemsItemType = "CONVERTED_TO_DISCUSSION_EVENT"
	// Represents a 'convert_to_draft' event on a given pull request.
	PullRequestTimelineItemsItemTypeConvertToDraftEvent PullRequestTimelineItemsItemType = "CONVERT_TO_DRAFT_EVENT"
	// Represents a mention made by one issue or pull request to another.
	PullRequestTimelineItemsItemTypeCrossReferencedEvent PullRequestTimelineItemsItemType = "CROSS_REFERENCED_EVENT"
	// Represents a 'demilestoned' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeDemilestonedEvent PullRequestTimelineItemsItemType = "DEMILESTONED_EVENT"
	// Represents a 'deployed' event on a given pull request.
	PullRequestTimelineItemsItemTypeDeployedEvent PullRequestTimelineItemsItemType = "DEPLOYED_EVENT"
	// Represents a 'deployment_environment_changed' event on a given pull request.
	PullRequestTimelineItemsItemTypeDeploymentEnvironmentChangedEvent PullRequestTimelineItemsItemType = "DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT"
	// Represents a 'disconnected' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeDisconnectedEvent PullRequestTimelineItemsItemType = "DISCONNECTED_EVENT"
	// Represents a 'head_ref_deleted' event on a given pull request.
	PullRequestTimelineItemsItemTypeHeadRefDeletedEvent PullRequestTimelineItemsItemType = "HEAD_REF_DELETED_EVENT"
	// Represents a 'head_ref_force_pushed' event on a given pull request.
	PullRequestTimelineItemsItemTypeHeadRefForcePushedEvent PullRequestTimelineItemsItemType = "HEAD_REF_FORCE_PUSHED_EVENT"
	// Represents a 'head_ref_restored' event on a given pull request.
	PullRequestTimelineItemsItemTypeHeadRefRestoredEvent PullRequestTimelineItemsItemType = "HEAD_REF_RESTORED_EVENT"
	// Represents a comment on an Issue.
	PullRequestTimelineItemsItemTypeIssueComment PullRequestTimelineItemsItemType = "ISSUE_COMMENT"
	// Represents a 'issue_type_added' event on a given issue.
	PullRequestTimelineItemsItemTypeIssueTypeAddedEvent PullRequestTimelineItemsItemType = "ISSUE_TYPE_ADDED_EVENT"
	// Represents a 'issue_type_changed' event on a given issue.
	PullRequestTimelineItemsItemTypeIssueTypeChangedEvent PullRequestTimelineItemsItemType = "ISSUE_TYPE_CHANGED_EVENT"
	// Represents a 'issue_type_removed' event on a given issue.
	PullRequestTimelineItemsItemTypeIssueTypeRemovedEvent PullRequestTimelineItemsItemType = "ISSUE_TYPE_REMOVED_EVENT"
	// Represents a 'labeled' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeLabeledEvent PullRequestTimelineItemsItemType = "LABELED_EVENT"
	// Represents a 'locked' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeLockedEvent PullRequestTimelineItemsItemType = "LOCKED_EVENT"
	// Represents a 'marked_as_duplicate' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeMarkedAsDuplicateEvent PullRequestTimelineItemsItemType = "MARKED_AS_DUPLICATE_EVENT"
	// Represents a 'mentioned' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeMentionedEvent PullRequestTimelineItemsItemType = "MENTIONED_EVENT"
	// Represents a 'merged' event on a given pull request.
	PullRequestTimelineItemsItemTypeMergedEvent PullRequestTimelineItemsItemType = "MERGED_EVENT"
	// Represents a 'milestoned' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeMilestonedEvent PullRequestTimelineItemsItemType = "MILESTONED_EVENT"
	// Represents a 'moved_columns_in_project' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeMovedColumnsInProjectEvent PullRequestTimelineItemsItemType = "MOVED_COLUMNS_IN_PROJECT_EVENT"
	// Represents a 'parent_issue_added' event on a given issue.
	PullRequestTimelineItemsItemTypeParentIssueAddedEvent PullRequestTimelineItemsItemType = "PARENT_ISSUE_ADDED_EVENT"
	// Represents a 'parent_issue_removed' event on a given issue.
	PullRequestTimelineItemsItemTypeParentIssueRemovedEvent PullRequestTimelineItemsItemType = "PARENT_ISSUE_REMOVED_EVENT"
	// Represents a 'pinned' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypePinnedEvent PullRequestTimelineItemsItemType = "PINNED_EVENT"
	// Represents a Git commit part of a pull request.
	PullRequestTimelineItemsItemTypePullRequestCommit PullRequestTimelineItemsItemType = "PULL_REQUEST_COMMIT"
	// Represents a commit comment thread part of a pull request.
	PullRequestTimelineItemsItemTypePullRequestCommitCommentThread PullRequestTimelineItemsItemType = "PULL_REQUEST_COMMIT_COMMENT_THREAD"
	// A review object for a given pull request.
	PullRequestTimelineItemsItemTypePullRequestReview PullRequestTimelineItemsItemType = "PULL_REQUEST_REVIEW"
	// A threaded list of comments for a given pull request.
	PullRequestTimelineItemsItemTypePullRequestReviewThread PullRequestTimelineItemsItemType = "PULL_REQUEST_REVIEW_THREAD"
	// Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits.
	PullRequestTimelineItemsItemTypePullRequestRevisionMarker PullRequestTimelineItemsItemType = "PULL_REQUEST_REVISION_MARKER"
	// Represents a 'ready_for_review' event on a given pull request.
	PullRequestTimelineItemsItemTypeReadyForReviewEvent PullRequestTimelineItemsItemType = "READY_FOR_REVIEW_EVENT"
	// Represents a 'referenced' event on a given `ReferencedSubject`.
	PullRequestTimelineItemsItemTypeReferencedEvent PullRequestTimelineItemsItemType = "REFERENCED_EVENT"
	// Represents a 'removed_from_merge_queue' event on a given pull request.
	PullRequestTimelineItemsItemTypeRemovedFromMergeQueueEvent PullRequestTimelineItemsItemType = "REMOVED_FROM_MERGE_QUEUE_EVENT"
	// Represents a 'removed_from_project' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeRemovedFromProjectEvent PullRequestTimelineItemsItemType = "REMOVED_FROM_PROJECT_EVENT"
	// Represents a 'renamed' event on a given issue or pull request
	PullRequestTimelineItemsItemTypeRenamedTitleEvent PullRequestTimelineItemsItemType = "RENAMED_TITLE_EVENT"
	// Represents a 'reopened' event on any `Closable`.
	PullRequestTimelineItemsItemTypeReopenedEvent PullRequestTimelineItemsItemType = "REOPENED_EVENT"
	// Represents a 'review_dismissed' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeReviewDismissedEvent PullRequestTimelineItemsItemType = "REVIEW_DISMISSED_EVENT"
	// Represents an 'review_requested' event on a given pull request.
	PullRequestTimelineItemsItemTypeReviewRequestedEvent PullRequestTimelineItemsItemType = "REVIEW_REQUESTED_EVENT"
	// Represents an 'review_request_removed' event on a given pull request.
	PullRequestTimelineItemsItemTypeReviewRequestRemovedEvent PullRequestTimelineItemsItemType = "REVIEW_REQUEST_REMOVED_EVENT"
	// Represents a 'subscribed' event on a given `Subscribable`.
	PullRequestTimelineItemsItemTypeSubscribedEvent PullRequestTimelineItemsItemType = "SUBSCRIBED_EVENT"
	// Represents a 'sub_issue_added' event on a given issue.
	PullRequestTimelineItemsItemTypeSubIssueAddedEvent PullRequestTimelineItemsItemType = "SUB_ISSUE_ADDED_EVENT"
	// Represents a 'sub_issue_removed' event on a given issue.
	PullRequestTimelineItemsItemTypeSubIssueRemovedEvent PullRequestTimelineItemsItemType = "SUB_ISSUE_REMOVED_EVENT"
	// Represents a 'transferred' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeTransferredEvent PullRequestTimelineItemsItemType = "TRANSFERRED_EVENT"
	// Represents an 'unassigned' event on any assignable object.
	PullRequestTimelineItemsItemTypeUnassignedEvent PullRequestTimelineItemsItemType = "UNASSIGNED_EVENT"
	// Represents an 'unlabeled' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeUnlabeledEvent PullRequestTimelineItemsItemType = "UNLABELED_EVENT"
	// Represents an 'unlocked' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeUnlockedEvent PullRequestTimelineItemsItemType = "UNLOCKED_EVENT"
	// Represents an 'unmarked_as_duplicate' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeUnmarkedAsDuplicateEvent PullRequestTimelineItemsItemType = "UNMARKED_AS_DUPLICATE_EVENT"
	// Represents an 'unpinned' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeUnpinnedEvent PullRequestTimelineItemsItemType = "UNPINNED_EVENT"
	// Represents an 'unsubscribed' event on a given `Subscribable`.
	PullRequestTimelineItemsItemTypeUnsubscribedEvent PullRequestTimelineItemsItemType = "UNSUBSCRIBED_EVENT"
	// Represents a 'user_blocked' event on a given user.
	PullRequestTimelineItemsItemTypeUserBlockedEvent PullRequestTimelineItemsItemType = "USER_BLOCKED_EVENT"
)

// The possible target states when updating a pull request.
type PullRequestUpdateState string

const (
	// A pull request that has been closed without being merged.
	PullRequestUpdateStateClosed PullRequestUpdateState = "CLOSED"
	// A pull request that is still open.
	PullRequestUpdateStateOpen PullRequestUpdateState = "OPEN"
)

// A Git push.
type Push struct {
	// The Node ID of the Push object
	Id string `json:"id"`
	// The SHA after the push
	NextSha *GitObjectID `json:"nextSha,omitempty"`
	// The permalink for this push.
	Permalink URI `json:"permalink"`
	// The SHA before the push
	PreviousSha *GitObjectID `json:"previousSha,omitempty"`
	// The actor who pushed
	Pusher *Actor `json:"pusher"`
	// The repository that was pushed to
	Repository *Repository `json:"repository"`
}

func (*Push) isNode() {}

// A team, user, or app who has the ability to push to a protected branch.
type PushAllowance struct {
	// The actor that can push.
	Actor *PushAllowanceActor `json:"actor,omitempty"`
	// Identifies the branch protection rule associated with the allowed user, team, or app.
	BranchProtectionRule *BranchProtectionRule `json:"branchProtectionRule,omitempty"`
	// The Node ID of the PushAllowance object
	Id string `json:"id"`
}

func (*PushAllowance) isNode() {}

// Types that can be an actor.
type PushAllowanceActor struct {
	// Underlying value of the GraphQL union
	Value PushAllowanceActorValue `json:"-"`
}

func (base *PushAllowanceActor) UnmarshalJSON(b []byte) error {
	type Raw PushAllowanceActor
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "App":
		base.Value = new(App)
	case "Team":
		base.Value = new(Team)
	case "User":
		base.Value = new(User)
	case "":
		return fmt.Errorf("gqlclient: union PushAllowanceActor: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union PushAllowanceActor: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// PushAllowanceActorValue is one of: App | Team | User
type PushAllowanceActorValue interface {
	isPushAllowanceActor()
}

// The connection type for PushAllowance.
type PushAllowanceConnection struct {
	// A list of edges.
	Edges []*PushAllowanceEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*PushAllowance `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type PushAllowanceEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *PushAllowance `json:"node,omitempty"`
}

// Represents the client's rate limit.
type RateLimit struct {
	// The point cost for the current query counting against the rate limit.
	Cost int32 `json:"cost"`
	// The maximum number of points the client is permitted to consume in a 60 minute window.
	Limit int32 `json:"limit"`
	// The maximum number of nodes this query may return
	NodeCount int32 `json:"nodeCount"`
	// The number of points remaining in the current rate limit window.
	Remaining int32 `json:"remaining"`
	// The time at which the current rate limit window resets in UTC epoch seconds.
	ResetAt DateTime `json:"resetAt"`
	// The number of points used in the current rate limit window.
	Used int32 `json:"used"`
}

// Represents a subject that can be reacted on.
type Reactable struct {
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The Node ID of the Reactable object
	Id string `json:"id"`
	// A list of reactions grouped by content left on the subject.
	ReactionGroups []ReactionGroup `json:"reactionGroups,omitempty"`
	// A list of Reactions left on the Issue.
	Reactions *ReactionConnection `json:"reactions"`
	// Can user react to this subject
	ViewerCanReact bool `json:"viewerCanReact"`

	// Underlying value of the GraphQL interface
	Value ReactableValue `json:"-"`
}

func (base *Reactable) UnmarshalJSON(b []byte) error {
	type Raw Reactable
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "CommitComment":
		base.Value = new(CommitComment)
	case "Discussion":
		base.Value = new(Discussion)
	case "DiscussionComment":
		base.Value = new(DiscussionComment)
	case "Issue":
		base.Value = new(Issue)
	case "IssueComment":
		base.Value = new(IssueComment)
	case "PullRequest":
		base.Value = new(PullRequest)
	case "PullRequestReview":
		base.Value = new(PullRequestReview)
	case "PullRequestReviewComment":
		base.Value = new(PullRequestReviewComment)
	case "Release":
		base.Value = new(Release)
	case "TeamDiscussion":
		base.Value = new(TeamDiscussion)
	case "TeamDiscussionComment":
		base.Value = new(TeamDiscussionComment)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface Reactable: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// ReactableValue is one of: CommitComment | Discussion | DiscussionComment | Issue | IssueComment | PullRequest | PullRequestReview | PullRequestReviewComment | Release | TeamDiscussion | TeamDiscussionComment
type ReactableValue interface {
	isReactable()
}

// The connection type for User.
type ReactingUserConnection struct {
	// A list of edges.
	Edges []*ReactingUserEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*User `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// Represents a user that's made a reaction.
type ReactingUserEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	Node   *User  `json:"node"`
	// The moment when the user made the reaction.
	ReactedAt DateTime `json:"reactedAt"`
}

// An emoji reaction to a particular piece of content.
type Reaction struct {
	// Identifies the emoji reaction.
	Content ReactionContent `json:"content"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The Node ID of the Reaction object
	Id string `json:"id"`
	// The reactable piece of content
	Reactable *Reactable `json:"reactable"`
	// Identifies the user who created this reaction.
	User *User `json:"user,omitempty"`
}

func (*Reaction) isNode() {}

// A list of reactions that have been left on the subject.
type ReactionConnection struct {
	// A list of edges.
	Edges []*ReactionEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*Reaction `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
	// Whether or not the authenticated user has left a reaction on the subject.
	ViewerHasReacted bool `json:"viewerHasReacted"`
}

// Emojis that can be attached to Issues, Pull Requests and Comments.
type ReactionContent string

const (
	// Represents the `:confused:` emoji.
	ReactionContentConfused ReactionContent = "CONFUSED"
	// Represents the `:eyes:` emoji.
	ReactionContentEyes ReactionContent = "EYES"
	// Represents the `:heart:` emoji.
	ReactionContentHeart ReactionContent = "HEART"
	// Represents the `:hooray:` emoji.
	ReactionContentHooray ReactionContent = "HOORAY"
	// Represents the `:laugh:` emoji.
	ReactionContentLaugh ReactionContent = "LAUGH"
	// Represents the `:rocket:` emoji.
	ReactionContentRocket ReactionContent = "ROCKET"
	// Represents the `:-1:` emoji.
	ReactionContentThumbsDown ReactionContent = "THUMBS_DOWN"
	// Represents the `:+1:` emoji.
	ReactionContentThumbsUp ReactionContent = "THUMBS_UP"
)

// An edge in a connection.
type ReactionEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *Reaction `json:"node,omitempty"`
}

// A group of emoji reactions to a particular piece of content.
type ReactionGroup struct {
	// Identifies the emoji reaction.
	Content ReactionContent `json:"content"`
	// Identifies when the reaction was created.
	CreatedAt *DateTime `json:"createdAt,omitempty"`
	// Reactors to the reaction subject with the emotion represented by this reaction group.
	Reactors *ReactorConnection `json:"reactors"`
	// The subject that was reacted to.
	Subject *Reactable `json:"subject"`
	// Users who have reacted to the reaction subject with the emotion represented by this reaction group
	Users *ReactingUserConnection `json:"users"`
	// Whether or not the authenticated user has left a reaction on the subject.
	ViewerHasReacted bool `json:"viewerHasReacted"`
}

// Ways in which lists of reactions can be ordered upon return.
type ReactionOrder struct {
	// The direction in which to order reactions by the specified field.
	Direction OrderDirection `json:"direction"`
	// The field in which to order reactions by.
	Field ReactionOrderField `json:"field"`
}

// A list of fields that reactions can be ordered by.
type ReactionOrderField string

const (
	// Allows ordering a list of reactions by when they were created.
	ReactionOrderFieldCreatedAt ReactionOrderField = "CREATED_AT"
)

// Types that can be assigned to reactions.
type Reactor struct {
	// Underlying value of the GraphQL union
	Value ReactorValue `json:"-"`
}

func (base *Reactor) UnmarshalJSON(b []byte) error {
	type Raw Reactor
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Bot":
		base.Value = new(Bot)
	case "Mannequin":
		base.Value = new(Mannequin)
	case "Organization":
		base.Value = new(Organization)
	case "User":
		base.Value = new(User)
	case "":
		return fmt.Errorf("gqlclient: union Reactor: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union Reactor: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// ReactorValue is one of: Bot | Mannequin | Organization | User
type ReactorValue interface {
	isReactor()
}

// The connection type for Reactor.
type ReactorConnection struct {
	// A list of edges.
	Edges []*ReactorEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*Reactor `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// Represents an author of a reaction.
type ReactorEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The author of the reaction.
	Node Reactor `json:"node"`
	// The moment when the user made the reaction.
	ReactedAt DateTime `json:"reactedAt"`
}

// Represents a 'ready_for_review' event on a given pull request.
type ReadyForReviewEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the ReadyForReviewEvent object
	Id string `json:"id"`
	// PullRequest referenced by event.
	PullRequest *PullRequest `json:"pullRequest"`
	// The HTTP path for this ready for review event.
	ResourcePath URI `json:"resourcePath"`
	// The HTTP URL for this ready for review event.
	Url URI `json:"url"`
}

func (*ReadyForReviewEvent) isPullRequestTimelineItems() {}

func (*ReadyForReviewEvent) isNode() {}

func (*ReadyForReviewEvent) isUniformResourceLocatable() {}

// Represents a Git reference.
type Ref struct {
	// A list of pull requests with this ref as the head ref.
	AssociatedPullRequests *PullRequestConnection `json:"associatedPullRequests"`
	// Branch protection rules for this ref
	BranchProtectionRule *BranchProtectionRule `json:"branchProtectionRule,omitempty"`
	// Compares the current ref as a base ref to another head ref, if the comparison can be made.
	Compare *Comparison `json:"compare,omitempty"`
	// The Node ID of the Ref object
	Id string `json:"id"`
	// The ref name.
	Name string `json:"name"`
	// The ref's prefix, such as `refs/heads/` or `refs/tags/`.
	Prefix string `json:"prefix"`
	// Branch protection rules that are viewable by non-admins
	RefUpdateRule *RefUpdateRule `json:"refUpdateRule,omitempty"`
	// The repository the ref belongs to.
	Repository *Repository `json:"repository"`
	// A list of rules from active Repository and Organization rulesets that apply to this ref.
	Rules *RepositoryRuleConnection `json:"rules,omitempty"`
	// The object the ref points to. Returns null when object does not exist.
	Target *GitObject `json:"target,omitempty"`
}

func (*Ref) isNode() {}

// The connection type for Ref.
type RefConnection struct {
	// A list of edges.
	Edges []*RefEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*Ref `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type RefEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *Ref `json:"node,omitempty"`
}

// Parameters to be used for the ref_name condition
type RefNameConditionTarget struct {
	// Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match.
	Exclude []string `json:"exclude"`
	// Array of ref names or patterns to include. One of these patterns must match
	// for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the
	// default branch or `~ALL` to include all branches.
	Include []string `json:"include"`
}

// Parameters to be used for the ref_name condition
type RefNameConditionTargetInput struct {
	// Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match.
	Exclude []string `json:"exclude"`
	// Array of ref names or patterns to include. One of these patterns must match
	// for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the
	// default branch or `~ALL` to include all branches.
	Include []string `json:"include"`
}

// Ways in which lists of git refs can be ordered upon return.
type RefOrder struct {
	// The direction in which to order refs by the specified field.
	Direction OrderDirection `json:"direction"`
	// The field in which to order refs by.
	Field RefOrderField `json:"field"`
}

// Properties by which ref connections can be ordered.
type RefOrderField string

const (
	// Order refs by their alphanumeric name
	RefOrderFieldAlphabetical RefOrderField = "ALPHABETICAL"
	// Order refs by underlying commit date if the ref prefix is refs/tags/
	RefOrderFieldTagCommitDate RefOrderField = "TAG_COMMIT_DATE"
)

// A ref update
type RefUpdate struct {
	// The value this ref should be updated to.
	AfterOid GitObjectID `json:"afterOid"`
	// The value this ref needs to point to before the update.
	BeforeOid *GitObjectID `json:"beforeOid,omitempty"`
	// Force a non fast-forward update.
	Force *bool `json:"force,omitempty"`
	// The fully qualified name of the ref to be update. For example `refs/heads/branch-name`
	Name GitRefname `json:"name"`
}

// Branch protection rules that are enforced on the viewer.
type RefUpdateRule struct {
	// Can this branch be deleted.
	AllowsDeletions bool `json:"allowsDeletions"`
	// Are force pushes allowed on this branch.
	AllowsForcePushes bool `json:"allowsForcePushes"`
	// Can matching branches be created.
	BlocksCreations bool `json:"blocksCreations"`
	// Identifies the protection rule pattern.
	Pattern string `json:"pattern"`
	// Number of approving reviews required to update matching branches.
	RequiredApprovingReviewCount *int32 `json:"requiredApprovingReviewCount,omitempty"`
	// List of required status check contexts that must pass for commits to be accepted to matching branches.
	RequiredStatusCheckContexts []*string `json:"requiredStatusCheckContexts,omitempty"`
	// Are reviews from code owners required to update matching branches.
	RequiresCodeOwnerReviews bool `json:"requiresCodeOwnerReviews"`
	// Are conversations required to be resolved before merging.
	RequiresConversationResolution bool `json:"requiresConversationResolution"`
	// Are merge commits prohibited from being pushed to this branch.
	RequiresLinearHistory bool `json:"requiresLinearHistory"`
	// Are commits required to be signed.
	RequiresSignatures bool `json:"requiresSignatures"`
	// Is the viewer allowed to dismiss reviews.
	ViewerAllowedToDismissReviews bool `json:"viewerAllowedToDismissReviews"`
	// Can the viewer push to the branch
	ViewerCanPush bool `json:"viewerCanPush"`
}

// Represents a 'referenced' event on a given `ReferencedSubject`.
type ReferencedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the commit associated with the 'referenced' event.
	Commit *Commit `json:"commit,omitempty"`
	// Identifies the repository associated with the 'referenced' event.
	CommitRepository *Repository `json:"commitRepository"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the ReferencedEvent object
	Id string `json:"id"`
	// Reference originated in a different repository.
	IsCrossRepository bool `json:"isCrossRepository"`
	// Checks if the commit message itself references the subject. Can be false in the case of a commit comment reference.
	IsDirectReference bool `json:"isDirectReference"`
	// Object referenced by event.
	Subject ReferencedSubject `json:"subject"`
}

func (*ReferencedEvent) isIssueTimelineItem() {}

func (*ReferencedEvent) isIssueTimelineItems() {}

func (*ReferencedEvent) isPullRequestTimelineItem() {}

func (*ReferencedEvent) isPullRequestTimelineItems() {}

func (*ReferencedEvent) isNode() {}

// Any referencable object
type ReferencedSubject struct {
	// Underlying value of the GraphQL union
	Value ReferencedSubjectValue `json:"-"`
}

func (base *ReferencedSubject) UnmarshalJSON(b []byte) error {
	type Raw ReferencedSubject
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Issue":
		base.Value = new(Issue)
	case "PullRequest":
		base.Value = new(PullRequest)
	case "":
		return fmt.Errorf("gqlclient: union ReferencedSubject: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union ReferencedSubject: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// ReferencedSubjectValue is one of: Issue | PullRequest
type ReferencedSubjectValue interface {
	isReferencedSubject()
}

// Autogenerated input type of RegenerateEnterpriseIdentityProviderRecoveryCodes
type RegenerateEnterpriseIdentityProviderRecoveryCodesInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the enterprise on which to set an identity provider.
	EnterpriseId string `json:"enterpriseId"`
}

// Autogenerated return type of RegenerateEnterpriseIdentityProviderRecoveryCodes.
type RegenerateEnterpriseIdentityProviderRecoveryCodesPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The identity provider for the enterprise.
	IdentityProvider *EnterpriseIdentityProvider `json:"identityProvider,omitempty"`
}

// Autogenerated input type of RegenerateVerifiableDomainToken
type RegenerateVerifiableDomainTokenInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the verifiable domain to regenerate the verification token of.
	Id string `json:"id"`
}

// Autogenerated return type of RegenerateVerifiableDomainToken.
type RegenerateVerifiableDomainTokenPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The verification token that was generated.
	VerificationToken *string `json:"verificationToken,omitempty"`
}

// Autogenerated input type of RejectDeployments
type RejectDeploymentsInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Optional comment for rejecting deployments
	Comment *string `json:"comment,omitempty"`
	// The ids of environments to reject deployments
	EnvironmentIds []string `json:"environmentIds"`
	// The node ID of the workflow run containing the pending deployments.
	WorkflowRunId string `json:"workflowRunId"`
}

// Autogenerated return type of RejectDeployments.
type RejectDeploymentsPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The affected deployments.
	Deployments []Deployment `json:"deployments,omitempty"`
}

// A release contains the content for a release.
type Release struct {
	// The author of the release
	Author *User `json:"author,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The description of the release.
	Description *string `json:"description,omitempty"`
	// The description of this release rendered to HTML.
	DescriptionHTML *HTML `json:"descriptionHTML,omitempty"`
	// The Node ID of the Release object
	Id string `json:"id"`
	// Whether or not the release is a draft
	IsDraft bool `json:"isDraft"`
	// Whether or not the release is the latest releast
	IsLatest bool `json:"isLatest"`
	// Whether or not the release is a prerelease
	IsPrerelease bool `json:"isPrerelease"`
	// A list of users mentioned in the release description
	Mentions *UserConnection `json:"mentions,omitempty"`
	// The title of the release.
	Name *string `json:"name,omitempty"`
	// Identifies the date and time when the release was created.
	PublishedAt *DateTime `json:"publishedAt,omitempty"`
	// A list of reactions grouped by content left on the subject.
	ReactionGroups []ReactionGroup `json:"reactionGroups,omitempty"`
	// A list of Reactions left on the Issue.
	Reactions *ReactionConnection `json:"reactions"`
	// List of releases assets which are dependent on this release.
	ReleaseAssets *ReleaseAssetConnection `json:"releaseAssets"`
	// The repository that the release belongs to.
	Repository *Repository `json:"repository"`
	// The HTTP path for this issue
	ResourcePath URI `json:"resourcePath"`
	// A description of the release, rendered to HTML without any links in it.
	ShortDescriptionHTML *HTML `json:"shortDescriptionHTML,omitempty"`
	// The Git tag the release points to
	Tag *Ref `json:"tag,omitempty"`
	// The tag commit for this release.
	TagCommit *Commit `json:"tagCommit,omitempty"`
	// The name of the release's Git tag
	TagName string `json:"tagName"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The HTTP URL for this issue
	Url URI `json:"url"`
	// Can user react to this subject
	ViewerCanReact bool `json:"viewerCanReact"`
}

func (*Release) isNode() {}

func (*Release) isReactable() {}

func (*Release) isUniformResourceLocatable() {}

// A release asset contains the content for a release asset.
type ReleaseAsset struct {
	// The asset's content-type
	ContentType string `json:"contentType"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The number of times this asset was downloaded
	DownloadCount int32 `json:"downloadCount"`
	// Identifies the URL where you can download the release asset via the browser.
	DownloadUrl URI `json:"downloadUrl"`
	// The Node ID of the ReleaseAsset object
	Id string `json:"id"`
	// Identifies the title of the release asset.
	Name string `json:"name"`
	// Release that the asset is associated with
	Release *Release `json:"release,omitempty"`
	// The size (in bytes) of the asset
	Size int32 `json:"size"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The user that performed the upload
	UploadedBy *User `json:"uploadedBy"`
	// Identifies the URL of the release asset.
	Url URI `json:"url"`
}

func (*ReleaseAsset) isNode() {}

// The connection type for ReleaseAsset.
type ReleaseAssetConnection struct {
	// A list of edges.
	Edges []*ReleaseAssetEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*ReleaseAsset `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type ReleaseAssetEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *ReleaseAsset `json:"node,omitempty"`
}

// The connection type for Release.
type ReleaseConnection struct {
	// A list of edges.
	Edges []*ReleaseEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*Release `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type ReleaseEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *Release `json:"node,omitempty"`
}

// Ways in which lists of releases can be ordered upon return.
type ReleaseOrder struct {
	// The direction in which to order releases by the specified field.
	Direction OrderDirection `json:"direction"`
	// The field in which to order releases by.
	Field ReleaseOrderField `json:"field"`
}

// Properties by which release connections can be ordered.
type ReleaseOrderField string

const (
	// Order releases by creation time
	ReleaseOrderFieldCreatedAt ReleaseOrderField = "CREATED_AT"
	// Order releases alphabetically by name
	ReleaseOrderFieldName ReleaseOrderField = "NAME"
)

// Autogenerated input type of RemoveAssigneesFromAssignable
type RemoveAssigneesFromAssignableInput struct {
	// The id of the assignable object to remove assignees from.
	AssignableId string `json:"assignableId"`
	// The id of users to remove as assignees.
	AssigneeIds []string `json:"assigneeIds"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
}

// Autogenerated return type of RemoveAssigneesFromAssignable.
type RemoveAssigneesFromAssignablePayload struct {
	// The item that was unassigned.
	Assignable *Assignable `json:"assignable,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
}

// Autogenerated input type of RemoveEnterpriseAdmin
type RemoveEnterpriseAdminInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Enterprise ID from which to remove the administrator.
	EnterpriseId string `json:"enterpriseId"`
	// The login of the user to remove as an administrator.
	Login string `json:"login"`
}

// Autogenerated return type of RemoveEnterpriseAdmin.
type RemoveEnterpriseAdminPayload struct {
	// The user who was removed as an administrator.
	Admin *User `json:"admin,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The updated enterprise.
	Enterprise *Enterprise `json:"enterprise,omitempty"`
	// A message confirming the result of removing an administrator.
	Message *string `json:"message,omitempty"`
	// The viewer performing the mutation.
	Viewer *User `json:"viewer,omitempty"`
}

// Autogenerated input type of RemoveEnterpriseIdentityProvider
type RemoveEnterpriseIdentityProviderInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the enterprise from which to remove the identity provider.
	EnterpriseId string `json:"enterpriseId"`
}

// Autogenerated return type of RemoveEnterpriseIdentityProvider.
type RemoveEnterpriseIdentityProviderPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The identity provider that was removed from the enterprise.
	IdentityProvider *EnterpriseIdentityProvider `json:"identityProvider,omitempty"`
}

// Autogenerated input type of RemoveEnterpriseMember
type RemoveEnterpriseMemberInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the enterprise from which the user should be removed.
	EnterpriseId string `json:"enterpriseId"`
	// The ID of the user to remove from the enterprise.
	UserId string `json:"userId"`
}

// Autogenerated return type of RemoveEnterpriseMember.
type RemoveEnterpriseMemberPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The updated enterprise.
	Enterprise *Enterprise `json:"enterprise,omitempty"`
	// The user that was removed from the enterprise.
	User *User `json:"user,omitempty"`
	// The viewer performing the mutation.
	Viewer *User `json:"viewer,omitempty"`
}

// Autogenerated input type of RemoveEnterpriseOrganization
type RemoveEnterpriseOrganizationInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the enterprise from which the organization should be removed.
	EnterpriseId string `json:"enterpriseId"`
	// The ID of the organization to remove from the enterprise.
	OrganizationId string `json:"organizationId"`
}

// Autogenerated return type of RemoveEnterpriseOrganization.
type RemoveEnterpriseOrganizationPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The updated enterprise.
	Enterprise *Enterprise `json:"enterprise,omitempty"`
	// The organization that was removed from the enterprise.
	Organization *Organization `json:"organization,omitempty"`
	// The viewer performing the mutation.
	Viewer *User `json:"viewer,omitempty"`
}

// Autogenerated input type of RemoveEnterpriseSupportEntitlement
type RemoveEnterpriseSupportEntitlementInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the Enterprise which the admin belongs to.
	EnterpriseId string `json:"enterpriseId"`
	// The login of a member who will lose the support entitlement.
	Login string `json:"login"`
}

// Autogenerated return type of RemoveEnterpriseSupportEntitlement.
type RemoveEnterpriseSupportEntitlementPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// A message confirming the result of removing the support entitlement.
	Message *string `json:"message,omitempty"`
}

// Autogenerated input type of RemoveLabelsFromLabelable
type RemoveLabelsFromLabelableInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ids of labels to remove.
	LabelIds []string `json:"labelIds"`
	// The id of the Labelable to remove labels from.
	LabelableId string `json:"labelableId"`
}

// Autogenerated return type of RemoveLabelsFromLabelable.
type RemoveLabelsFromLabelablePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Labelable the labels were removed from.
	Labelable *Labelable `json:"labelable,omitempty"`
}

// Autogenerated input type of RemoveOutsideCollaborator
type RemoveOutsideCollaboratorInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the organization to remove the outside collaborator from.
	OrganizationId string `json:"organizationId"`
	// The ID of the outside collaborator to remove.
	UserId string `json:"userId"`
}

// Autogenerated return type of RemoveOutsideCollaborator.
type RemoveOutsideCollaboratorPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The user that was removed as an outside collaborator.
	RemovedUser *User `json:"removedUser,omitempty"`
}

// Autogenerated input type of RemoveReaction
type RemoveReactionInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The name of the emoji reaction to remove.
	Content ReactionContent `json:"content"`
	// The Node ID of the subject to modify.
	SubjectId string `json:"subjectId"`
}

// Autogenerated return type of RemoveReaction.
type RemoveReactionPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The reaction object.
	Reaction *Reaction `json:"reaction,omitempty"`
	// The reaction groups for the subject.
	ReactionGroups []ReactionGroup `json:"reactionGroups,omitempty"`
	// The reactable subject.
	Subject *Reactable `json:"subject,omitempty"`
}

// Autogenerated input type of RemoveStar
type RemoveStarInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Starrable ID to unstar.
	StarrableId string `json:"starrableId"`
}

// Autogenerated return type of RemoveStar.
type RemoveStarPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The starrable.
	Starrable *Starrable `json:"starrable,omitempty"`
}

// Autogenerated input type of RemoveSubIssue
type RemoveSubIssueInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The id of the issue.
	IssueId string `json:"issueId"`
	// The id of the sub-issue.
	SubIssueId string `json:"subIssueId"`
}

// Autogenerated return type of RemoveSubIssue.
type RemoveSubIssuePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The parent of the sub-issue.
	Issue *Issue `json:"issue,omitempty"`
	// The sub-issue of the parent.
	SubIssue *Issue `json:"subIssue,omitempty"`
}

// Autogenerated input type of RemoveUpvote
type RemoveUpvoteInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Node ID of the discussion or comment to remove upvote.
	SubjectId string `json:"subjectId"`
}

// Autogenerated return type of RemoveUpvote.
type RemoveUpvotePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The votable subject.
	Subject *Votable `json:"subject,omitempty"`
}

// Represents a 'removed_from_merge_queue' event on a given pull request.
type RemovedFromMergeQueueEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the before commit SHA for the 'removed_from_merge_queue' event.
	BeforeCommit *Commit `json:"beforeCommit,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The user who removed this Pull Request from the merge queue
	Enqueuer *User `json:"enqueuer,omitempty"`
	// The Node ID of the RemovedFromMergeQueueEvent object
	Id string `json:"id"`
	// The merge queue where this pull request was removed from.
	MergeQueue *MergeQueue `json:"mergeQueue,omitempty"`
	// PullRequest referenced by event.
	PullRequest *PullRequest `json:"pullRequest,omitempty"`
	// The reason this pull request was removed from the queue.
	Reason *string `json:"reason,omitempty"`
}

func (*RemovedFromMergeQueueEvent) isPullRequestTimelineItems() {}

func (*RemovedFromMergeQueueEvent) isNode() {}

// Represents a 'removed_from_project' event on a given issue or pull request.
type RemovedFromProjectEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The Node ID of the RemovedFromProjectEvent object
	Id string `json:"id"`
	// Project referenced by event.
	Project *Project `json:"project,omitempty"`
	// Column name referenced by this project event.
	ProjectColumnName string `json:"projectColumnName"`
}

func (*RemovedFromProjectEvent) isIssueTimelineItems() {}

func (*RemovedFromProjectEvent) isPullRequestTimelineItems() {}

func (*RemovedFromProjectEvent) isNode() {}

// Represents a 'renamed' event on a given issue or pull request
type RenamedTitleEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the current title of the issue or pull request.
	CurrentTitle string `json:"currentTitle"`
	// The Node ID of the RenamedTitleEvent object
	Id string `json:"id"`
	// Identifies the previous title of the issue or pull request.
	PreviousTitle string `json:"previousTitle"`
	// Subject that was renamed.
	Subject RenamedTitleSubject `json:"subject"`
}

func (*RenamedTitleEvent) isIssueTimelineItem() {}

func (*RenamedTitleEvent) isIssueTimelineItems() {}

func (*RenamedTitleEvent) isPullRequestTimelineItem() {}

func (*RenamedTitleEvent) isPullRequestTimelineItems() {}

func (*RenamedTitleEvent) isNode() {}

// An object which has a renamable title
type RenamedTitleSubject struct {
	// Underlying value of the GraphQL union
	Value RenamedTitleSubjectValue `json:"-"`
}

func (base *RenamedTitleSubject) UnmarshalJSON(b []byte) error {
	type Raw RenamedTitleSubject
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Issue":
		base.Value = new(Issue)
	case "PullRequest":
		base.Value = new(PullRequest)
	case "":
		return fmt.Errorf("gqlclient: union RenamedTitleSubject: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union RenamedTitleSubject: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// RenamedTitleSubjectValue is one of: Issue | PullRequest
type RenamedTitleSubjectValue interface {
	isRenamedTitleSubject()
}

// Autogenerated input type of ReopenDiscussion
type ReopenDiscussionInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// ID of the discussion to be reopened.
	DiscussionId string `json:"discussionId"`
}

// Autogenerated return type of ReopenDiscussion.
type ReopenDiscussionPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The discussion that was reopened.
	Discussion *Discussion `json:"discussion,omitempty"`
}

// Autogenerated input type of ReopenIssue
type ReopenIssueInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// ID of the issue to be opened.
	IssueId string `json:"issueId"`
}

// Autogenerated return type of ReopenIssue.
type ReopenIssuePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The issue that was opened.
	Issue *Issue `json:"issue,omitempty"`
}

// Autogenerated input type of ReopenPullRequest
type ReopenPullRequestInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// ID of the pull request to be reopened.
	PullRequestId string `json:"pullRequestId"`
}

// Autogenerated return type of ReopenPullRequest.
type ReopenPullRequestPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The pull request that was reopened.
	PullRequest *PullRequest `json:"pullRequest,omitempty"`
}

// Represents a 'reopened' event on any `Closable`.
type ReopenedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Object that was reopened.
	Closable *Closable `json:"closable"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the ReopenedEvent object
	Id string `json:"id"`
	// The reason the issue state was changed to open.
	StateReason *IssueStateReason `json:"stateReason,omitempty"`
}

func (*ReopenedEvent) isIssueTimelineItem() {}

func (*ReopenedEvent) isIssueTimelineItems() {}

func (*ReopenedEvent) isPullRequestTimelineItem() {}

func (*ReopenedEvent) isPullRequestTimelineItems() {}

func (*ReopenedEvent) isNode() {}

// Autogenerated input type of ReorderEnvironment
type ReorderEnvironmentInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the environment to modify
	EnvironmentId string `json:"environmentId"`
	// The desired position of the environment
	Position int32 `json:"position"`
}

// Autogenerated return type of ReorderEnvironment.
type ReorderEnvironmentPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The environment that was reordered
	Environment *Environment `json:"environment,omitempty"`
}

// Autogenerated input type of ReplaceActorsForAssignable
type ReplaceActorsForAssignableInput struct {
	// The ids of the actors to replace the existing assignees.
	ActorIds []string `json:"actorIds"`
	// The id of the assignable object to replace the assignees for.
	AssignableId string `json:"assignableId"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
}

// Autogenerated return type of ReplaceActorsForAssignable.
type ReplaceActorsForAssignablePayload struct {
	// The item that was assigned.
	Assignable *Assignable `json:"assignable,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
}

// Audit log entry for a repo.access event.
type RepoAccessAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the RepoAccessAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The repository associated with the action
	Repository *Repository `json:"repository,omitempty"`
	// The name of the repository
	RepositoryName *string `json:"repositoryName,omitempty"`
	// The HTTP path for the repository
	RepositoryResourcePath *URI `json:"repositoryResourcePath,omitempty"`
	// The HTTP URL for the repository
	RepositoryUrl *URI `json:"repositoryUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
	// The visibility of the repository
	Visibility *RepoAccessAuditEntryVisibility `json:"visibility,omitempty"`
}

func (*RepoAccessAuditEntry) isOrganizationAuditEntry() {}

func (*RepoAccessAuditEntry) isAuditEntry() {}

func (*RepoAccessAuditEntry) isNode() {}

func (*RepoAccessAuditEntry) isOrganizationAuditEntryData() {}

func (*RepoAccessAuditEntry) isRepositoryAuditEntryData() {}

// The privacy of a repository
type RepoAccessAuditEntryVisibility string

const (
	// The repository is visible only to users in the same enterprise.
	RepoAccessAuditEntryVisibilityInternal RepoAccessAuditEntryVisibility = "INTERNAL"
	// The repository is visible only to those with explicit access.
	RepoAccessAuditEntryVisibilityPrivate RepoAccessAuditEntryVisibility = "PRIVATE"
	// The repository is visible to everyone.
	RepoAccessAuditEntryVisibilityPublic RepoAccessAuditEntryVisibility = "PUBLIC"
)

// Audit log entry for a repo.add_member event.
type RepoAddMemberAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the RepoAddMemberAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The repository associated with the action
	Repository *Repository `json:"repository,omitempty"`
	// The name of the repository
	RepositoryName *string `json:"repositoryName,omitempty"`
	// The HTTP path for the repository
	RepositoryResourcePath *URI `json:"repositoryResourcePath,omitempty"`
	// The HTTP URL for the repository
	RepositoryUrl *URI `json:"repositoryUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
	// The visibility of the repository
	Visibility *RepoAddMemberAuditEntryVisibility `json:"visibility,omitempty"`
}

func (*RepoAddMemberAuditEntry) isOrganizationAuditEntry() {}

func (*RepoAddMemberAuditEntry) isAuditEntry() {}

func (*RepoAddMemberAuditEntry) isNode() {}

func (*RepoAddMemberAuditEntry) isOrganizationAuditEntryData() {}

func (*RepoAddMemberAuditEntry) isRepositoryAuditEntryData() {}

// The privacy of a repository
type RepoAddMemberAuditEntryVisibility string

const (
	// The repository is visible only to users in the same enterprise.
	RepoAddMemberAuditEntryVisibilityInternal RepoAddMemberAuditEntryVisibility = "INTERNAL"
	// The repository is visible only to those with explicit access.
	RepoAddMemberAuditEntryVisibilityPrivate RepoAddMemberAuditEntryVisibility = "PRIVATE"
	// The repository is visible to everyone.
	RepoAddMemberAuditEntryVisibilityPublic RepoAddMemberAuditEntryVisibility = "PUBLIC"
)

// Audit log entry for a repo.add_topic event.
type RepoAddTopicAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the RepoAddTopicAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The repository associated with the action
	Repository *Repository `json:"repository,omitempty"`
	// The name of the repository
	RepositoryName *string `json:"repositoryName,omitempty"`
	// The HTTP path for the repository
	RepositoryResourcePath *URI `json:"repositoryResourcePath,omitempty"`
	// The HTTP URL for the repository
	RepositoryUrl *URI `json:"repositoryUrl,omitempty"`
	// The name of the topic added to the repository
	Topic *Topic `json:"topic,omitempty"`
	// The name of the topic added to the repository
	TopicName *string `json:"topicName,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*RepoAddTopicAuditEntry) isOrganizationAuditEntry() {}

func (*RepoAddTopicAuditEntry) isAuditEntry() {}

func (*RepoAddTopicAuditEntry) isNode() {}

func (*RepoAddTopicAuditEntry) isOrganizationAuditEntryData() {}

func (*RepoAddTopicAuditEntry) isRepositoryAuditEntryData() {}

func (*RepoAddTopicAuditEntry) isTopicAuditEntryData() {}

// Audit log entry for a repo.archived event.
type RepoArchivedAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the RepoArchivedAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The repository associated with the action
	Repository *Repository `json:"repository,omitempty"`
	// The name of the repository
	RepositoryName *string `json:"repositoryName,omitempty"`
	// The HTTP path for the repository
	RepositoryResourcePath *URI `json:"repositoryResourcePath,omitempty"`
	// The HTTP URL for the repository
	RepositoryUrl *URI `json:"repositoryUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
	// The visibility of the repository
	Visibility *RepoArchivedAuditEntryVisibility `json:"visibility,omitempty"`
}

func (*RepoArchivedAuditEntry) isOrganizationAuditEntry() {}

func (*RepoArchivedAuditEntry) isAuditEntry() {}

func (*RepoArchivedAuditEntry) isNode() {}

func (*RepoArchivedAuditEntry) isOrganizationAuditEntryData() {}

func (*RepoArchivedAuditEntry) isRepositoryAuditEntryData() {}

// The privacy of a repository
type RepoArchivedAuditEntryVisibility string

const (
	// The repository is visible only to users in the same enterprise.
	RepoArchivedAuditEntryVisibilityInternal RepoArchivedAuditEntryVisibility = "INTERNAL"
	// The repository is visible only to those with explicit access.
	RepoArchivedAuditEntryVisibilityPrivate RepoArchivedAuditEntryVisibility = "PRIVATE"
	// The repository is visible to everyone.
	RepoArchivedAuditEntryVisibilityPublic RepoArchivedAuditEntryVisibility = "PUBLIC"
)

// Audit log entry for a repo.change_merge_setting event.
type RepoChangeMergeSettingAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the RepoChangeMergeSettingAuditEntry object
	Id string `json:"id"`
	// Whether the change was to enable (true) or disable (false) the merge type
	IsEnabled *bool `json:"isEnabled,omitempty"`
	// The merge method affected by the change
	MergeType *RepoChangeMergeSettingAuditEntryMergeType `json:"mergeType,omitempty"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The repository associated with the action
	Repository *Repository `json:"repository,omitempty"`
	// The name of the repository
	RepositoryName *string `json:"repositoryName,omitempty"`
	// The HTTP path for the repository
	RepositoryResourcePath *URI `json:"repositoryResourcePath,omitempty"`
	// The HTTP URL for the repository
	RepositoryUrl *URI `json:"repositoryUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*RepoChangeMergeSettingAuditEntry) isOrganizationAuditEntry() {}

func (*RepoChangeMergeSettingAuditEntry) isAuditEntry() {}

func (*RepoChangeMergeSettingAuditEntry) isNode() {}

func (*RepoChangeMergeSettingAuditEntry) isOrganizationAuditEntryData() {}

func (*RepoChangeMergeSettingAuditEntry) isRepositoryAuditEntryData() {}

// The merge options available for pull requests to this repository.
type RepoChangeMergeSettingAuditEntryMergeType string

const (
	// The pull request is added to the base branch in a merge commit.
	RepoChangeMergeSettingAuditEntryMergeTypeMerge RepoChangeMergeSettingAuditEntryMergeType = "MERGE"
	// Commits from the pull request are added onto the base branch individually without a merge commit.
	RepoChangeMergeSettingAuditEntryMergeTypeRebase RepoChangeMergeSettingAuditEntryMergeType = "REBASE"
	// The pull request's commits are squashed into a single commit before they are merged to the base branch.
	RepoChangeMergeSettingAuditEntryMergeTypeSquash RepoChangeMergeSettingAuditEntryMergeType = "SQUASH"
)

// Audit log entry for a repo.config.disable_anonymous_git_access event.
type RepoConfigDisableAnonymousGitAccessAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the RepoConfigDisableAnonymousGitAccessAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The repository associated with the action
	Repository *Repository `json:"repository,omitempty"`
	// The name of the repository
	RepositoryName *string `json:"repositoryName,omitempty"`
	// The HTTP path for the repository
	RepositoryResourcePath *URI `json:"repositoryResourcePath,omitempty"`
	// The HTTP URL for the repository
	RepositoryUrl *URI `json:"repositoryUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*RepoConfigDisableAnonymousGitAccessAuditEntry) isOrganizationAuditEntry() {}

func (*RepoConfigDisableAnonymousGitAccessAuditEntry) isAuditEntry() {}

func (*RepoConfigDisableAnonymousGitAccessAuditEntry) isNode() {}

func (*RepoConfigDisableAnonymousGitAccessAuditEntry) isOrganizationAuditEntryData() {}

func (*RepoConfigDisableAnonymousGitAccessAuditEntry) isRepositoryAuditEntryData() {}

// Audit log entry for a repo.config.disable_collaborators_only event.
type RepoConfigDisableCollaboratorsOnlyAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the RepoConfigDisableCollaboratorsOnlyAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The repository associated with the action
	Repository *Repository `json:"repository,omitempty"`
	// The name of the repository
	RepositoryName *string `json:"repositoryName,omitempty"`
	// The HTTP path for the repository
	RepositoryResourcePath *URI `json:"repositoryResourcePath,omitempty"`
	// The HTTP URL for the repository
	RepositoryUrl *URI `json:"repositoryUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*RepoConfigDisableCollaboratorsOnlyAuditEntry) isOrganizationAuditEntry() {}

func (*RepoConfigDisableCollaboratorsOnlyAuditEntry) isAuditEntry() {}

func (*RepoConfigDisableCollaboratorsOnlyAuditEntry) isNode() {}

func (*RepoConfigDisableCollaboratorsOnlyAuditEntry) isOrganizationAuditEntryData() {}

func (*RepoConfigDisableCollaboratorsOnlyAuditEntry) isRepositoryAuditEntryData() {}

// Audit log entry for a repo.config.disable_contributors_only event.
type RepoConfigDisableContributorsOnlyAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the RepoConfigDisableContributorsOnlyAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The repository associated with the action
	Repository *Repository `json:"repository,omitempty"`
	// The name of the repository
	RepositoryName *string `json:"repositoryName,omitempty"`
	// The HTTP path for the repository
	RepositoryResourcePath *URI `json:"repositoryResourcePath,omitempty"`
	// The HTTP URL for the repository
	RepositoryUrl *URI `json:"repositoryUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*RepoConfigDisableContributorsOnlyAuditEntry) isOrganizationAuditEntry() {}

func (*RepoConfigDisableContributorsOnlyAuditEntry) isAuditEntry() {}

func (*RepoConfigDisableContributorsOnlyAuditEntry) isNode() {}

func (*RepoConfigDisableContributorsOnlyAuditEntry) isOrganizationAuditEntryData() {}

func (*RepoConfigDisableContributorsOnlyAuditEntry) isRepositoryAuditEntryData() {}

// Audit log entry for a repo.config.disable_sockpuppet_disallowed event.
type RepoConfigDisableSockpuppetDisallowedAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the RepoConfigDisableSockpuppetDisallowedAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The repository associated with the action
	Repository *Repository `json:"repository,omitempty"`
	// The name of the repository
	RepositoryName *string `json:"repositoryName,omitempty"`
	// The HTTP path for the repository
	RepositoryResourcePath *URI `json:"repositoryResourcePath,omitempty"`
	// The HTTP URL for the repository
	RepositoryUrl *URI `json:"repositoryUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*RepoConfigDisableSockpuppetDisallowedAuditEntry) isOrganizationAuditEntry() {}

func (*RepoConfigDisableSockpuppetDisallowedAuditEntry) isAuditEntry() {}

func (*RepoConfigDisableSockpuppetDisallowedAuditEntry) isNode() {}

func (*RepoConfigDisableSockpuppetDisallowedAuditEntry) isOrganizationAuditEntryData() {}

func (*RepoConfigDisableSockpuppetDisallowedAuditEntry) isRepositoryAuditEntryData() {}

// Audit log entry for a repo.config.enable_anonymous_git_access event.
type RepoConfigEnableAnonymousGitAccessAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the RepoConfigEnableAnonymousGitAccessAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The repository associated with the action
	Repository *Repository `json:"repository,omitempty"`
	// The name of the repository
	RepositoryName *string `json:"repositoryName,omitempty"`
	// The HTTP path for the repository
	RepositoryResourcePath *URI `json:"repositoryResourcePath,omitempty"`
	// The HTTP URL for the repository
	RepositoryUrl *URI `json:"repositoryUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*RepoConfigEnableAnonymousGitAccessAuditEntry) isOrganizationAuditEntry() {}

func (*RepoConfigEnableAnonymousGitAccessAuditEntry) isAuditEntry() {}

func (*RepoConfigEnableAnonymousGitAccessAuditEntry) isNode() {}

func (*RepoConfigEnableAnonymousGitAccessAuditEntry) isOrganizationAuditEntryData() {}

func (*RepoConfigEnableAnonymousGitAccessAuditEntry) isRepositoryAuditEntryData() {}

// Audit log entry for a repo.config.enable_collaborators_only event.
type RepoConfigEnableCollaboratorsOnlyAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the RepoConfigEnableCollaboratorsOnlyAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The repository associated with the action
	Repository *Repository `json:"repository,omitempty"`
	// The name of the repository
	RepositoryName *string `json:"repositoryName,omitempty"`
	// The HTTP path for the repository
	RepositoryResourcePath *URI `json:"repositoryResourcePath,omitempty"`
	// The HTTP URL for the repository
	RepositoryUrl *URI `json:"repositoryUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*RepoConfigEnableCollaboratorsOnlyAuditEntry) isOrganizationAuditEntry() {}

func (*RepoConfigEnableCollaboratorsOnlyAuditEntry) isAuditEntry() {}

func (*RepoConfigEnableCollaboratorsOnlyAuditEntry) isNode() {}

func (*RepoConfigEnableCollaboratorsOnlyAuditEntry) isOrganizationAuditEntryData() {}

func (*RepoConfigEnableCollaboratorsOnlyAuditEntry) isRepositoryAuditEntryData() {}

// Audit log entry for a repo.config.enable_contributors_only event.
type RepoConfigEnableContributorsOnlyAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the RepoConfigEnableContributorsOnlyAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The repository associated with the action
	Repository *Repository `json:"repository,omitempty"`
	// The name of the repository
	RepositoryName *string `json:"repositoryName,omitempty"`
	// The HTTP path for the repository
	RepositoryResourcePath *URI `json:"repositoryResourcePath,omitempty"`
	// The HTTP URL for the repository
	RepositoryUrl *URI `json:"repositoryUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*RepoConfigEnableContributorsOnlyAuditEntry) isOrganizationAuditEntry() {}

func (*RepoConfigEnableContributorsOnlyAuditEntry) isAuditEntry() {}

func (*RepoConfigEnableContributorsOnlyAuditEntry) isNode() {}

func (*RepoConfigEnableContributorsOnlyAuditEntry) isOrganizationAuditEntryData() {}

func (*RepoConfigEnableContributorsOnlyAuditEntry) isRepositoryAuditEntryData() {}

// Audit log entry for a repo.config.enable_sockpuppet_disallowed event.
type RepoConfigEnableSockpuppetDisallowedAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the RepoConfigEnableSockpuppetDisallowedAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The repository associated with the action
	Repository *Repository `json:"repository,omitempty"`
	// The name of the repository
	RepositoryName *string `json:"repositoryName,omitempty"`
	// The HTTP path for the repository
	RepositoryResourcePath *URI `json:"repositoryResourcePath,omitempty"`
	// The HTTP URL for the repository
	RepositoryUrl *URI `json:"repositoryUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*RepoConfigEnableSockpuppetDisallowedAuditEntry) isOrganizationAuditEntry() {}

func (*RepoConfigEnableSockpuppetDisallowedAuditEntry) isAuditEntry() {}

func (*RepoConfigEnableSockpuppetDisallowedAuditEntry) isNode() {}

func (*RepoConfigEnableSockpuppetDisallowedAuditEntry) isOrganizationAuditEntryData() {}

func (*RepoConfigEnableSockpuppetDisallowedAuditEntry) isRepositoryAuditEntryData() {}

// Audit log entry for a repo.config.lock_anonymous_git_access event.
type RepoConfigLockAnonymousGitAccessAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the RepoConfigLockAnonymousGitAccessAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The repository associated with the action
	Repository *Repository `json:"repository,omitempty"`
	// The name of the repository
	RepositoryName *string `json:"repositoryName,omitempty"`
	// The HTTP path for the repository
	RepositoryResourcePath *URI `json:"repositoryResourcePath,omitempty"`
	// The HTTP URL for the repository
	RepositoryUrl *URI `json:"repositoryUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*RepoConfigLockAnonymousGitAccessAuditEntry) isOrganizationAuditEntry() {}

func (*RepoConfigLockAnonymousGitAccessAuditEntry) isAuditEntry() {}

func (*RepoConfigLockAnonymousGitAccessAuditEntry) isNode() {}

func (*RepoConfigLockAnonymousGitAccessAuditEntry) isOrganizationAuditEntryData() {}

func (*RepoConfigLockAnonymousGitAccessAuditEntry) isRepositoryAuditEntryData() {}

// Audit log entry for a repo.config.unlock_anonymous_git_access event.
type RepoConfigUnlockAnonymousGitAccessAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the RepoConfigUnlockAnonymousGitAccessAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The repository associated with the action
	Repository *Repository `json:"repository,omitempty"`
	// The name of the repository
	RepositoryName *string `json:"repositoryName,omitempty"`
	// The HTTP path for the repository
	RepositoryResourcePath *URI `json:"repositoryResourcePath,omitempty"`
	// The HTTP URL for the repository
	RepositoryUrl *URI `json:"repositoryUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*RepoConfigUnlockAnonymousGitAccessAuditEntry) isOrganizationAuditEntry() {}

func (*RepoConfigUnlockAnonymousGitAccessAuditEntry) isAuditEntry() {}

func (*RepoConfigUnlockAnonymousGitAccessAuditEntry) isNode() {}

func (*RepoConfigUnlockAnonymousGitAccessAuditEntry) isOrganizationAuditEntryData() {}

func (*RepoConfigUnlockAnonymousGitAccessAuditEntry) isRepositoryAuditEntryData() {}

// Audit log entry for a repo.create event.
type RepoCreateAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The name of the parent repository for this forked repository.
	ForkParentName *string `json:"forkParentName,omitempty"`
	// The name of the root repository for this network.
	ForkSourceName *string `json:"forkSourceName,omitempty"`
	// The Node ID of the RepoCreateAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The repository associated with the action
	Repository *Repository `json:"repository,omitempty"`
	// The name of the repository
	RepositoryName *string `json:"repositoryName,omitempty"`
	// The HTTP path for the repository
	RepositoryResourcePath *URI `json:"repositoryResourcePath,omitempty"`
	// The HTTP URL for the repository
	RepositoryUrl *URI `json:"repositoryUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
	// The visibility of the repository
	Visibility *RepoCreateAuditEntryVisibility `json:"visibility,omitempty"`
}

func (*RepoCreateAuditEntry) isOrganizationAuditEntry() {}

func (*RepoCreateAuditEntry) isAuditEntry() {}

func (*RepoCreateAuditEntry) isNode() {}

func (*RepoCreateAuditEntry) isOrganizationAuditEntryData() {}

func (*RepoCreateAuditEntry) isRepositoryAuditEntryData() {}

// The privacy of a repository
type RepoCreateAuditEntryVisibility string

const (
	// The repository is visible only to users in the same enterprise.
	RepoCreateAuditEntryVisibilityInternal RepoCreateAuditEntryVisibility = "INTERNAL"
	// The repository is visible only to those with explicit access.
	RepoCreateAuditEntryVisibilityPrivate RepoCreateAuditEntryVisibility = "PRIVATE"
	// The repository is visible to everyone.
	RepoCreateAuditEntryVisibilityPublic RepoCreateAuditEntryVisibility = "PUBLIC"
)

// Audit log entry for a repo.destroy event.
type RepoDestroyAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the RepoDestroyAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The repository associated with the action
	Repository *Repository `json:"repository,omitempty"`
	// The name of the repository
	RepositoryName *string `json:"repositoryName,omitempty"`
	// The HTTP path for the repository
	RepositoryResourcePath *URI `json:"repositoryResourcePath,omitempty"`
	// The HTTP URL for the repository
	RepositoryUrl *URI `json:"repositoryUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
	// The visibility of the repository
	Visibility *RepoDestroyAuditEntryVisibility `json:"visibility,omitempty"`
}

func (*RepoDestroyAuditEntry) isOrganizationAuditEntry() {}

func (*RepoDestroyAuditEntry) isAuditEntry() {}

func (*RepoDestroyAuditEntry) isNode() {}

func (*RepoDestroyAuditEntry) isOrganizationAuditEntryData() {}

func (*RepoDestroyAuditEntry) isRepositoryAuditEntryData() {}

// The privacy of a repository
type RepoDestroyAuditEntryVisibility string

const (
	// The repository is visible only to users in the same enterprise.
	RepoDestroyAuditEntryVisibilityInternal RepoDestroyAuditEntryVisibility = "INTERNAL"
	// The repository is visible only to those with explicit access.
	RepoDestroyAuditEntryVisibilityPrivate RepoDestroyAuditEntryVisibility = "PRIVATE"
	// The repository is visible to everyone.
	RepoDestroyAuditEntryVisibilityPublic RepoDestroyAuditEntryVisibility = "PUBLIC"
)

// Audit log entry for a repo.remove_member event.
type RepoRemoveMemberAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the RepoRemoveMemberAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The repository associated with the action
	Repository *Repository `json:"repository,omitempty"`
	// The name of the repository
	RepositoryName *string `json:"repositoryName,omitempty"`
	// The HTTP path for the repository
	RepositoryResourcePath *URI `json:"repositoryResourcePath,omitempty"`
	// The HTTP URL for the repository
	RepositoryUrl *URI `json:"repositoryUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
	// The visibility of the repository
	Visibility *RepoRemoveMemberAuditEntryVisibility `json:"visibility,omitempty"`
}

func (*RepoRemoveMemberAuditEntry) isOrganizationAuditEntry() {}

func (*RepoRemoveMemberAuditEntry) isAuditEntry() {}

func (*RepoRemoveMemberAuditEntry) isNode() {}

func (*RepoRemoveMemberAuditEntry) isOrganizationAuditEntryData() {}

func (*RepoRemoveMemberAuditEntry) isRepositoryAuditEntryData() {}

// The privacy of a repository
type RepoRemoveMemberAuditEntryVisibility string

const (
	// The repository is visible only to users in the same enterprise.
	RepoRemoveMemberAuditEntryVisibilityInternal RepoRemoveMemberAuditEntryVisibility = "INTERNAL"
	// The repository is visible only to those with explicit access.
	RepoRemoveMemberAuditEntryVisibilityPrivate RepoRemoveMemberAuditEntryVisibility = "PRIVATE"
	// The repository is visible to everyone.
	RepoRemoveMemberAuditEntryVisibilityPublic RepoRemoveMemberAuditEntryVisibility = "PUBLIC"
)

// Audit log entry for a repo.remove_topic event.
type RepoRemoveTopicAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the RepoRemoveTopicAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The repository associated with the action
	Repository *Repository `json:"repository,omitempty"`
	// The name of the repository
	RepositoryName *string `json:"repositoryName,omitempty"`
	// The HTTP path for the repository
	RepositoryResourcePath *URI `json:"repositoryResourcePath,omitempty"`
	// The HTTP URL for the repository
	RepositoryUrl *URI `json:"repositoryUrl,omitempty"`
	// The name of the topic added to the repository
	Topic *Topic `json:"topic,omitempty"`
	// The name of the topic added to the repository
	TopicName *string `json:"topicName,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*RepoRemoveTopicAuditEntry) isOrganizationAuditEntry() {}

func (*RepoRemoveTopicAuditEntry) isAuditEntry() {}

func (*RepoRemoveTopicAuditEntry) isNode() {}

func (*RepoRemoveTopicAuditEntry) isOrganizationAuditEntryData() {}

func (*RepoRemoveTopicAuditEntry) isRepositoryAuditEntryData() {}

func (*RepoRemoveTopicAuditEntry) isTopicAuditEntryData() {}

// The reasons a piece of content can be reported or minimized.
type ReportedContentClassifiers string

const (
	// An abusive or harassing piece of content
	ReportedContentClassifiersAbuse ReportedContentClassifiers = "ABUSE"
	// A duplicated piece of content
	ReportedContentClassifiersDuplicate ReportedContentClassifiers = "DUPLICATE"
	// An irrelevant piece of content
	ReportedContentClassifiersOffTopic ReportedContentClassifiers = "OFF_TOPIC"
	// An outdated piece of content
	ReportedContentClassifiersOutdated ReportedContentClassifiers = "OUTDATED"
	// The content has been resolved
	ReportedContentClassifiersResolved ReportedContentClassifiers = "RESOLVED"
	// A spammy piece of content
	ReportedContentClassifiersSpam ReportedContentClassifiers = "SPAM"
)

// A repository contains the content for a project.
type Repository struct {
	// Whether or not a pull request head branch that is behind its base branch can
	// always be updated even if it is not required to be up to date before merging.
	AllowUpdateBranch bool `json:"allowUpdateBranch"`
	// Identifies the date and time when the repository was archived.
	ArchivedAt *DateTime `json:"archivedAt,omitempty"`
	// A list of users that can be assigned to issues in this repository.
	AssignableUsers *UserConnection `json:"assignableUsers"`
	// Whether or not Auto-merge can be enabled on pull requests in this repository.
	AutoMergeAllowed bool `json:"autoMergeAllowed"`
	// A list of branch protection rules for this repository.
	BranchProtectionRules *BranchProtectionRuleConnection `json:"branchProtectionRules"`
	// Returns the code of conduct for this repository
	CodeOfConduct *CodeOfConduct `json:"codeOfConduct,omitempty"`
	// Information extracted from the repository's `CODEOWNERS` file.
	Codeowners *RepositoryCodeowners `json:"codeowners,omitempty"`
	// A list of collaborators associated with the repository.
	Collaborators *RepositoryCollaboratorConnection `json:"collaborators,omitempty"`
	// A list of commit comments associated with the repository.
	CommitComments *CommitCommentConnection `json:"commitComments"`
	// Returns a list of contact links associated to the repository
	ContactLinks []RepositoryContactLink `json:"contactLinks,omitempty"`
	// Returns the contributing guidelines for this repository.
	ContributingGuidelines *ContributingGuidelines `json:"contributingGuidelines,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The Ref associated with the repository's default branch.
	DefaultBranchRef *Ref `json:"defaultBranchRef,omitempty"`
	// Whether or not branches are automatically deleted when merged in this repository.
	DeleteBranchOnMerge bool `json:"deleteBranchOnMerge"`
	// A list of dependency manifests contained in the repository
	DependencyGraphManifests *DependencyGraphManifestConnection `json:"dependencyGraphManifests,omitempty"`
	// A list of deploy keys that are on this repository.
	DeployKeys *DeployKeyConnection `json:"deployKeys"`
	// Deployments associated with the repository
	Deployments *DeploymentConnection `json:"deployments"`
	// The description of the repository.
	Description *string `json:"description,omitempty"`
	// The description of the repository rendered to HTML.
	DescriptionHTML HTML `json:"descriptionHTML"`
	// Returns a single discussion from the current repository by number.
	Discussion *Discussion `json:"discussion,omitempty"`
	// A list of discussion categories that are available in the repository.
	DiscussionCategories *DiscussionCategoryConnection `json:"discussionCategories"`
	// A discussion category by slug.
	DiscussionCategory *DiscussionCategory `json:"discussionCategory,omitempty"`
	// A list of discussions that have been opened in the repository.
	Discussions *DiscussionConnection `json:"discussions"`
	// The number of kilobytes this repository occupies on disk.
	DiskUsage *int32 `json:"diskUsage,omitempty"`
	// Returns a single active environment from the current repository by name.
	Environment *Environment `json:"environment,omitempty"`
	// A list of environments that are in this repository.
	Environments *EnvironmentConnection `json:"environments"`
	// Returns how many forks there are of this repository in the whole network.
	ForkCount int32 `json:"forkCount"`
	// Whether this repository allows forks.
	ForkingAllowed bool `json:"forkingAllowed"`
	// A list of direct forked repositories.
	Forks *RepositoryConnection `json:"forks"`
	// The funding links for this repository
	FundingLinks []FundingLink `json:"fundingLinks"`
	// Indicates if the repository has the Discussions feature enabled.
	HasDiscussionsEnabled bool `json:"hasDiscussionsEnabled"`
	// Indicates if the repository has issues feature enabled.
	HasIssuesEnabled bool `json:"hasIssuesEnabled"`
	// Indicates if the repository has the Projects feature enabled.
	HasProjectsEnabled bool `json:"hasProjectsEnabled"`
	// Indicates if the repository displays a Sponsor button for financial contributions.
	HasSponsorshipsEnabled bool `json:"hasSponsorshipsEnabled"`
	// Whether vulnerability alerts are enabled for the repository.
	HasVulnerabilityAlertsEnabled bool `json:"hasVulnerabilityAlertsEnabled"`
	// Indicates if the repository has wiki feature enabled.
	HasWikiEnabled bool `json:"hasWikiEnabled"`
	// The repository's URL.
	HomepageUrl *URI `json:"homepageUrl,omitempty"`
	// The Node ID of the Repository object
	Id string `json:"id"`
	// The interaction ability settings for this repository.
	InteractionAbility *RepositoryInteractionAbility `json:"interactionAbility,omitempty"`
	// Indicates if the repository is unmaintained.
	IsArchived bool `json:"isArchived"`
	// Returns true if blank issue creation is allowed
	IsBlankIssuesEnabled bool `json:"isBlankIssuesEnabled"`
	// Returns whether or not this repository disabled.
	IsDisabled bool `json:"isDisabled"`
	// Returns whether or not this repository is empty.
	IsEmpty bool `json:"isEmpty"`
	// Identifies if the repository is a fork.
	IsFork bool `json:"isFork"`
	// Indicates if a repository is either owned by an organization, or is a private fork of an organization repository.
	IsInOrganization bool `json:"isInOrganization"`
	// Indicates if the repository has been locked or not.
	IsLocked bool `json:"isLocked"`
	// Identifies if the repository is a mirror.
	IsMirror bool `json:"isMirror"`
	// Identifies if the repository is private or internal.
	IsPrivate bool `json:"isPrivate"`
	// Returns true if this repository has a security policy
	IsSecurityPolicyEnabled *bool `json:"isSecurityPolicyEnabled,omitempty"`
	// Identifies if the repository is a template that can be used to generate new repositories.
	IsTemplate bool `json:"isTemplate"`
	// Is this repository a user configuration repository?
	IsUserConfigurationRepository bool `json:"isUserConfigurationRepository"`
	// Returns a single issue from the current repository by number.
	Issue *Issue `json:"issue,omitempty"`
	// Returns a single issue-like object from the current repository by number.
	IssueOrPullRequest *IssueOrPullRequest `json:"issueOrPullRequest,omitempty"`
	// Returns a list of issue templates associated to the repository
	IssueTemplates []IssueTemplate `json:"issueTemplates,omitempty"`
	// Returns a single issue type by name
	IssueType *IssueType `json:"issueType,omitempty"`
	// A list of the repository's issue types
	IssueTypes *IssueTypeConnection `json:"issueTypes,omitempty"`
	// A list of issues that have been opened in the repository.
	Issues *IssueConnection `json:"issues"`
	// Returns a single label by name
	Label *Label `json:"label,omitempty"`
	// A list of labels associated with the repository.
	Labels *LabelConnection `json:"labels,omitempty"`
	// A list containing a breakdown of the language composition of the repository.
	Languages *LanguageConnection `json:"languages,omitempty"`
	// Get the latest release for the repository if one exists.
	LatestRelease *Release `json:"latestRelease,omitempty"`
	// The license associated with the repository
	LicenseInfo *License `json:"licenseInfo,omitempty"`
	// The reason the repository has been locked.
	LockReason *RepositoryLockReason `json:"lockReason,omitempty"`
	// A list of Users that can be mentioned in the context of the repository.
	MentionableUsers *UserConnection `json:"mentionableUsers"`
	// Whether or not PRs are merged with a merge commit on this repository.
	MergeCommitAllowed bool `json:"mergeCommitAllowed"`
	// How the default commit message will be generated when merging a pull request.
	MergeCommitMessage MergeCommitMessage `json:"mergeCommitMessage"`
	// How the default commit title will be generated when merging a pull request.
	MergeCommitTitle MergeCommitTitle `json:"mergeCommitTitle"`
	// The merge queue for a specified branch, otherwise the default branch if not provided.
	MergeQueue *MergeQueue `json:"mergeQueue,omitempty"`
	// Returns a single milestone from the current repository by number.
	Milestone *Milestone `json:"milestone,omitempty"`
	// A list of milestones associated with the repository.
	Milestones *MilestoneConnection `json:"milestones,omitempty"`
	// The repository's original mirror URL.
	MirrorUrl *URI `json:"mirrorUrl,omitempty"`
	// The name of the repository.
	Name string `json:"name"`
	// The repository's name with owner.
	NameWithOwner string `json:"nameWithOwner"`
	// A Git object in the repository
	Object *GitObject `json:"object,omitempty"`
	// The image used to represent this repository in Open Graph data.
	OpenGraphImageUrl URI `json:"openGraphImageUrl"`
	// The User owner of the repository.
	Owner *RepositoryOwner `json:"owner"`
	// A list of packages under the owner.
	Packages *PackageConnection `json:"packages"`
	// The repository parent, if this is a fork.
	Parent *Repository `json:"parent,omitempty"`
	// A list of discussions that have been pinned in this repository.
	PinnedDiscussions *PinnedDiscussionConnection `json:"pinnedDiscussions"`
	// A list of pinned environments for this repository.
	PinnedEnvironments *PinnedEnvironmentConnection `json:"pinnedEnvironments,omitempty"`
	// A list of pinned issues for this repository.
	PinnedIssues *PinnedIssueConnection `json:"pinnedIssues,omitempty"`
	// Returns information about the availability of certain features and limits based on the repository's billing plan.
	PlanFeatures *RepositoryPlanFeatures `json:"planFeatures"`
	// The primary language of the repository's code.
	PrimaryLanguage *Language `json:"primaryLanguage,omitempty"`
	// Find project by number.
	Project *Project `json:"project,omitempty"`
	// Finds and returns the Project according to the provided Project number.
	ProjectV2 *ProjectV2 `json:"projectV2,omitempty"`
	// A list of projects under the owner.
	Projects *ProjectConnection `json:"projects"`
	// The HTTP path listing the repository's projects
	ProjectsResourcePath URI `json:"projectsResourcePath"`
	// The HTTP URL listing the repository's projects
	ProjectsUrl URI `json:"projectsUrl"`
	// List of projects linked to this repository.
	ProjectsV2 *ProjectV2Connection `json:"projectsV2"`
	// Returns a single pull request from the current repository by number.
	PullRequest *PullRequest `json:"pullRequest,omitempty"`
	// Returns a list of pull request templates associated to the repository
	PullRequestTemplates []PullRequestTemplate `json:"pullRequestTemplates,omitempty"`
	// A list of pull requests that have been opened in the repository.
	PullRequests *PullRequestConnection `json:"pullRequests"`
	// Identifies the date and time when the repository was last pushed to.
	PushedAt *DateTime `json:"pushedAt,omitempty"`
	// Whether or not rebase-merging is enabled on this repository.
	RebaseMergeAllowed bool `json:"rebaseMergeAllowed"`
	// Recent projects that this user has modified in the context of the owner.
	RecentProjects *ProjectV2Connection `json:"recentProjects"`
	// Fetch a given ref from the repository
	Ref *Ref `json:"ref,omitempty"`
	// Fetch a list of refs from the repository
	Refs *RefConnection `json:"refs,omitempty"`
	// Lookup a single release given various criteria.
	Release *Release `json:"release,omitempty"`
	// List of releases which are dependent on this repository.
	Releases *ReleaseConnection `json:"releases"`
	// A list of applied repository-topic associations for this repository.
	RepositoryTopics *RepositoryTopicConnection `json:"repositoryTopics"`
	// The HTTP path for this repository
	ResourcePath URI `json:"resourcePath"`
	// Returns a single ruleset from the current repository by ID.
	Ruleset *RepositoryRuleset `json:"ruleset,omitempty"`
	// A list of rulesets for this repository.
	Rulesets *RepositoryRulesetConnection `json:"rulesets,omitempty"`
	// The security policy URL.
	SecurityPolicyUrl *URI `json:"securityPolicyUrl,omitempty"`
	// A description of the repository, rendered to HTML without any links in it.
	ShortDescriptionHTML HTML `json:"shortDescriptionHTML"`
	// Whether or not squash-merging is enabled on this repository.
	SquashMergeAllowed bool `json:"squashMergeAllowed"`
	// How the default commit message will be generated when squash merging a pull request.
	SquashMergeCommitMessage SquashMergeCommitMessage `json:"squashMergeCommitMessage"`
	// How the default commit title will be generated when squash merging a pull request.
	SquashMergeCommitTitle SquashMergeCommitTitle `json:"squashMergeCommitTitle"`
	// Whether a squash merge commit can use the pull request title as default.
	SquashPrTitleUsedAsDefault bool `json:"squashPrTitleUsedAsDefault"`
	// The SSH URL to clone this repository
	SshUrl GitSSHRemote `json:"sshUrl"`
	// Returns a count of how many stargazers there are on this object
	StargazerCount int32 `json:"stargazerCount"`
	// A list of users who have starred this starrable.
	Stargazers *StargazerConnection `json:"stargazers"`
	// Returns a list of all submodules in this repository parsed from the
	// .gitmodules file as of the default branch's HEAD commit.
	Submodules *SubmoduleConnection `json:"submodules"`
	// A list of suggested actors that can be attributed to content in this repository.
	SuggestedActors *ActorConnection `json:"suggestedActors"`
	// Temporary authentication token for cloning this repository.
	TempCloneToken *string `json:"tempCloneToken,omitempty"`
	// The repository from which this repository was generated, if any.
	TemplateRepository *Repository `json:"templateRepository,omitempty"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The HTTP URL for this repository
	Url URI `json:"url"`
	// Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar.
	UsesCustomOpenGraphImage bool `json:"usesCustomOpenGraphImage"`
	// Indicates whether the viewer has admin permissions on this repository.
	ViewerCanAdminister bool `json:"viewerCanAdminister"`
	// Can the current viewer create new projects on this owner.
	ViewerCanCreateProjects bool `json:"viewerCanCreateProjects"`
	// Check if the viewer is able to change their subscription status for the repository.
	ViewerCanSubscribe bool `json:"viewerCanSubscribe"`
	// Indicates whether the viewer can update the topics of this repository.
	ViewerCanUpdateTopics bool `json:"viewerCanUpdateTopics"`
	// The last commit email for the viewer.
	ViewerDefaultCommitEmail *string `json:"viewerDefaultCommitEmail,omitempty"`
	// The last used merge method by the viewer or the default for the repository.
	ViewerDefaultMergeMethod PullRequestMergeMethod `json:"viewerDefaultMergeMethod"`
	// Returns a boolean indicating whether the viewing user has starred this starrable.
	ViewerHasStarred bool `json:"viewerHasStarred"`
	// The users permission level on the repository. Will return null if authenticated as an GitHub App.
	ViewerPermission *RepositoryPermission `json:"viewerPermission,omitempty"`
	// A list of emails this viewer can commit with.
	ViewerPossibleCommitEmails []string `json:"viewerPossibleCommitEmails,omitempty"`
	// Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
	ViewerSubscription *SubscriptionState `json:"viewerSubscription,omitempty"`
	// Indicates the repository's visibility level.
	Visibility RepositoryVisibility `json:"visibility"`
	// Returns a single vulnerability alert from the current repository by number.
	VulnerabilityAlert *RepositoryVulnerabilityAlert `json:"vulnerabilityAlert,omitempty"`
	// A list of vulnerability alerts that are on this repository.
	VulnerabilityAlerts *RepositoryVulnerabilityAlertConnection `json:"vulnerabilityAlerts,omitempty"`
	// A list of users watching the repository.
	Watchers *UserConnection `json:"watchers"`
	// Whether contributors are required to sign off on web-based commits in this repository.
	WebCommitSignoffRequired bool `json:"webCommitSignoffRequired"`
}

func (*Repository) isPermissionGranter() {}

func (*Repository) isPinnableItem() {}

func (*Repository) isNode() {}

func (*Repository) isPackageOwner() {}

func (*Repository) isProjectOwner() {}

func (*Repository) isProjectV2Recent() {}

func (*Repository) isRepositoryInfo() {}

func (*Repository) isStarrable() {}

func (*Repository) isSubscribable() {}

func (*Repository) isUniformResourceLocatable() {}

func (*Repository) isRuleSource() {}

func (*Repository) isSearchResultItem() {}

func (*Repository) isSponsorsListingFeatureableItem() {}

func (*Repository) isUserListItems() {}

// The affiliation of a user to a repository
type RepositoryAffiliation string

const (
	// Repositories that the user has been added to as a collaborator.
	RepositoryAffiliationCollaborator RepositoryAffiliation = "COLLABORATOR"
	// Repositories that the user has access to through being a member of an
	// organization. This includes every repository on every team that the user is on.
	RepositoryAffiliationOrganizationMember RepositoryAffiliation = "ORGANIZATION_MEMBER"
	// Repositories that are owned by the authenticated user.
	RepositoryAffiliationOwner RepositoryAffiliation = "OWNER"
)

// Metadata for an audit entry with action repo.*
type RepositoryAuditEntryData struct {
	// The repository associated with the action
	Repository *Repository `json:"repository,omitempty"`
	// The name of the repository
	RepositoryName *string `json:"repositoryName,omitempty"`
	// The HTTP path for the repository
	RepositoryResourcePath *URI `json:"repositoryResourcePath,omitempty"`
	// The HTTP URL for the repository
	RepositoryUrl *URI `json:"repositoryUrl,omitempty"`

	// Underlying value of the GraphQL interface
	Value RepositoryAuditEntryDataValue `json:"-"`
}

func (base *RepositoryAuditEntryData) UnmarshalJSON(b []byte) error {
	type Raw RepositoryAuditEntryData
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "OrgRestoreMemberMembershipRepositoryAuditEntryData":
		base.Value = new(OrgRestoreMemberMembershipRepositoryAuditEntryData)
	case "PrivateRepositoryForkingDisableAuditEntry":
		base.Value = new(PrivateRepositoryForkingDisableAuditEntry)
	case "PrivateRepositoryForkingEnableAuditEntry":
		base.Value = new(PrivateRepositoryForkingEnableAuditEntry)
	case "RepoAccessAuditEntry":
		base.Value = new(RepoAccessAuditEntry)
	case "RepoAddMemberAuditEntry":
		base.Value = new(RepoAddMemberAuditEntry)
	case "RepoAddTopicAuditEntry":
		base.Value = new(RepoAddTopicAuditEntry)
	case "RepoArchivedAuditEntry":
		base.Value = new(RepoArchivedAuditEntry)
	case "RepoChangeMergeSettingAuditEntry":
		base.Value = new(RepoChangeMergeSettingAuditEntry)
	case "RepoConfigDisableAnonymousGitAccessAuditEntry":
		base.Value = new(RepoConfigDisableAnonymousGitAccessAuditEntry)
	case "RepoConfigDisableCollaboratorsOnlyAuditEntry":
		base.Value = new(RepoConfigDisableCollaboratorsOnlyAuditEntry)
	case "RepoConfigDisableContributorsOnlyAuditEntry":
		base.Value = new(RepoConfigDisableContributorsOnlyAuditEntry)
	case "RepoConfigDisableSockpuppetDisallowedAuditEntry":
		base.Value = new(RepoConfigDisableSockpuppetDisallowedAuditEntry)
	case "RepoConfigEnableAnonymousGitAccessAuditEntry":
		base.Value = new(RepoConfigEnableAnonymousGitAccessAuditEntry)
	case "RepoConfigEnableCollaboratorsOnlyAuditEntry":
		base.Value = new(RepoConfigEnableCollaboratorsOnlyAuditEntry)
	case "RepoConfigEnableContributorsOnlyAuditEntry":
		base.Value = new(RepoConfigEnableContributorsOnlyAuditEntry)
	case "RepoConfigEnableSockpuppetDisallowedAuditEntry":
		base.Value = new(RepoConfigEnableSockpuppetDisallowedAuditEntry)
	case "RepoConfigLockAnonymousGitAccessAuditEntry":
		base.Value = new(RepoConfigLockAnonymousGitAccessAuditEntry)
	case "RepoConfigUnlockAnonymousGitAccessAuditEntry":
		base.Value = new(RepoConfigUnlockAnonymousGitAccessAuditEntry)
	case "RepoCreateAuditEntry":
		base.Value = new(RepoCreateAuditEntry)
	case "RepoDestroyAuditEntry":
		base.Value = new(RepoDestroyAuditEntry)
	case "RepoRemoveMemberAuditEntry":
		base.Value = new(RepoRemoveMemberAuditEntry)
	case "RepoRemoveTopicAuditEntry":
		base.Value = new(RepoRemoveTopicAuditEntry)
	case "TeamAddRepositoryAuditEntry":
		base.Value = new(TeamAddRepositoryAuditEntry)
	case "TeamRemoveRepositoryAuditEntry":
		base.Value = new(TeamRemoveRepositoryAuditEntry)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface RepositoryAuditEntryData: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// RepositoryAuditEntryDataValue is one of: OrgRestoreMemberMembershipRepositoryAuditEntryData | PrivateRepositoryForkingDisableAuditEntry | PrivateRepositoryForkingEnableAuditEntry | RepoAccessAuditEntry | RepoAddMemberAuditEntry | RepoAddTopicAuditEntry | RepoArchivedAuditEntry | RepoChangeMergeSettingAuditEntry | RepoConfigDisableAnonymousGitAccessAuditEntry | RepoConfigDisableCollaboratorsOnlyAuditEntry | RepoConfigDisableContributorsOnlyAuditEntry | RepoConfigDisableSockpuppetDisallowedAuditEntry | RepoConfigEnableAnonymousGitAccessAuditEntry | RepoConfigEnableCollaboratorsOnlyAuditEntry | RepoConfigEnableContributorsOnlyAuditEntry | RepoConfigEnableSockpuppetDisallowedAuditEntry | RepoConfigLockAnonymousGitAccessAuditEntry | RepoConfigUnlockAnonymousGitAccessAuditEntry | RepoCreateAuditEntry | RepoDestroyAuditEntry | RepoRemoveMemberAuditEntry | RepoRemoveTopicAuditEntry | TeamAddRepositoryAuditEntry | TeamRemoveRepositoryAuditEntry
type RepositoryAuditEntryDataValue interface {
	isRepositoryAuditEntryData()
}

// Information extracted from a repository's `CODEOWNERS` file.
type RepositoryCodeowners struct {
	// Any problems that were encountered while parsing the `CODEOWNERS` file.
	Errors []RepositoryCodeownersError `json:"errors"`
}

// An error in a `CODEOWNERS` file.
type RepositoryCodeownersError struct {
	// The column number where the error occurs.
	Column int32 `json:"column"`
	// A short string describing the type of error.
	Kind string `json:"kind"`
	// The line number where the error occurs.
	Line int32 `json:"line"`
	// A complete description of the error, combining information from other fields.
	Message string `json:"message"`
	// The path to the file when the error occurs.
	Path string `json:"path"`
	// The content of the line where the error occurs.
	Source string `json:"source"`
	// A suggestion of how to fix the error.
	Suggestion *string `json:"suggestion,omitempty"`
}

// The connection type for User.
type RepositoryCollaboratorConnection struct {
	// A list of edges.
	Edges []*RepositoryCollaboratorEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*User `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// Represents a user who is a collaborator of a repository.
type RepositoryCollaboratorEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	Node   *User  `json:"node"`
	// The permission the user has on the repository.
	Permission RepositoryPermission `json:"permission"`
	// A list of sources for the user's access to the repository.
	PermissionSources []PermissionSource `json:"permissionSources,omitempty"`
}

// A list of repositories owned by the subject.
type RepositoryConnection struct {
	// A list of edges.
	Edges []*RepositoryEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*Repository `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
	// The total size in kilobytes of all repositories in the connection. Value will
	// never be larger than max 32-bit signed integer.
	TotalDiskUsage int32 `json:"totalDiskUsage"`
}

// A repository contact link.
type RepositoryContactLink struct {
	// The contact link purpose.
	About string `json:"about"`
	// The contact link name.
	Name string `json:"name"`
	// The contact link URL.
	Url URI `json:"url"`
}

// The reason a repository is listed as 'contributed'.
type RepositoryContributionType string

const (
	// Created a commit
	RepositoryContributionTypeCommit RepositoryContributionType = "COMMIT"
	// Created an issue
	RepositoryContributionTypeIssue RepositoryContributionType = "ISSUE"
	// Created a pull request
	RepositoryContributionTypePullRequest RepositoryContributionType = "PULL_REQUEST"
	// Reviewed a pull request
	RepositoryContributionTypePullRequestReview RepositoryContributionType = "PULL_REQUEST_REVIEW"
	// Created the repository
	RepositoryContributionTypeRepository RepositoryContributionType = "REPOSITORY"
)

// Represents an author of discussions in repositories.
type RepositoryDiscussionAuthor struct {
	// Discussions this user has started.
	RepositoryDiscussions *DiscussionConnection `json:"repositoryDiscussions"`

	// Underlying value of the GraphQL interface
	Value RepositoryDiscussionAuthorValue `json:"-"`
}

func (base *RepositoryDiscussionAuthor) UnmarshalJSON(b []byte) error {
	type Raw RepositoryDiscussionAuthor
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Organization":
		base.Value = new(Organization)
	case "User":
		base.Value = new(User)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface RepositoryDiscussionAuthor: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// RepositoryDiscussionAuthorValue is one of: Organization | User
type RepositoryDiscussionAuthorValue interface {
	isRepositoryDiscussionAuthor()
}

// Represents an author of discussion comments in repositories.
type RepositoryDiscussionCommentAuthor struct {
	// Discussion comments this user has authored.
	RepositoryDiscussionComments *DiscussionCommentConnection `json:"repositoryDiscussionComments"`

	// Underlying value of the GraphQL interface
	Value RepositoryDiscussionCommentAuthorValue `json:"-"`
}

func (base *RepositoryDiscussionCommentAuthor) UnmarshalJSON(b []byte) error {
	type Raw RepositoryDiscussionCommentAuthor
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Organization":
		base.Value = new(Organization)
	case "User":
		base.Value = new(User)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface RepositoryDiscussionCommentAuthor: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// RepositoryDiscussionCommentAuthorValue is one of: Organization | User
type RepositoryDiscussionCommentAuthorValue interface {
	isRepositoryDiscussionCommentAuthor()
}

// An edge in a connection.
type RepositoryEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *Repository `json:"node,omitempty"`
}

// Parameters to be used for the repository_id condition
type RepositoryIdConditionTarget struct {
	// One of these repo IDs must match the repo.
	RepositoryIds []string `json:"repositoryIds"`
}

// Parameters to be used for the repository_id condition
type RepositoryIdConditionTargetInput struct {
	// One of these repo IDs must match the repo.
	RepositoryIds []string `json:"repositoryIds"`
}

// A subset of repository info.
type RepositoryInfo struct {
	// Identifies the date and time when the repository was archived.
	ArchivedAt *DateTime `json:"archivedAt,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The description of the repository.
	Description *string `json:"description,omitempty"`
	// The description of the repository rendered to HTML.
	DescriptionHTML HTML `json:"descriptionHTML"`
	// Returns how many forks there are of this repository in the whole network.
	ForkCount int32 `json:"forkCount"`
	// Indicates if the repository has the Discussions feature enabled.
	HasDiscussionsEnabled bool `json:"hasDiscussionsEnabled"`
	// Indicates if the repository has issues feature enabled.
	HasIssuesEnabled bool `json:"hasIssuesEnabled"`
	// Indicates if the repository has the Projects feature enabled.
	HasProjectsEnabled bool `json:"hasProjectsEnabled"`
	// Indicates if the repository displays a Sponsor button for financial contributions.
	HasSponsorshipsEnabled bool `json:"hasSponsorshipsEnabled"`
	// Indicates if the repository has wiki feature enabled.
	HasWikiEnabled bool `json:"hasWikiEnabled"`
	// The repository's URL.
	HomepageUrl *URI `json:"homepageUrl,omitempty"`
	// Indicates if the repository is unmaintained.
	IsArchived bool `json:"isArchived"`
	// Identifies if the repository is a fork.
	IsFork bool `json:"isFork"`
	// Indicates if a repository is either owned by an organization, or is a private fork of an organization repository.
	IsInOrganization bool `json:"isInOrganization"`
	// Indicates if the repository has been locked or not.
	IsLocked bool `json:"isLocked"`
	// Identifies if the repository is a mirror.
	IsMirror bool `json:"isMirror"`
	// Identifies if the repository is private or internal.
	IsPrivate bool `json:"isPrivate"`
	// Identifies if the repository is a template that can be used to generate new repositories.
	IsTemplate bool `json:"isTemplate"`
	// The license associated with the repository
	LicenseInfo *License `json:"licenseInfo,omitempty"`
	// The reason the repository has been locked.
	LockReason *RepositoryLockReason `json:"lockReason,omitempty"`
	// The repository's original mirror URL.
	MirrorUrl *URI `json:"mirrorUrl,omitempty"`
	// The name of the repository.
	Name string `json:"name"`
	// The repository's name with owner.
	NameWithOwner string `json:"nameWithOwner"`
	// The image used to represent this repository in Open Graph data.
	OpenGraphImageUrl URI `json:"openGraphImageUrl"`
	// The User owner of the repository.
	Owner *RepositoryOwner `json:"owner"`
	// Identifies the date and time when the repository was last pushed to.
	PushedAt *DateTime `json:"pushedAt,omitempty"`
	// The HTTP path for this repository
	ResourcePath URI `json:"resourcePath"`
	// A description of the repository, rendered to HTML without any links in it.
	ShortDescriptionHTML HTML `json:"shortDescriptionHTML"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The HTTP URL for this repository
	Url URI `json:"url"`
	// Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar.
	UsesCustomOpenGraphImage bool `json:"usesCustomOpenGraphImage"`
	// Indicates the repository's visibility level.
	Visibility RepositoryVisibility `json:"visibility"`

	// Underlying value of the GraphQL interface
	Value RepositoryInfoValue `json:"-"`
}

func (base *RepositoryInfo) UnmarshalJSON(b []byte) error {
	type Raw RepositoryInfo
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Repository":
		base.Value = new(Repository)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface RepositoryInfo: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// RepositoryInfoValue is one of: Repository
type RepositoryInfoValue interface {
	isRepositoryInfo()
}

// Repository interaction limit that applies to this object.
type RepositoryInteractionAbility struct {
	// The time the currently active limit expires.
	ExpiresAt *DateTime `json:"expiresAt,omitempty"`
	// The current limit that is enabled on this object.
	Limit RepositoryInteractionLimit `json:"limit"`
	// The origin of the currently active interaction limit.
	Origin RepositoryInteractionLimitOrigin `json:"origin"`
}

// A repository interaction limit.
type RepositoryInteractionLimit string

const (
	// Users that are not collaborators will not be able to interact with the repository.
	RepositoryInteractionLimitCollaboratorsOnly RepositoryInteractionLimit = "COLLABORATORS_ONLY"
	// Users that have not previously committed to a repositorys default branch will be unable to interact with the repository.
	RepositoryInteractionLimitContributorsOnly RepositoryInteractionLimit = "CONTRIBUTORS_ONLY"
	// Users that have recently created their account will be unable to interact with the repository.
	RepositoryInteractionLimitExistingUsers RepositoryInteractionLimit = "EXISTING_USERS"
	// No interaction limits are enabled.
	RepositoryInteractionLimitNoLimit RepositoryInteractionLimit = "NO_LIMIT"
)

// The length for a repository interaction limit to be enabled for.
type RepositoryInteractionLimitExpiry string

const (
	// The interaction limit will expire after 1 day.
	RepositoryInteractionLimitExpiryOneDay RepositoryInteractionLimitExpiry = "ONE_DAY"
	// The interaction limit will expire after 1 month.
	RepositoryInteractionLimitExpiryOneMonth RepositoryInteractionLimitExpiry = "ONE_MONTH"
	// The interaction limit will expire after 1 week.
	RepositoryInteractionLimitExpiryOneWeek RepositoryInteractionLimitExpiry = "ONE_WEEK"
	// The interaction limit will expire after 6 months.
	RepositoryInteractionLimitExpirySixMonths RepositoryInteractionLimitExpiry = "SIX_MONTHS"
	// The interaction limit will expire after 3 days.
	RepositoryInteractionLimitExpiryThreeDays RepositoryInteractionLimitExpiry = "THREE_DAYS"
)

// Indicates where an interaction limit is configured.
type RepositoryInteractionLimitOrigin string

const (
	// A limit that is configured at the organization level.
	RepositoryInteractionLimitOriginOrganization RepositoryInteractionLimitOrigin = "ORGANIZATION"
	// A limit that is configured at the repository level.
	RepositoryInteractionLimitOriginRepository RepositoryInteractionLimitOrigin = "REPOSITORY"
	// A limit that is configured at the user-wide level.
	RepositoryInteractionLimitOriginUser RepositoryInteractionLimitOrigin = "USER"
)

// An invitation for a user to be added to a repository.
type RepositoryInvitation struct {
	// The email address that received the invitation.
	Email *string `json:"email,omitempty"`
	// The Node ID of the RepositoryInvitation object
	Id string `json:"id"`
	// The user who received the invitation.
	Invitee *User `json:"invitee,omitempty"`
	// The user who created the invitation.
	Inviter *User `json:"inviter"`
	// The permalink for this repository invitation.
	Permalink URI `json:"permalink"`
	// The permission granted on this repository by this invitation.
	Permission RepositoryPermission `json:"permission"`
	// The Repository the user is invited to.
	Repository *RepositoryInfo `json:"repository,omitempty"`
}

func (*RepositoryInvitation) isNode() {}

// A list of repository invitations.
type RepositoryInvitationConnection struct {
	// A list of edges.
	Edges []*RepositoryInvitationEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*RepositoryInvitation `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type RepositoryInvitationEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *RepositoryInvitation `json:"node,omitempty"`
}

// Ordering options for repository invitation connections.
type RepositoryInvitationOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order repository invitations by.
	Field RepositoryInvitationOrderField `json:"field"`
}

// Properties by which repository invitation connections can be ordered.
type RepositoryInvitationOrderField string

const (
	// Order repository invitations by creation time
	RepositoryInvitationOrderFieldCreatedAt RepositoryInvitationOrderField = "CREATED_AT"
)

// The possible reasons a given repository could be in a locked state.
type RepositoryLockReason string

const (
	// The repository is locked due to a billing related reason.
	RepositoryLockReasonBilling RepositoryLockReason = "BILLING"
	// The repository is locked due to a migration.
	RepositoryLockReasonMigrating RepositoryLockReason = "MIGRATING"
	// The repository is locked due to a move.
	RepositoryLockReasonMoving RepositoryLockReason = "MOVING"
	// The repository is locked due to a rename.
	RepositoryLockReasonRename RepositoryLockReason = "RENAME"
	// The repository is locked due to a trade controls related reason.
	RepositoryLockReasonTradeRestriction RepositoryLockReason = "TRADE_RESTRICTION"
	// The repository is locked due to an ownership transfer.
	RepositoryLockReasonTransferringOwnership RepositoryLockReason = "TRANSFERRING_OWNERSHIP"
)

// A GitHub Enterprise Importer (GEI) repository migration.
type RepositoryMigration struct {
	// The migration flag to continue on error.
	ContinueOnError bool `json:"continueOnError"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *string `json:"databaseId,omitempty"`
	// The reason the migration failed.
	FailureReason *string `json:"failureReason,omitempty"`
	// The Node ID of the RepositoryMigration object
	Id string `json:"id"`
	// The URL for the migration log (expires 1 day after migration completes).
	MigrationLogUrl *URI `json:"migrationLogUrl,omitempty"`
	// The migration source.
	MigrationSource *MigrationSource `json:"migrationSource"`
	// The target repository name.
	RepositoryName string `json:"repositoryName"`
	// The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`.
	SourceUrl URI `json:"sourceUrl"`
	// The migration state.
	State MigrationState `json:"state"`
	// The number of warnings encountered for this migration. To review the warnings,
	// check the [Migration Log](https://docs.github.com/migrations/using-github-enterprise-importer/completing-your-migration-with-github-enterprise-importer/accessing-your-migration-logs-for-github-enterprise-importer).
	WarningsCount int32 `json:"warningsCount"`
}

func (*RepositoryMigration) isMigration() {}

func (*RepositoryMigration) isNode() {}

// A list of migrations.
type RepositoryMigrationConnection struct {
	// A list of edges.
	Edges []*RepositoryMigrationEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*RepositoryMigration `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// Represents a repository migration.
type RepositoryMigrationEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *RepositoryMigration `json:"node,omitempty"`
}

// Ordering options for repository migrations.
type RepositoryMigrationOrder struct {
	// The ordering direction.
	Direction RepositoryMigrationOrderDirection `json:"direction"`
	// The field to order repository migrations by.
	Field RepositoryMigrationOrderField `json:"field"`
}

// Possible directions in which to order a list of repository migrations when provided an `orderBy` argument.
type RepositoryMigrationOrderDirection string

const (
	// Specifies an ascending order for a given `orderBy` argument.
	RepositoryMigrationOrderDirectionAsc RepositoryMigrationOrderDirection = "ASC"
	// Specifies a descending order for a given `orderBy` argument.
	RepositoryMigrationOrderDirectionDesc RepositoryMigrationOrderDirection = "DESC"
)

// Properties by which repository migrations can be ordered.
type RepositoryMigrationOrderField string

const (
	// Order mannequins why when they were created.
	RepositoryMigrationOrderFieldCreatedAt RepositoryMigrationOrderField = "CREATED_AT"
)

// Parameters to be used for the repository_name condition
type RepositoryNameConditionTarget struct {
	// Array of repository names or patterns to exclude. The condition will not pass if any of these patterns match.
	Exclude []string `json:"exclude"`
	// Array of repository names or patterns to include. One of these patterns must
	// match for the condition to pass. Also accepts `~ALL` to include all repositories.
	Include []string `json:"include"`
	// Target changes that match these patterns will be prevented except by those with bypass permissions.
	Protected bool `json:"protected"`
}

// Parameters to be used for the repository_name condition
type RepositoryNameConditionTargetInput struct {
	// Array of repository names or patterns to exclude. The condition will not pass if any of these patterns match.
	Exclude []string `json:"exclude"`
	// Array of repository names or patterns to include. One of these patterns must
	// match for the condition to pass. Also accepts `~ALL` to include all repositories.
	Include []string `json:"include"`
	// Target changes that match these patterns will be prevented except by those with bypass permissions.
	Protected *bool `json:"protected,omitempty"`
}

// Represents a object that belongs to a repository.
type RepositoryNode struct {
	// The repository associated with this node.
	Repository *Repository `json:"repository"`

	// Underlying value of the GraphQL interface
	Value RepositoryNodeValue `json:"-"`
}

func (base *RepositoryNode) UnmarshalJSON(b []byte) error {
	type Raw RepositoryNode
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "CommitComment":
		base.Value = new(CommitComment)
	case "CommitCommentThread":
		base.Value = new(CommitCommentThread)
	case "DependabotUpdate":
		base.Value = new(DependabotUpdate)
	case "Discussion":
		base.Value = new(Discussion)
	case "DiscussionCategory":
		base.Value = new(DiscussionCategory)
	case "Issue":
		base.Value = new(Issue)
	case "IssueComment":
		base.Value = new(IssueComment)
	case "PinnedDiscussion":
		base.Value = new(PinnedDiscussion)
	case "PullRequest":
		base.Value = new(PullRequest)
	case "PullRequestCommitCommentThread":
		base.Value = new(PullRequestCommitCommentThread)
	case "PullRequestReview":
		base.Value = new(PullRequestReview)
	case "PullRequestReviewComment":
		base.Value = new(PullRequestReviewComment)
	case "RepositoryVulnerabilityAlert":
		base.Value = new(RepositoryVulnerabilityAlert)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface RepositoryNode: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// RepositoryNodeValue is one of: CommitComment | CommitCommentThread | DependabotUpdate | Discussion | DiscussionCategory | Issue | IssueComment | PinnedDiscussion | PullRequest | PullRequestCommitCommentThread | PullRequestReview | PullRequestReviewComment | RepositoryVulnerabilityAlert
type RepositoryNodeValue interface {
	isRepositoryNode()
}

// Ordering options for repository connections
type RepositoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order repositories by.
	Field RepositoryOrderField `json:"field"`
}

// Properties by which repository connections can be ordered.
type RepositoryOrderField string

const (
	// Order repositories by creation time
	RepositoryOrderFieldCreatedAt RepositoryOrderField = "CREATED_AT"
	// Order repositories by name
	RepositoryOrderFieldName RepositoryOrderField = "NAME"
	// Order repositories by push time
	RepositoryOrderFieldPushedAt RepositoryOrderField = "PUSHED_AT"
	// Order repositories by number of stargazers
	RepositoryOrderFieldStargazers RepositoryOrderField = "STARGAZERS"
	// Order repositories by update time
	RepositoryOrderFieldUpdatedAt RepositoryOrderField = "UPDATED_AT"
)

// Represents an owner of a Repository.
type RepositoryOwner struct {
	// A URL pointing to the owner's public avatar.
	AvatarUrl URI `json:"avatarUrl"`
	// The Node ID of the RepositoryOwner object
	Id string `json:"id"`
	// The username used to login.
	Login string `json:"login"`
	// A list of repositories that the user owns.
	Repositories *RepositoryConnection `json:"repositories"`
	// Find Repository.
	Repository *Repository `json:"repository,omitempty"`
	// The HTTP URL for the owner.
	ResourcePath URI `json:"resourcePath"`
	// The HTTP URL for the owner.
	Url URI `json:"url"`

	// Underlying value of the GraphQL interface
	Value RepositoryOwnerValue `json:"-"`
}

func (base *RepositoryOwner) UnmarshalJSON(b []byte) error {
	type Raw RepositoryOwner
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Organization":
		base.Value = new(Organization)
	case "User":
		base.Value = new(User)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface RepositoryOwner: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// RepositoryOwnerValue is one of: Organization | User
type RepositoryOwnerValue interface {
	isRepositoryOwner()
}

// The access level to a repository
type RepositoryPermission string

const (
	// Can read, clone, and push to this repository. Can also manage issues, pull
	// requests, and repository settings, including adding collaborators
	RepositoryPermissionAdmin RepositoryPermission = "ADMIN"
	// Can read, clone, and push to this repository. They can also manage issues, pull requests, and some repository settings
	RepositoryPermissionMaintain RepositoryPermission = "MAINTAIN"
	// Can read and clone this repository. Can also open and comment on issues and pull requests
	RepositoryPermissionRead RepositoryPermission = "READ"
	// Can read and clone this repository. Can also manage issues and pull requests
	RepositoryPermissionTriage RepositoryPermission = "TRIAGE"
	// Can read, clone, and push to this repository. Can also manage issues and pull requests
	RepositoryPermissionWrite RepositoryPermission = "WRITE"
)

// Information about the availability of features and limits for a repository based on its billing plan.
type RepositoryPlanFeatures struct {
	// Whether reviews can be automatically requested and enforced with a CODEOWNERS file
	Codeowners bool `json:"codeowners"`
	// Whether pull requests can be created as or converted to draft
	DraftPullRequests bool `json:"draftPullRequests"`
	// Maximum number of users that can be assigned to an issue or pull request
	MaximumAssignees int32 `json:"maximumAssignees"`
	// Maximum number of manually-requested reviews on a pull request
	MaximumManualReviewRequests int32 `json:"maximumManualReviewRequests"`
	// Whether teams can be requested to review pull requests
	TeamReviewRequests bool `json:"teamReviewRequests"`
}

// The privacy of a repository
type RepositoryPrivacy string

const (
	// Private
	RepositoryPrivacyPrivate RepositoryPrivacy = "PRIVATE"
	// Public
	RepositoryPrivacyPublic RepositoryPrivacy = "PUBLIC"
)

// Parameters to be used for the repository_property condition
type RepositoryPropertyConditionTarget struct {
	// Array of repository properties that must not match.
	Exclude []PropertyTargetDefinition `json:"exclude"`
	// Array of repository properties that must match
	Include []PropertyTargetDefinition `json:"include"`
}

// Parameters to be used for the repository_property condition
type RepositoryPropertyConditionTargetInput struct {
	// Array of repository properties that must not match.
	Exclude []PropertyTargetDefinitionInput `json:"exclude"`
	// Array of repository properties that must match
	Include []PropertyTargetDefinitionInput `json:"include"`
}

// A repository rule.
type RepositoryRule struct {
	// The Node ID of the RepositoryRule object
	Id string `json:"id"`
	// The parameters for this rule.
	Parameters *RuleParameters `json:"parameters,omitempty"`
	// The repository ruleset associated with this rule configuration
	RepositoryRuleset *RepositoryRuleset `json:"repositoryRuleset,omitempty"`
	// The type of rule.
	Type RepositoryRuleType `json:"type"`
}

func (*RepositoryRule) isNode() {}

// Set of conditions that determine if a ruleset will evaluate
type RepositoryRuleConditions struct {
	// Configuration for the ref_name condition
	RefName *RefNameConditionTarget `json:"refName,omitempty"`
	// Configuration for the repository_id condition
	RepositoryId *RepositoryIdConditionTarget `json:"repositoryId,omitempty"`
	// Configuration for the repository_name condition
	RepositoryName *RepositoryNameConditionTarget `json:"repositoryName,omitempty"`
	// Configuration for the repository_property condition
	RepositoryProperty *RepositoryPropertyConditionTarget `json:"repositoryProperty,omitempty"`
}

// Specifies the conditions required for a ruleset to evaluate
type RepositoryRuleConditionsInput struct {
	// Configuration for the ref_name condition
	RefName *RefNameConditionTargetInput `json:"refName,omitempty"`
	// Configuration for the repository_id condition
	RepositoryId *RepositoryIdConditionTargetInput `json:"repositoryId,omitempty"`
	// Configuration for the repository_name condition
	RepositoryName *RepositoryNameConditionTargetInput `json:"repositoryName,omitempty"`
	// Configuration for the repository_property condition
	RepositoryProperty *RepositoryPropertyConditionTargetInput `json:"repositoryProperty,omitempty"`
}

// The connection type for RepositoryRule.
type RepositoryRuleConnection struct {
	// A list of edges.
	Edges []*RepositoryRuleEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*RepositoryRule `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type RepositoryRuleEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *RepositoryRule `json:"node,omitempty"`
}

// Specifies the attributes for a new or updated rule.
type RepositoryRuleInput struct {
	// Optional ID of this rule when updating
	Id string `json:"id,omitempty"`
	// The parameters for the rule.
	Parameters *RuleParametersInput `json:"parameters,omitempty"`
	// The type of rule to create.
	Type RepositoryRuleType `json:"type"`
}

// Ordering options for repository rules.
type RepositoryRuleOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order repository rules by.
	Field RepositoryRuleOrderField `json:"field"`
}

// Properties by which repository rule connections can be ordered.
type RepositoryRuleOrderField string

const (
	// Order repository rules by created time
	RepositoryRuleOrderFieldCreatedAt RepositoryRuleOrderField = "CREATED_AT"
	// Order repository rules by type
	RepositoryRuleOrderFieldType RepositoryRuleOrderField = "TYPE"
	// Order repository rules by updated time
	RepositoryRuleOrderFieldUpdatedAt RepositoryRuleOrderField = "UPDATED_AT"
)

// The rule types supported in rulesets
type RepositoryRuleType string

const (
	// Authorization
	RepositoryRuleTypeAuthorization RepositoryRuleType = "AUTHORIZATION"
	// Branch name pattern
	RepositoryRuleTypeBranchNamePattern RepositoryRuleType = "BRANCH_NAME_PATTERN"
	// Choose which tools must provide code scanning results before the reference is
	// updated. When configured, code scanning must be enabled and have results for
	// both the commit and the reference being updated.
	RepositoryRuleTypeCodeScanning RepositoryRuleType = "CODE_SCANNING"
	// Committer email pattern
	RepositoryRuleTypeCommitterEmailPattern RepositoryRuleType = "COMMITTER_EMAIL_PATTERN"
	// Commit author email pattern
	RepositoryRuleTypeCommitAuthorEmailPattern RepositoryRuleType = "COMMIT_AUTHOR_EMAIL_PATTERN"
	// Commit message pattern
	RepositoryRuleTypeCommitMessagePattern RepositoryRuleType = "COMMIT_MESSAGE_PATTERN"
	// Only allow users with bypass permission to create matching refs.
	RepositoryRuleTypeCreation RepositoryRuleType = "CREATION"
	// Only allow users with bypass permissions to delete matching refs.
	RepositoryRuleTypeDeletion RepositoryRuleType = "DELETION"
	// Prevent commits that include files with specified file extensions from being pushed to the commit graph.
	RepositoryRuleTypeFileExtensionRestriction RepositoryRuleType = "FILE_EXTENSION_RESTRICTION"
	// Prevent commits that include changes in specified file and folder paths from
	// being pushed to the commit graph. This includes absolute paths that contain file names.
	RepositoryRuleTypeFilePathRestriction RepositoryRuleType = "FILE_PATH_RESTRICTION"
	// Branch is read-only. Users cannot push to the branch.
	RepositoryRuleTypeLockBranch RepositoryRuleType = "LOCK_BRANCH"
	// Prevent commits that include file paths that exceed the specified character limit from being pushed to the commit graph.
	RepositoryRuleTypeMaxFilePathLength RepositoryRuleType = "MAX_FILE_PATH_LENGTH"
	// Prevent commits with individual files that exceed the specified limit from being pushed to the commit graph.
	RepositoryRuleTypeMaxFileSize RepositoryRuleType = "MAX_FILE_SIZE"
	// Max ref updates
	RepositoryRuleTypeMaxRefUpdates RepositoryRuleType = "MAX_REF_UPDATES"
	// Merges must be performed via a merge queue.
	RepositoryRuleTypeMergeQueue RepositoryRuleType = "MERGE_QUEUE"
	// Merge queue locked ref
	RepositoryRuleTypeMergeQueueLockedRef RepositoryRuleType = "MERGE_QUEUE_LOCKED_REF"
	// Prevent users with push access from force pushing to refs.
	RepositoryRuleTypeNonFastForward RepositoryRuleType = "NON_FAST_FORWARD"
	// Require all commits be made to a non-target branch and submitted via a pull request before they can be merged.
	RepositoryRuleTypePullRequest RepositoryRuleType = "PULL_REQUEST"
	// Choose which environments must be successfully deployed to before refs can be pushed into a ref that matches this rule.
	RepositoryRuleTypeRequiredDeployments RepositoryRuleType = "REQUIRED_DEPLOYMENTS"
	// Prevent merge commits from being pushed to matching refs.
	RepositoryRuleTypeRequiredLinearHistory RepositoryRuleType = "REQUIRED_LINEAR_HISTORY"
	// When enabled, all conversations on code must be resolved before a pull request
	// can be merged into a branch that matches this rule.
	RepositoryRuleTypeRequiredReviewThreadResolution RepositoryRuleType = "REQUIRED_REVIEW_THREAD_RESOLUTION"
	// Commits pushed to matching refs must have verified signatures.
	RepositoryRuleTypeRequiredSignatures RepositoryRuleType = "REQUIRED_SIGNATURES"
	// Choose which status checks must pass before the ref is updated. When enabled,
	// commits must first be pushed to another ref where the checks pass.
	RepositoryRuleTypeRequiredStatusChecks RepositoryRuleType = "REQUIRED_STATUS_CHECKS"
	// Require all commits be made to a non-target branch and submitted via a pull
	// request and required workflow checks to pass before they can be merged.
	RepositoryRuleTypeRequiredWorkflowStatusChecks RepositoryRuleType = "REQUIRED_WORKFLOW_STATUS_CHECKS"
	// Secret scanning
	RepositoryRuleTypeSecretScanning RepositoryRuleType = "SECRET_SCANNING"
	// Tag
	RepositoryRuleTypeTag RepositoryRuleType = "TAG"
	// Tag name pattern
	RepositoryRuleTypeTagNamePattern RepositoryRuleType = "TAG_NAME_PATTERN"
	// Only allow users with bypass permission to update matching refs.
	RepositoryRuleTypeUpdate RepositoryRuleType = "UPDATE"
	// Require all changes made to a targeted branch to pass the specified workflows before they can be merged.
	RepositoryRuleTypeWorkflows RepositoryRuleType = "WORKFLOWS"
	// Workflow files cannot be modified.
	RepositoryRuleTypeWorkflowUpdates RepositoryRuleType = "WORKFLOW_UPDATES"
)

// A repository ruleset.
type RepositoryRuleset struct {
	// The actors that can bypass this ruleset
	BypassActors *RepositoryRulesetBypassActorConnection `json:"bypassActors,omitempty"`
	// The set of conditions that must evaluate to true for this ruleset to apply
	Conditions *RepositoryRuleConditions `json:"conditions"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The enforcement level of this ruleset
	Enforcement RuleEnforcement `json:"enforcement"`
	// The Node ID of the RepositoryRuleset object
	Id string `json:"id"`
	// Name of the ruleset.
	Name string `json:"name"`
	// List of rules.
	Rules *RepositoryRuleConnection `json:"rules,omitempty"`
	// Source of ruleset.
	Source RuleSource `json:"source"`
	// Target of the ruleset.
	Target *RepositoryRulesetTarget `json:"target,omitempty"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
}

func (*RepositoryRuleset) isNode() {}

// A team or app that has the ability to bypass a rules defined on a ruleset
type RepositoryRulesetBypassActor struct {
	// The actor that can bypass rules.
	Actor *BypassActor `json:"actor,omitempty"`
	// The mode for the bypass actor
	BypassMode *RepositoryRulesetBypassActorBypassMode `json:"bypassMode,omitempty"`
	// This actor represents the ability for a deploy key to bypass
	DeployKey bool `json:"deployKey"`
	// This actor represents the ability for an enterprise owner to bypass
	EnterpriseOwner bool `json:"enterpriseOwner"`
	// The Node ID of the RepositoryRulesetBypassActor object
	Id string `json:"id"`
	// This actor represents the ability for an organization owner to bypass
	OrganizationAdmin bool `json:"organizationAdmin"`
	// If the actor is a repository role, the repository role's ID that can bypass
	RepositoryRoleDatabaseId *int32 `json:"repositoryRoleDatabaseId,omitempty"`
	// If the actor is a repository role, the repository role's name that can bypass
	RepositoryRoleName *string `json:"repositoryRoleName,omitempty"`
	// Identifies the ruleset associated with the allowed actor
	RepositoryRuleset *RepositoryRuleset `json:"repositoryRuleset,omitempty"`
}

func (*RepositoryRulesetBypassActor) isNode() {}

// The bypass mode for a specific actor on a ruleset.
type RepositoryRulesetBypassActorBypassMode string

const (
	// The actor can always bypass rules
	RepositoryRulesetBypassActorBypassModeAlways RepositoryRulesetBypassActorBypassMode = "ALWAYS"
	// The actor can only bypass rules via a pull request
	RepositoryRulesetBypassActorBypassModePullRequest RepositoryRulesetBypassActorBypassMode = "PULL_REQUEST"
)

// The connection type for RepositoryRulesetBypassActor.
type RepositoryRulesetBypassActorConnection struct {
	// A list of edges.
	Edges []*RepositoryRulesetBypassActorEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*RepositoryRulesetBypassActor `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type RepositoryRulesetBypassActorEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *RepositoryRulesetBypassActor `json:"node,omitempty"`
}

// Specifies the attributes for a new or updated ruleset bypass actor. Only one of
// `actor_id`, `repository_role_database_id`, `organization_admin`, or `deploy_key`
// should be specified.
type RepositoryRulesetBypassActorInput struct {
	// For Team and Integration bypasses, the Team or Integration ID
	ActorId string `json:"actorId,omitempty"`
	// The bypass mode for this actor.
	BypassMode RepositoryRulesetBypassActorBypassMode `json:"bypassMode"`
	// For deploy key bypasses, true. Can only use ALWAYS as the bypass mode
	DeployKey *bool `json:"deployKey,omitempty"`
	// For enterprise owner bypasses, true
	EnterpriseOwner *bool `json:"enterpriseOwner,omitempty"`
	// For organization owner bypasses, true
	OrganizationAdmin *bool `json:"organizationAdmin,omitempty"`
	// For role bypasses, the role database ID
	RepositoryRoleDatabaseId *int32 `json:"repositoryRoleDatabaseId,omitempty"`
}

// The connection type for RepositoryRuleset.
type RepositoryRulesetConnection struct {
	// A list of edges.
	Edges []*RepositoryRulesetEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*RepositoryRuleset `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type RepositoryRulesetEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *RepositoryRuleset `json:"node,omitempty"`
}

// The targets supported for rulesets.
type RepositoryRulesetTarget string

const (
	// Branch
	RepositoryRulesetTargetBranch RepositoryRulesetTarget = "BRANCH"
	// Push
	RepositoryRulesetTargetPush RepositoryRulesetTarget = "PUSH"
	// repository
	RepositoryRulesetTargetRepository RepositoryRulesetTarget = "REPOSITORY"
	// Tag
	RepositoryRulesetTargetTag RepositoryRulesetTarget = "TAG"
)

// The possible filters for suggested actors in a repository
type RepositorySuggestedActorFilter string

const (
	// Actors that can be assigned to issues and pull requests
	RepositorySuggestedActorFilterCanBeAssigned RepositorySuggestedActorFilter = "CAN_BE_ASSIGNED"
	// Actors that can be the author of issues and pull requests
	RepositorySuggestedActorFilterCanBeAuthor RepositorySuggestedActorFilter = "CAN_BE_AUTHOR"
)

// A repository-topic connects a repository to a topic.
type RepositoryTopic struct {
	// The Node ID of the RepositoryTopic object
	Id string `json:"id"`
	// The HTTP path for this repository-topic.
	ResourcePath URI `json:"resourcePath"`
	// The topic.
	Topic *Topic `json:"topic"`
	// The HTTP URL for this repository-topic.
	Url URI `json:"url"`
}

func (*RepositoryTopic) isNode() {}

func (*RepositoryTopic) isUniformResourceLocatable() {}

// The connection type for RepositoryTopic.
type RepositoryTopicConnection struct {
	// A list of edges.
	Edges []*RepositoryTopicEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*RepositoryTopic `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type RepositoryTopicEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *RepositoryTopic `json:"node,omitempty"`
}

// The repository's visibility level.
type RepositoryVisibility string

const (
	// The repository is visible only to users in the same enterprise.
	RepositoryVisibilityInternal RepositoryVisibility = "INTERNAL"
	// The repository is visible only to those with explicit access.
	RepositoryVisibilityPrivate RepositoryVisibility = "PRIVATE"
	// The repository is visible to everyone.
	RepositoryVisibilityPublic RepositoryVisibility = "PUBLIC"
)

// Audit log entry for a repository_visibility_change.disable event.
type RepositoryVisibilityChangeDisableAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The HTTP path for this enterprise.
	EnterpriseResourcePath *URI `json:"enterpriseResourcePath,omitempty"`
	// The slug of the enterprise.
	EnterpriseSlug *string `json:"enterpriseSlug,omitempty"`
	// The HTTP URL for this enterprise.
	EnterpriseUrl *URI `json:"enterpriseUrl,omitempty"`
	// The Node ID of the RepositoryVisibilityChangeDisableAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*RepositoryVisibilityChangeDisableAuditEntry) isOrganizationAuditEntry() {}

func (*RepositoryVisibilityChangeDisableAuditEntry) isAuditEntry() {}

func (*RepositoryVisibilityChangeDisableAuditEntry) isEnterpriseAuditEntryData() {}

func (*RepositoryVisibilityChangeDisableAuditEntry) isNode() {}

func (*RepositoryVisibilityChangeDisableAuditEntry) isOrganizationAuditEntryData() {}

// Audit log entry for a repository_visibility_change.enable event.
type RepositoryVisibilityChangeEnableAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The HTTP path for this enterprise.
	EnterpriseResourcePath *URI `json:"enterpriseResourcePath,omitempty"`
	// The slug of the enterprise.
	EnterpriseSlug *string `json:"enterpriseSlug,omitempty"`
	// The HTTP URL for this enterprise.
	EnterpriseUrl *URI `json:"enterpriseUrl,omitempty"`
	// The Node ID of the RepositoryVisibilityChangeEnableAuditEntry object
	Id string `json:"id"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*RepositoryVisibilityChangeEnableAuditEntry) isOrganizationAuditEntry() {}

func (*RepositoryVisibilityChangeEnableAuditEntry) isAuditEntry() {}

func (*RepositoryVisibilityChangeEnableAuditEntry) isEnterpriseAuditEntryData() {}

func (*RepositoryVisibilityChangeEnableAuditEntry) isNode() {}

func (*RepositoryVisibilityChangeEnableAuditEntry) isOrganizationAuditEntryData() {}

// A Dependabot alert for a repository with a dependency affected by a security vulnerability.
type RepositoryVulnerabilityAlert struct {
	// When was the alert auto-dismissed?
	AutoDismissedAt *DateTime `json:"autoDismissedAt,omitempty"`
	// When was the alert created?
	CreatedAt DateTime `json:"createdAt"`
	// The associated Dependabot update
	DependabotUpdate *DependabotUpdate `json:"dependabotUpdate,omitempty"`
	// The relationship of an alert's dependency.
	DependencyRelationship *RepositoryVulnerabilityAlertDependencyRelationship `json:"dependencyRelationship,omitempty"`
	// The scope of an alert's dependency
	DependencyScope *RepositoryVulnerabilityAlertDependencyScope `json:"dependencyScope,omitempty"`
	// Comment explaining the reason the alert was dismissed
	DismissComment *string `json:"dismissComment,omitempty"`
	// The reason the alert was dismissed
	DismissReason *string `json:"dismissReason,omitempty"`
	// When was the alert dismissed?
	DismissedAt *DateTime `json:"dismissedAt,omitempty"`
	// The user who dismissed the alert
	Dismisser *User `json:"dismisser,omitempty"`
	// When was the alert fixed?
	FixedAt *DateTime `json:"fixedAt,omitempty"`
	// The Node ID of the RepositoryVulnerabilityAlert object
	Id string `json:"id"`
	// Identifies the alert number.
	Number int32 `json:"number"`
	// The associated repository
	Repository *Repository `json:"repository"`
	// The associated security advisory
	SecurityAdvisory *SecurityAdvisory `json:"securityAdvisory,omitempty"`
	// The associated security vulnerability
	SecurityVulnerability *SecurityVulnerability `json:"securityVulnerability,omitempty"`
	// Identifies the state of the alert.
	State RepositoryVulnerabilityAlertState `json:"state"`
	// The vulnerable manifest filename
	VulnerableManifestFilename string `json:"vulnerableManifestFilename"`
	// The vulnerable manifest path
	VulnerableManifestPath string `json:"vulnerableManifestPath"`
	// The vulnerable requirements
	VulnerableRequirements *string `json:"vulnerableRequirements,omitempty"`
}

func (*RepositoryVulnerabilityAlert) isNode() {}

func (*RepositoryVulnerabilityAlert) isRepositoryNode() {}

// The connection type for RepositoryVulnerabilityAlert.
type RepositoryVulnerabilityAlertConnection struct {
	// A list of edges.
	Edges []*RepositoryVulnerabilityAlertEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*RepositoryVulnerabilityAlert `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// The possible relationships of an alert's dependency.
type RepositoryVulnerabilityAlertDependencyRelationship string

const (
	// A direct dependency of your project
	RepositoryVulnerabilityAlertDependencyRelationshipDirect RepositoryVulnerabilityAlertDependencyRelationship = "DIRECT"
	// A transitive dependency of your project
	RepositoryVulnerabilityAlertDependencyRelationshipTransitive RepositoryVulnerabilityAlertDependencyRelationship = "TRANSITIVE"
	// The relationship is unknown
	RepositoryVulnerabilityAlertDependencyRelationshipUnknown RepositoryVulnerabilityAlertDependencyRelationship = "UNKNOWN"
)

// The possible scopes of an alert's dependency.
type RepositoryVulnerabilityAlertDependencyScope string

const (
	// A dependency that is only used in development
	RepositoryVulnerabilityAlertDependencyScopeDevelopment RepositoryVulnerabilityAlertDependencyScope = "DEVELOPMENT"
	// A dependency that is leveraged during application runtime
	RepositoryVulnerabilityAlertDependencyScopeRuntime RepositoryVulnerabilityAlertDependencyScope = "RUNTIME"
)

// An edge in a connection.
type RepositoryVulnerabilityAlertEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *RepositoryVulnerabilityAlert `json:"node,omitempty"`
}

// The possible states of an alert
type RepositoryVulnerabilityAlertState string

const (
	// An alert that has been automatically closed by Dependabot.
	RepositoryVulnerabilityAlertStateAutoDismissed RepositoryVulnerabilityAlertState = "AUTO_DISMISSED"
	// An alert that has been manually closed by a user.
	RepositoryVulnerabilityAlertStateDismissed RepositoryVulnerabilityAlertState = "DISMISSED"
	// An alert that has been resolved by a code change.
	RepositoryVulnerabilityAlertStateFixed RepositoryVulnerabilityAlertState = "FIXED"
	// An alert that is still open.
	RepositoryVulnerabilityAlertStateOpen RepositoryVulnerabilityAlertState = "OPEN"
)

// Autogenerated input type of ReprioritizeSubIssue
type ReprioritizeSubIssueInput struct {
	// The id of the sub-issue to be prioritized after (either positional argument after OR before should be specified).
	AfterId string `json:"afterId,omitempty"`
	// The id of the sub-issue to be prioritized before (either positional argument after OR before should be specified).
	BeforeId string `json:"beforeId,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The id of the parent issue.
	IssueId string `json:"issueId"`
	// The id of the sub-issue to reprioritize.
	SubIssueId string `json:"subIssueId"`
}

// Autogenerated return type of ReprioritizeSubIssue.
type ReprioritizeSubIssuePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The parent issue that the sub-issue was reprioritized in.
	Issue *Issue `json:"issue,omitempty"`
}

// Autogenerated input type of RequestReviews
type RequestReviewsInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Node ID of the pull request to modify.
	PullRequestId string `json:"pullRequestId"`
	// The Node IDs of the team to request.
	TeamIds []string `json:"teamIds,omitempty"`
	// Add users to the set rather than replace.
	Union *bool `json:"union,omitempty"`
	// The Node IDs of the user to request.
	UserIds []string `json:"userIds,omitempty"`
}

// Autogenerated return type of RequestReviews.
type RequestReviewsPayload struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The pull request that is getting requests.
	PullRequest *PullRequest `json:"pullRequest,omitempty"`
	// The edge from the pull request to the requested reviewers.
	RequestedReviewersEdge *UserEdge `json:"requestedReviewersEdge,omitempty"`
}

// The possible states that can be requested when creating a check run.
type RequestableCheckStatusState string

const (
	// The check suite or run has been completed.
	RequestableCheckStatusStateCompleted RequestableCheckStatusState = "COMPLETED"
	// The check suite or run is in progress.
	RequestableCheckStatusStateInProgress RequestableCheckStatusState = "IN_PROGRESS"
	// The check suite or run is in pending state.
	RequestableCheckStatusStatePending RequestableCheckStatusState = "PENDING"
	// The check suite or run has been queued.
	RequestableCheckStatusStateQueued RequestableCheckStatusState = "QUEUED"
	// The check suite or run is in waiting state.
	RequestableCheckStatusStateWaiting RequestableCheckStatusState = "WAITING"
)

// Types that can be requested reviewers.
type RequestedReviewer struct {
	// Underlying value of the GraphQL union
	Value RequestedReviewerValue `json:"-"`
}

func (base *RequestedReviewer) UnmarshalJSON(b []byte) error {
	type Raw RequestedReviewer
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Bot":
		base.Value = new(Bot)
	case "Mannequin":
		base.Value = new(Mannequin)
	case "Team":
		base.Value = new(Team)
	case "User":
		base.Value = new(User)
	case "":
		return fmt.Errorf("gqlclient: union RequestedReviewer: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union RequestedReviewer: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// RequestedReviewerValue is one of: Bot | Mannequin | Team | User
type RequestedReviewerValue interface {
	isRequestedReviewer()
}

// The connection type for RequestedReviewer.
type RequestedReviewerConnection struct {
	// A list of edges.
	Edges []*RequestedReviewerEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*RequestedReviewer `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type RequestedReviewerEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *RequestedReviewer `json:"node,omitempty"`
}

// Represents a type that can be required by a pull request for merging.
type RequirableByPullRequest struct {
	// Whether this is required to pass before merging for a specific pull request.
	IsRequired bool `json:"isRequired"`

	// Underlying value of the GraphQL interface
	Value RequirableByPullRequestValue `json:"-"`
}

func (base *RequirableByPullRequest) UnmarshalJSON(b []byte) error {
	type Raw RequirableByPullRequest
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "CheckRun":
		base.Value = new(CheckRun)
	case "StatusContext":
		base.Value = new(StatusContext)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface RequirableByPullRequest: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// RequirableByPullRequestValue is one of: CheckRun | StatusContext
type RequirableByPullRequestValue interface {
	isRequirableByPullRequest()
}

// Choose which environments must be successfully deployed to before refs can be pushed into a ref that matches this rule.
type RequiredDeploymentsParameters struct {
	// The environments that must be successfully deployed to before branches can be merged.
	RequiredDeploymentEnvironments []string `json:"requiredDeploymentEnvironments"`
}

func (*RequiredDeploymentsParameters) isRuleParameters() {}

// Choose which environments must be successfully deployed to before refs can be pushed into a ref that matches this rule.
type RequiredDeploymentsParametersInput struct {
	// The environments that must be successfully deployed to before branches can be merged.
	RequiredDeploymentEnvironments []string `json:"requiredDeploymentEnvironments"`
}

// Represents a required status check for a protected branch, but not any specific run of that check.
type RequiredStatusCheckDescription struct {
	// The App that must provide this status in order for it to be accepted.
	App *App `json:"app,omitempty"`
	// The name of this status.
	Context string `json:"context"`
}

// Specifies the attributes for a new or updated required status check.
type RequiredStatusCheckInput struct {
	// The ID of the App that must set the status in order for it to be accepted.
	// Omit this value to use whichever app has recently been setting this status, or
	// use "any" to allow any app to set the status.
	AppId string `json:"appId,omitempty"`
	// Status check context that must pass for commits to be accepted to the matching branch.
	Context string `json:"context"`
}

// Choose which status checks must pass before the ref is updated. When enabled,
// commits must first be pushed to another ref where the checks pass.
type RequiredStatusChecksParameters struct {
	// Allow repositories and branches to be created if a check would otherwise prohibit it.
	DoNotEnforceOnCreate bool `json:"doNotEnforceOnCreate"`
	// Status checks that are required.
	RequiredStatusChecks []StatusCheckConfiguration `json:"requiredStatusChecks"`
	// Whether pull requests targeting a matching branch must be tested with the
	// latest code. This setting will not take effect unless at least one status
	// check is enabled.
	StrictRequiredStatusChecksPolicy bool `json:"strictRequiredStatusChecksPolicy"`
}

func (*RequiredStatusChecksParameters) isRuleParameters() {}

// Choose which status checks must pass before the ref is updated. When enabled,
// commits must first be pushed to another ref where the checks pass.
type RequiredStatusChecksParametersInput struct {
	// Allow repositories and branches to be created if a check would otherwise prohibit it.
	DoNotEnforceOnCreate *bool `json:"doNotEnforceOnCreate,omitempty"`
	// Status checks that are required.
	RequiredStatusChecks []StatusCheckConfigurationInput `json:"requiredStatusChecks"`
	// Whether pull requests targeting a matching branch must be tested with the
	// latest code. This setting will not take effect unless at least one status
	// check is enabled.
	StrictRequiredStatusChecksPolicy bool `json:"strictRequiredStatusChecksPolicy"`
}

// Autogenerated input type of RerequestCheckSuite
type RerequestCheckSuiteInput struct {
	// The Node ID of the check suite.
	CheckSuiteId string `json:"checkSuiteId"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Node ID of the repository.
	RepositoryId string `json:"repositoryId"`
}

// Autogenerated return type of RerequestCheckSuite.
type RerequestCheckSuitePayload struct {
	// The requested check suite.
	CheckSuite *CheckSuite `json:"checkSuite,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
}

// Autogenerated input type of ResolveReviewThread
type ResolveReviewThreadInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the thread to resolve
	ThreadId string `json:"threadId"`
}

// Autogenerated return type of ResolveReviewThread.
type ResolveReviewThreadPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The thread to resolve.
	Thread *PullRequestReviewThread `json:"thread,omitempty"`
}

// Represents a private contribution a user made on GitHub.
type RestrictedContribution struct {
	// Whether this contribution is associated with a record you do not have access to. For
	// example, your own 'first issue' contribution may have been made on a repository you can no
	// longer access.
	IsRestricted bool `json:"isRestricted"`
	// When this contribution was made.
	OccurredAt DateTime `json:"occurredAt"`
	// The HTTP path for this contribution.
	ResourcePath URI `json:"resourcePath"`
	// The HTTP URL for this contribution.
	Url URI `json:"url"`
	// The user who made this contribution.
	User *User `json:"user"`
}

func (*RestrictedContribution) isCreatedIssueOrRestrictedContribution() {}

func (*RestrictedContribution) isCreatedPullRequestOrRestrictedContribution() {}

func (*RestrictedContribution) isCreatedRepositoryOrRestrictedContribution() {}

func (*RestrictedContribution) isContribution() {}

// Autogenerated input type of RetireSponsorsTier
type RetireSponsorsTierInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the published tier to retire.
	TierId string `json:"tierId"`
}

// Autogenerated return type of RetireSponsorsTier.
type RetireSponsorsTierPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The tier that was retired.
	SponsorsTier *SponsorsTier `json:"sponsorsTier,omitempty"`
}

// Autogenerated input type of RevertPullRequest
type RevertPullRequestInput struct {
	// The description of the revert pull request.
	Body *string `json:"body,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Indicates whether the revert pull request should be a draft.
	Draft *bool `json:"draft,omitempty"`
	// The ID of the pull request to revert.
	PullRequestId string `json:"pullRequestId"`
	// The title of the revert pull request.
	Title *string `json:"title,omitempty"`
}

// Autogenerated return type of RevertPullRequest.
type RevertPullRequestPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The pull request that was reverted.
	PullRequest *PullRequest `json:"pullRequest,omitempty"`
	// The new pull request that reverts the input pull request.
	RevertPullRequest *PullRequest `json:"revertPullRequest,omitempty"`
}

// A user, team, or app who has the ability to dismiss a review on a protected branch.
type ReviewDismissalAllowance struct {
	// The actor that can dismiss.
	Actor *ReviewDismissalAllowanceActor `json:"actor,omitempty"`
	// Identifies the branch protection rule associated with the allowed user, team, or app.
	BranchProtectionRule *BranchProtectionRule `json:"branchProtectionRule,omitempty"`
	// The Node ID of the ReviewDismissalAllowance object
	Id string `json:"id"`
}

func (*ReviewDismissalAllowance) isNode() {}

// Types that can be an actor.
type ReviewDismissalAllowanceActor struct {
	// Underlying value of the GraphQL union
	Value ReviewDismissalAllowanceActorValue `json:"-"`
}

func (base *ReviewDismissalAllowanceActor) UnmarshalJSON(b []byte) error {
	type Raw ReviewDismissalAllowanceActor
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "App":
		base.Value = new(App)
	case "Team":
		base.Value = new(Team)
	case "User":
		base.Value = new(User)
	case "":
		return fmt.Errorf("gqlclient: union ReviewDismissalAllowanceActor: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union ReviewDismissalAllowanceActor: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// ReviewDismissalAllowanceActorValue is one of: App | Team | User
type ReviewDismissalAllowanceActorValue interface {
	isReviewDismissalAllowanceActor()
}

// The connection type for ReviewDismissalAllowance.
type ReviewDismissalAllowanceConnection struct {
	// A list of edges.
	Edges []*ReviewDismissalAllowanceEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*ReviewDismissalAllowance `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type ReviewDismissalAllowanceEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *ReviewDismissalAllowance `json:"node,omitempty"`
}

// Represents a 'review_dismissed' event on a given issue or pull request.
type ReviewDismissedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// Identifies the optional message associated with the 'review_dismissed' event.
	DismissalMessage *string `json:"dismissalMessage,omitempty"`
	// Identifies the optional message associated with the event, rendered to HTML.
	DismissalMessageHTML *string `json:"dismissalMessageHTML,omitempty"`
	// The Node ID of the ReviewDismissedEvent object
	Id string `json:"id"`
	// Identifies the previous state of the review with the 'review_dismissed' event.
	PreviousReviewState PullRequestReviewState `json:"previousReviewState"`
	// PullRequest referenced by event.
	PullRequest *PullRequest `json:"pullRequest"`
	// Identifies the commit which caused the review to become stale.
	PullRequestCommit *PullRequestCommit `json:"pullRequestCommit,omitempty"`
	// The HTTP path for this review dismissed event.
	ResourcePath URI `json:"resourcePath"`
	// Identifies the review associated with the 'review_dismissed' event.
	Review *PullRequestReview `json:"review,omitempty"`
	// The HTTP URL for this review dismissed event.
	Url URI `json:"url"`
}

func (*ReviewDismissedEvent) isPullRequestTimelineItem() {}

func (*ReviewDismissedEvent) isPullRequestTimelineItems() {}

func (*ReviewDismissedEvent) isNode() {}

func (*ReviewDismissedEvent) isUniformResourceLocatable() {}

// A request for a user to review a pull request.
type ReviewRequest struct {
	// Whether this request was created for a code owner
	AsCodeOwner bool `json:"asCodeOwner"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The Node ID of the ReviewRequest object
	Id string `json:"id"`
	// Identifies the pull request associated with this review request.
	PullRequest *PullRequest `json:"pullRequest"`
	// The reviewer that is requested.
	RequestedReviewer *RequestedReviewer `json:"requestedReviewer,omitempty"`
}

func (*ReviewRequest) isNode() {}

// The connection type for ReviewRequest.
type ReviewRequestConnection struct {
	// A list of edges.
	Edges []*ReviewRequestEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*ReviewRequest `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type ReviewRequestEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *ReviewRequest `json:"node,omitempty"`
}

// Represents an 'review_request_removed' event on a given pull request.
type ReviewRequestRemovedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the ReviewRequestRemovedEvent object
	Id string `json:"id"`
	// PullRequest referenced by event.
	PullRequest *PullRequest `json:"pullRequest"`
	// Identifies the reviewer whose review request was removed.
	RequestedReviewer *RequestedReviewer `json:"requestedReviewer,omitempty"`
}

func (*ReviewRequestRemovedEvent) isPullRequestTimelineItem() {}

func (*ReviewRequestRemovedEvent) isPullRequestTimelineItems() {}

func (*ReviewRequestRemovedEvent) isNode() {}

// Represents an 'review_requested' event on a given pull request.
type ReviewRequestedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the ReviewRequestedEvent object
	Id string `json:"id"`
	// PullRequest referenced by event.
	PullRequest *PullRequest `json:"pullRequest"`
	// Identifies the reviewer whose review was requested.
	RequestedReviewer *RequestedReviewer `json:"requestedReviewer,omitempty"`
}

func (*ReviewRequestedEvent) isPullRequestTimelineItem() {}

func (*ReviewRequestedEvent) isPullRequestTimelineItems() {}

func (*ReviewRequestedEvent) isNode() {}

// A hovercard context with a message describing the current code review state of the pull
// request.
type ReviewStatusHovercardContext struct {
	// A string describing this context
	Message string `json:"message"`
	// An octicon to accompany this context
	Octicon string `json:"octicon"`
	// The current status of the pull request with respect to code review.
	ReviewDecision *PullRequestReviewDecision `json:"reviewDecision,omitempty"`
}

func (*ReviewStatusHovercardContext) isHovercardContext() {}

// Autogenerated input type of RevokeEnterpriseOrganizationsMigratorRole
type RevokeEnterpriseOrganizationsMigratorRoleInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the enterprise to which all organizations managed by it will be granted the migrator role.
	EnterpriseId string `json:"enterpriseId"`
	// The login of the user to revoke the migrator role
	Login string `json:"login"`
}

// Autogenerated return type of RevokeEnterpriseOrganizationsMigratorRole.
type RevokeEnterpriseOrganizationsMigratorRolePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The organizations that had the migrator role revoked for the given user.
	Organizations *OrganizationConnection `json:"organizations,omitempty"`
}

// Autogenerated input type of RevokeMigratorRole
type RevokeMigratorRoleInput struct {
	// The user login or Team slug to revoke the migrator role from.
	Actor string `json:"actor"`
	// Specifies the type of the actor, can be either USER or TEAM.
	ActorType ActorType `json:"actorType"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the organization that the user/team belongs to.
	OrganizationId string `json:"organizationId"`
}

// Autogenerated return type of RevokeMigratorRole.
type RevokeMigratorRolePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Did the operation succeed?
	Success *bool `json:"success,omitempty"`
}

// Possible roles a user may have in relation to an organization.
type RoleInOrganization string

const (
	// A user who is a direct member of the organization.
	RoleInOrganizationDirectMember RoleInOrganization = "DIRECT_MEMBER"
	// A user with full administrative access to the organization.
	RoleInOrganizationOwner RoleInOrganization = "OWNER"
	// A user who is unaffiliated with the organization.
	RoleInOrganizationUnaffiliated RoleInOrganization = "UNAFFILIATED"
)

// The level of enforcement for a rule or ruleset.
type RuleEnforcement string

const (
	// Rules will be enforced
	RuleEnforcementActive RuleEnforcement = "ACTIVE"
	// Do not evaluate or enforce rules
	RuleEnforcementDisabled RuleEnforcement = "DISABLED"
	// Allow admins to test rules before enforcing them. Admins can view insights on
	// the Rule Insights page (`evaluate` is only available with GitHub Enterprise).
	RuleEnforcementEvaluate RuleEnforcement = "EVALUATE"
)

// Types which can be parameters for `RepositoryRule` objects.
type RuleParameters struct {
	// Underlying value of the GraphQL union
	Value RuleParametersValue `json:"-"`
}

func (base *RuleParameters) UnmarshalJSON(b []byte) error {
	type Raw RuleParameters
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "BranchNamePatternParameters":
		base.Value = new(BranchNamePatternParameters)
	case "CodeScanningParameters":
		base.Value = new(CodeScanningParameters)
	case "CommitAuthorEmailPatternParameters":
		base.Value = new(CommitAuthorEmailPatternParameters)
	case "CommitMessagePatternParameters":
		base.Value = new(CommitMessagePatternParameters)
	case "CommitterEmailPatternParameters":
		base.Value = new(CommitterEmailPatternParameters)
	case "FileExtensionRestrictionParameters":
		base.Value = new(FileExtensionRestrictionParameters)
	case "FilePathRestrictionParameters":
		base.Value = new(FilePathRestrictionParameters)
	case "MaxFilePathLengthParameters":
		base.Value = new(MaxFilePathLengthParameters)
	case "MaxFileSizeParameters":
		base.Value = new(MaxFileSizeParameters)
	case "MergeQueueParameters":
		base.Value = new(MergeQueueParameters)
	case "PullRequestParameters":
		base.Value = new(PullRequestParameters)
	case "RequiredDeploymentsParameters":
		base.Value = new(RequiredDeploymentsParameters)
	case "RequiredStatusChecksParameters":
		base.Value = new(RequiredStatusChecksParameters)
	case "TagNamePatternParameters":
		base.Value = new(TagNamePatternParameters)
	case "UpdateParameters":
		base.Value = new(UpdateParameters)
	case "WorkflowsParameters":
		base.Value = new(WorkflowsParameters)
	case "":
		return fmt.Errorf("gqlclient: union RuleParameters: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union RuleParameters: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// RuleParametersValue is one of: BranchNamePatternParameters | CodeScanningParameters | CommitAuthorEmailPatternParameters | CommitMessagePatternParameters | CommitterEmailPatternParameters | FileExtensionRestrictionParameters | FilePathRestrictionParameters | MaxFilePathLengthParameters | MaxFileSizeParameters | MergeQueueParameters | PullRequestParameters | RequiredDeploymentsParameters | RequiredStatusChecksParameters | TagNamePatternParameters | UpdateParameters | WorkflowsParameters
type RuleParametersValue interface {
	isRuleParameters()
}

// Specifies the parameters for a `RepositoryRule` object. Only one of the fields should be specified.
type RuleParametersInput struct {
	// Parameters used for the `branch_name_pattern` rule type
	BranchNamePattern *BranchNamePatternParametersInput `json:"branchNamePattern,omitempty"`
	// Parameters used for the `code_scanning` rule type
	CodeScanning *CodeScanningParametersInput `json:"codeScanning,omitempty"`
	// Parameters used for the `commit_author_email_pattern` rule type
	CommitAuthorEmailPattern *CommitAuthorEmailPatternParametersInput `json:"commitAuthorEmailPattern,omitempty"`
	// Parameters used for the `commit_message_pattern` rule type
	CommitMessagePattern *CommitMessagePatternParametersInput `json:"commitMessagePattern,omitempty"`
	// Parameters used for the `committer_email_pattern` rule type
	CommitterEmailPattern *CommitterEmailPatternParametersInput `json:"committerEmailPattern,omitempty"`
	// Parameters used for the `file_extension_restriction` rule type
	FileExtensionRestriction *FileExtensionRestrictionParametersInput `json:"fileExtensionRestriction,omitempty"`
	// Parameters used for the `file_path_restriction` rule type
	FilePathRestriction *FilePathRestrictionParametersInput `json:"filePathRestriction,omitempty"`
	// Parameters used for the `max_file_path_length` rule type
	MaxFilePathLength *MaxFilePathLengthParametersInput `json:"maxFilePathLength,omitempty"`
	// Parameters used for the `max_file_size` rule type
	MaxFileSize *MaxFileSizeParametersInput `json:"maxFileSize,omitempty"`
	// Parameters used for the `merge_queue` rule type
	MergeQueue *MergeQueueParametersInput `json:"mergeQueue,omitempty"`
	// Parameters used for the `pull_request` rule type
	PullRequest *PullRequestParametersInput `json:"pullRequest,omitempty"`
	// Parameters used for the `required_deployments` rule type
	RequiredDeployments *RequiredDeploymentsParametersInput `json:"requiredDeployments,omitempty"`
	// Parameters used for the `required_status_checks` rule type
	RequiredStatusChecks *RequiredStatusChecksParametersInput `json:"requiredStatusChecks,omitempty"`
	// Parameters used for the `tag_name_pattern` rule type
	TagNamePattern *TagNamePatternParametersInput `json:"tagNamePattern,omitempty"`
	// Parameters used for the `update` rule type
	Update *UpdateParametersInput `json:"update,omitempty"`
	// Parameters used for the `workflows` rule type
	Workflows *WorkflowsParametersInput `json:"workflows,omitempty"`
}

// Types which can have `RepositoryRule` objects.
type RuleSource struct {
	// Underlying value of the GraphQL union
	Value RuleSourceValue `json:"-"`
}

func (base *RuleSource) UnmarshalJSON(b []byte) error {
	type Raw RuleSource
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Enterprise":
		base.Value = new(Enterprise)
	case "Organization":
		base.Value = new(Organization)
	case "Repository":
		base.Value = new(Repository)
	case "":
		return fmt.Errorf("gqlclient: union RuleSource: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union RuleSource: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// RuleSourceValue is one of: Enterprise | Organization | Repository
type RuleSourceValue interface {
	isRuleSource()
}

// The possible digest algorithms used to sign SAML requests for an identity provider.
type SamlDigestAlgorithm string

const (
	// SHA1
	SamlDigestAlgorithmSha1 SamlDigestAlgorithm = "SHA1"
	// SHA256
	SamlDigestAlgorithmSha256 SamlDigestAlgorithm = "SHA256"
	// SHA384
	SamlDigestAlgorithmSha384 SamlDigestAlgorithm = "SHA384"
	// SHA512
	SamlDigestAlgorithmSha512 SamlDigestAlgorithm = "SHA512"
)

// The possible signature algorithms used to sign SAML requests for a Identity Provider.
type SamlSignatureAlgorithm string

const (
	// RSA-SHA1
	SamlSignatureAlgorithmRsaSha1 SamlSignatureAlgorithm = "RSA_SHA1"
	// RSA-SHA256
	SamlSignatureAlgorithmRsaSha256 SamlSignatureAlgorithm = "RSA_SHA256"
	// RSA-SHA384
	SamlSignatureAlgorithmRsaSha384 SamlSignatureAlgorithm = "RSA_SHA384"
	// RSA-SHA512
	SamlSignatureAlgorithmRsaSha512 SamlSignatureAlgorithm = "RSA_SHA512"
)

// A Saved Reply is text a user can use to reply quickly.
type SavedReply struct {
	// The body of the saved reply.
	Body string `json:"body"`
	// The saved reply body rendered to HTML.
	BodyHTML HTML `json:"bodyHTML"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The Node ID of the SavedReply object
	Id string `json:"id"`
	// The title of the saved reply.
	Title string `json:"title"`
	// The user that saved this reply.
	User *Actor `json:"user,omitempty"`
}

func (*SavedReply) isNode() {}

// The connection type for SavedReply.
type SavedReplyConnection struct {
	// A list of edges.
	Edges []*SavedReplyEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*SavedReply `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type SavedReplyEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *SavedReply `json:"node,omitempty"`
}

// Ordering options for saved reply connections.
type SavedReplyOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order saved replies by.
	Field SavedReplyOrderField `json:"field"`
}

// Properties by which saved reply connections can be ordered.
type SavedReplyOrderField string

const (
	// Order saved reply by when they were updated.
	SavedReplyOrderFieldUpdatedAt SavedReplyOrderField = "UPDATED_AT"
)

// The results of a search.
type SearchResultItem struct {
	// Underlying value of the GraphQL union
	Value SearchResultItemValue `json:"-"`
}

func (base *SearchResultItem) UnmarshalJSON(b []byte) error {
	type Raw SearchResultItem
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "App":
		base.Value = new(App)
	case "Discussion":
		base.Value = new(Discussion)
	case "Issue":
		base.Value = new(Issue)
	case "MarketplaceListing":
		base.Value = new(MarketplaceListing)
	case "Organization":
		base.Value = new(Organization)
	case "PullRequest":
		base.Value = new(PullRequest)
	case "Repository":
		base.Value = new(Repository)
	case "User":
		base.Value = new(User)
	case "":
		return fmt.Errorf("gqlclient: union SearchResultItem: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union SearchResultItem: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// SearchResultItemValue is one of: App | Discussion | Issue | MarketplaceListing | Organization | PullRequest | Repository | User
type SearchResultItemValue interface {
	isSearchResultItem()
}

// A list of results that matched against a search query. Regardless of the number
// of matches, a maximum of 1,000 results will be available across all types,
// potentially split across many pages.
type SearchResultItemConnection struct {
	// The total number of pieces of code that matched the search query. Regardless
	// of the total number of matches, a maximum of 1,000 results will be available
	// across all types.
	CodeCount int32 `json:"codeCount"`
	// The total number of discussions that matched the search query. Regardless of
	// the total number of matches, a maximum of 1,000 results will be available
	// across all types.
	DiscussionCount int32 `json:"discussionCount"`
	// A list of edges.
	Edges []*SearchResultItemEdge `json:"edges,omitempty"`
	// The total number of issues that matched the search query. Regardless of the
	// total number of matches, a maximum of 1,000 results will be available across all types.
	IssueCount int32 `json:"issueCount"`
	// A list of nodes.
	Nodes []*SearchResultItem `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// The total number of repositories that matched the search query. Regardless of
	// the total number of matches, a maximum of 1,000 results will be available
	// across all types.
	RepositoryCount int32 `json:"repositoryCount"`
	// The total number of users that matched the search query. Regardless of the
	// total number of matches, a maximum of 1,000 results will be available across all types.
	UserCount int32 `json:"userCount"`
	// The total number of wiki pages that matched the search query. Regardless of
	// the total number of matches, a maximum of 1,000 results will be available
	// across all types.
	WikiCount int32 `json:"wikiCount"`
}

// An edge in a connection.
type SearchResultItemEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *SearchResultItem `json:"node,omitempty"`
	// Text matches on the result found.
	TextMatches []*TextMatch `json:"textMatches,omitempty"`
}

// Represents the individual results of a search.
type SearchType string

const (
	// Returns matching discussions in repositories.
	SearchTypeDiscussion SearchType = "DISCUSSION"
	// Returns results matching issues in repositories.
	SearchTypeIssue SearchType = "ISSUE"
	// Returns results matching issues in repositories.
	SearchTypeIssueAdvanced SearchType = "ISSUE_ADVANCED"
	// Returns results matching repositories.
	SearchTypeRepository SearchType = "REPOSITORY"
	// Returns results matching users and organizations on GitHub.
	SearchTypeUser SearchType = "USER"
)

// A GitHub Security Advisory
type SecurityAdvisory struct {
	// The classification of the advisory
	Classification SecurityAdvisoryClassification `json:"classification"`
	// The CVSS associated with this advisory
	Cvss *CVSS `json:"cvss"`
	// The CVSS associated with this advisory
	CvssSeverities *CvssSeverities `json:"cvssSeverities"`
	// CWEs associated with this Advisory
	Cwes *CWEConnection `json:"cwes"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// This is a long plaintext description of the advisory
	Description string `json:"description"`
	// The Exploit Prediction Scoring System
	Epss *EPSS `json:"epss,omitempty"`
	// The GitHub Security Advisory ID
	GhsaId string `json:"ghsaId"`
	// The Node ID of the SecurityAdvisory object
	Id string `json:"id"`
	// A list of identifiers for this advisory
	Identifiers []SecurityAdvisoryIdentifier `json:"identifiers"`
	// The permalink for the advisory's dependabot alerts page
	NotificationsPermalink *URI `json:"notificationsPermalink,omitempty"`
	// The organization that originated the advisory
	Origin string `json:"origin"`
	// The permalink for the advisory
	Permalink *URI `json:"permalink,omitempty"`
	// When the advisory was published
	PublishedAt DateTime `json:"publishedAt"`
	// A list of references for this advisory
	References []SecurityAdvisoryReference `json:"references"`
	// The severity of the advisory
	Severity SecurityAdvisorySeverity `json:"severity"`
	// A short plaintext summary of the advisory
	Summary string `json:"summary"`
	// When the advisory was last updated
	UpdatedAt DateTime `json:"updatedAt"`
	// Vulnerabilities associated with this Advisory
	Vulnerabilities *SecurityVulnerabilityConnection `json:"vulnerabilities"`
	// When the advisory was withdrawn, if it has been withdrawn
	WithdrawnAt *DateTime `json:"withdrawnAt,omitempty"`
}

func (*SecurityAdvisory) isNode() {}

// Classification of the advisory.
type SecurityAdvisoryClassification string

const (
	// Classification of general advisories.
	SecurityAdvisoryClassificationGeneral SecurityAdvisoryClassification = "GENERAL"
	// Classification of malware advisories.
	SecurityAdvisoryClassificationMalware SecurityAdvisoryClassification = "MALWARE"
)

// The connection type for SecurityAdvisory.
type SecurityAdvisoryConnection struct {
	// A list of edges.
	Edges []*SecurityAdvisoryEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*SecurityAdvisory `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// The possible ecosystems of a security vulnerability's package.
type SecurityAdvisoryEcosystem string

const (
	// GitHub Actions
	SecurityAdvisoryEcosystemActions SecurityAdvisoryEcosystem = "ACTIONS"
	// PHP packages hosted at packagist.org
	SecurityAdvisoryEcosystemComposer SecurityAdvisoryEcosystem = "COMPOSER"
	// Erlang/Elixir packages hosted at hex.pm
	SecurityAdvisoryEcosystemErlang SecurityAdvisoryEcosystem = "ERLANG"
	// Go modules
	SecurityAdvisoryEcosystemGo SecurityAdvisoryEcosystem = "GO"
	// Java artifacts hosted at the Maven central repository
	SecurityAdvisoryEcosystemMaven SecurityAdvisoryEcosystem = "MAVEN"
	// JavaScript packages hosted at npmjs.com
	SecurityAdvisoryEcosystemNpm SecurityAdvisoryEcosystem = "NPM"
	// .NET packages hosted at the NuGet Gallery
	SecurityAdvisoryEcosystemNuget SecurityAdvisoryEcosystem = "NUGET"
	// Python packages hosted at PyPI.org
	SecurityAdvisoryEcosystemPip SecurityAdvisoryEcosystem = "PIP"
	// Dart packages hosted at pub.dev
	SecurityAdvisoryEcosystemPub SecurityAdvisoryEcosystem = "PUB"
	// Ruby gems hosted at RubyGems.org
	SecurityAdvisoryEcosystemRubygems SecurityAdvisoryEcosystem = "RUBYGEMS"
	// Rust crates
	SecurityAdvisoryEcosystemRust SecurityAdvisoryEcosystem = "RUST"
	// Swift packages
	SecurityAdvisoryEcosystemSwift SecurityAdvisoryEcosystem = "SWIFT"
)

// An edge in a connection.
type SecurityAdvisoryEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *SecurityAdvisory `json:"node,omitempty"`
}

// A GitHub Security Advisory Identifier
type SecurityAdvisoryIdentifier struct {
	// The identifier type, e.g. GHSA, CVE
	Type string `json:"type"`
	// The identifier
	Value string `json:"value"`
}

// An advisory identifier to filter results on.
type SecurityAdvisoryIdentifierFilter struct {
	// The identifier type.
	Type SecurityAdvisoryIdentifierType `json:"type"`
	// The identifier string. Supports exact or partial matching.
	Value string `json:"value"`
}

// Identifier formats available for advisories.
type SecurityAdvisoryIdentifierType string

const (
	// Common Vulnerabilities and Exposures Identifier.
	SecurityAdvisoryIdentifierTypeCve SecurityAdvisoryIdentifierType = "CVE"
	// GitHub Security Advisory ID.
	SecurityAdvisoryIdentifierTypeGhsa SecurityAdvisoryIdentifierType = "GHSA"
)

// Ordering options for security advisory connections
type SecurityAdvisoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order security advisories by.
	Field SecurityAdvisoryOrderField `json:"field"`
}

// Properties by which security advisory connections can be ordered.
type SecurityAdvisoryOrderField string

const (
	// Order advisories by EPSS percentage
	SecurityAdvisoryOrderFieldEpssPercentage SecurityAdvisoryOrderField = "EPSS_PERCENTAGE"
	// Order advisories by EPSS percentile
	SecurityAdvisoryOrderFieldEpssPercentile SecurityAdvisoryOrderField = "EPSS_PERCENTILE"
	// Order advisories by publication time
	SecurityAdvisoryOrderFieldPublishedAt SecurityAdvisoryOrderField = "PUBLISHED_AT"
	// Order advisories by update time
	SecurityAdvisoryOrderFieldUpdatedAt SecurityAdvisoryOrderField = "UPDATED_AT"
)

// An individual package
type SecurityAdvisoryPackage struct {
	// The ecosystem the package belongs to, e.g. RUBYGEMS, NPM
	Ecosystem SecurityAdvisoryEcosystem `json:"ecosystem"`
	// The package name
	Name string `json:"name"`
}

// An individual package version
type SecurityAdvisoryPackageVersion struct {
	// The package name or version
	Identifier string `json:"identifier"`
}

// A GitHub Security Advisory Reference
type SecurityAdvisoryReference struct {
	// A publicly accessible reference
	Url URI `json:"url"`
}

// Severity of the vulnerability.
type SecurityAdvisorySeverity string

const (
	// Critical.
	SecurityAdvisorySeverityCritical SecurityAdvisorySeverity = "CRITICAL"
	// High.
	SecurityAdvisorySeverityHigh SecurityAdvisorySeverity = "HIGH"
	// Low.
	SecurityAdvisorySeverityLow SecurityAdvisorySeverity = "LOW"
	// Moderate.
	SecurityAdvisorySeverityModerate SecurityAdvisorySeverity = "MODERATE"
)

// An individual vulnerability within an Advisory
type SecurityVulnerability struct {
	// The Advisory associated with this Vulnerability
	Advisory *SecurityAdvisory `json:"advisory"`
	// The first version containing a fix for the vulnerability
	FirstPatchedVersion *SecurityAdvisoryPackageVersion `json:"firstPatchedVersion,omitempty"`
	// A description of the vulnerable package
	Package *SecurityAdvisoryPackage `json:"package"`
	// The severity of the vulnerability within this package
	Severity SecurityAdvisorySeverity `json:"severity"`
	// When the vulnerability was last updated
	UpdatedAt DateTime `json:"updatedAt"`
	// A string that describes the vulnerable package versions.
	// This string follows a basic syntax with a few forms.
	// + `= 0.2.0` denotes a single vulnerable version.
	// + `<= 1.0.8` denotes a version range up to and including the specified version
	// + `< 0.1.11` denotes a version range up to, but excluding, the specified version
	// + `>= 4.3.0, < 4.3.5` denotes a version range with a known minimum and maximum version.
	// + `>= 0.0.1` denotes a version range with a known minimum, but no known maximum
	VulnerableVersionRange string `json:"vulnerableVersionRange"`
}

// The connection type for SecurityVulnerability.
type SecurityVulnerabilityConnection struct {
	// A list of edges.
	Edges []*SecurityVulnerabilityEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*SecurityVulnerability `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type SecurityVulnerabilityEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *SecurityVulnerability `json:"node,omitempty"`
}

// Ordering options for security vulnerability connections
type SecurityVulnerabilityOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order security vulnerabilities by.
	Field SecurityVulnerabilityOrderField `json:"field"`
}

// Properties by which security vulnerability connections can be ordered.
type SecurityVulnerabilityOrderField string

const (
	// Order vulnerability by update time
	SecurityVulnerabilityOrderFieldUpdatedAt SecurityVulnerabilityOrderField = "UPDATED_AT"
)

// Autogenerated input type of SetEnterpriseIdentityProvider
type SetEnterpriseIdentityProviderInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The digest algorithm used to sign SAML requests for the identity provider.
	DigestMethod SamlDigestAlgorithm `json:"digestMethod"`
	// The ID of the enterprise on which to set an identity provider.
	EnterpriseId string `json:"enterpriseId"`
	// The x509 certificate used by the identity provider to sign assertions and responses.
	IdpCertificate string `json:"idpCertificate"`
	// The Issuer Entity ID for the SAML identity provider
	Issuer *string `json:"issuer,omitempty"`
	// The signature algorithm used to sign SAML requests for the identity provider.
	SignatureMethod SamlSignatureAlgorithm `json:"signatureMethod"`
	// The URL endpoint for the identity provider's SAML SSO.
	SsoUrl URI `json:"ssoUrl"`
}

// Autogenerated return type of SetEnterpriseIdentityProvider.
type SetEnterpriseIdentityProviderPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The identity provider for the enterprise.
	IdentityProvider *EnterpriseIdentityProvider `json:"identityProvider,omitempty"`
}

// Autogenerated input type of SetOrganizationInteractionLimit
type SetOrganizationInteractionLimitInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// When this limit should expire.
	Expiry *RepositoryInteractionLimitExpiry `json:"expiry,omitempty"`
	// The limit to set.
	Limit RepositoryInteractionLimit `json:"limit"`
	// The ID of the organization to set a limit for.
	OrganizationId string `json:"organizationId"`
}

// Autogenerated return type of SetOrganizationInteractionLimit.
type SetOrganizationInteractionLimitPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The organization that the interaction limit was set for.
	Organization *Organization `json:"organization,omitempty"`
}

// Autogenerated input type of SetRepositoryInteractionLimit
type SetRepositoryInteractionLimitInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// When this limit should expire.
	Expiry *RepositoryInteractionLimitExpiry `json:"expiry,omitempty"`
	// The limit to set.
	Limit RepositoryInteractionLimit `json:"limit"`
	// The ID of the repository to set a limit for.
	RepositoryId string `json:"repositoryId"`
}

// Autogenerated return type of SetRepositoryInteractionLimit.
type SetRepositoryInteractionLimitPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The repository that the interaction limit was set for.
	Repository *Repository `json:"repository,omitempty"`
}

// Autogenerated input type of SetUserInteractionLimit
type SetUserInteractionLimitInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// When this limit should expire.
	Expiry *RepositoryInteractionLimitExpiry `json:"expiry,omitempty"`
	// The limit to set.
	Limit RepositoryInteractionLimit `json:"limit"`
	// The ID of the user to set a limit for.
	UserId string `json:"userId"`
}

// Autogenerated return type of SetUserInteractionLimit.
type SetUserInteractionLimitPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The user that the interaction limit was set for.
	User *User `json:"user,omitempty"`
}

// Represents an S/MIME signature on a Commit or Tag.
type SmimeSignature struct {
	// Email used to sign this object.
	Email string `json:"email"`
	// True if the signature is valid and verified by GitHub.
	IsValid bool `json:"isValid"`
	// Payload for GPG signing object. Raw ODB object without the signature header.
	Payload string `json:"payload"`
	// ASCII-armored signature header from object.
	Signature string `json:"signature"`
	// GitHub user corresponding to the email signing this commit.
	Signer *User `json:"signer,omitempty"`
	// The state of this signature. `VALID` if signature is valid and verified by
	// GitHub, otherwise represents reason why signature is considered invalid.
	State GitSignatureState `json:"state"`
	// The date the signature was verified, if valid
	VerifiedAt *DateTime `json:"verifiedAt,omitempty"`
	// True if the signature was made with GitHub's signing key.
	WasSignedByGitHub bool `json:"wasSignedByGitHub"`
}

func (*SmimeSignature) isGitSignature() {}

// Social media profile associated with a user.
type SocialAccount struct {
	// Name of the social media account as it appears on the profile.
	DisplayName string `json:"displayName"`
	// Software or company that hosts the social media account.
	Provider SocialAccountProvider `json:"provider"`
	// URL of the social media account.
	Url URI `json:"url"`
}

// The connection type for SocialAccount.
type SocialAccountConnection struct {
	// A list of edges.
	Edges []*SocialAccountEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*SocialAccount `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type SocialAccountEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *SocialAccount `json:"node,omitempty"`
}

// Software or company that hosts social media accounts.
type SocialAccountProvider string

const (
	// Decentralized microblogging social platform.
	SocialAccountProviderBluesky SocialAccountProvider = "BLUESKY"
	// Social media and networking website.
	SocialAccountProviderFacebook SocialAccountProvider = "FACEBOOK"
	// Catch-all for social media providers that do not yet have specific handling.
	SocialAccountProviderGeneric SocialAccountProvider = "GENERIC"
	// Fork of Mastodon with a greater focus on local posting.
	SocialAccountProviderHometown SocialAccountProvider = "HOMETOWN"
	// Social media website with a focus on photo and video sharing.
	SocialAccountProviderInstagram SocialAccountProvider = "INSTAGRAM"
	// Professional networking website.
	SocialAccountProviderLinkedin SocialAccountProvider = "LINKEDIN"
	// Open-source federated microblogging service.
	SocialAccountProviderMastodon SocialAccountProvider = "MASTODON"
	// JavaScript package registry.
	SocialAccountProviderNpm SocialAccountProvider = "NPM"
	// Social news aggregation and discussion website.
	SocialAccountProviderReddit SocialAccountProvider = "REDDIT"
	// Live-streaming service.
	SocialAccountProviderTwitch SocialAccountProvider = "TWITCH"
	// Microblogging website.
	SocialAccountProviderTwitter SocialAccountProvider = "TWITTER"
	// Online video platform.
	SocialAccountProviderYoutube SocialAccountProvider = "YOUTUBE"
)

// Entities that can sponsor others via GitHub Sponsors
type Sponsor struct {
	// Underlying value of the GraphQL union
	Value SponsorValue `json:"-"`
}

func (base *Sponsor) UnmarshalJSON(b []byte) error {
	type Raw Sponsor
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Organization":
		base.Value = new(Organization)
	case "User":
		base.Value = new(User)
	case "":
		return fmt.Errorf("gqlclient: union Sponsor: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union Sponsor: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// SponsorValue is one of: Organization | User
type SponsorValue interface {
	isSponsor()
}

// A GitHub account and the total amount in USD they've paid for sponsorships to a
// particular maintainer. Does not include payments made via Patreon.
type SponsorAndLifetimeValue struct {
	// The amount in cents.
	AmountInCents int32 `json:"amountInCents"`
	// The amount in USD, formatted as a string.
	FormattedAmount string `json:"formattedAmount"`
	// The sponsor's GitHub account.
	Sponsor *Sponsorable `json:"sponsor"`
	// The maintainer's GitHub account.
	Sponsorable *Sponsorable `json:"sponsorable"`
}

// The connection type for SponsorAndLifetimeValue.
type SponsorAndLifetimeValueConnection struct {
	// A list of edges.
	Edges []*SponsorAndLifetimeValueEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*SponsorAndLifetimeValue `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type SponsorAndLifetimeValueEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *SponsorAndLifetimeValue `json:"node,omitempty"`
}

// Ordering options for connections to get sponsor entities and associated USD amounts for GitHub Sponsors.
type SponsorAndLifetimeValueOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order results by.
	Field SponsorAndLifetimeValueOrderField `json:"field"`
}

// Properties by which sponsor and lifetime value connections can be ordered.
type SponsorAndLifetimeValueOrderField string

const (
	// Order results by how much money the sponsor has paid in total.
	SponsorAndLifetimeValueOrderFieldLifetimeValue SponsorAndLifetimeValueOrderField = "LIFETIME_VALUE"
	// Order results by the sponsor's login (username).
	SponsorAndLifetimeValueOrderFieldSponsorLogin SponsorAndLifetimeValueOrderField = "SPONSOR_LOGIN"
	// Order results by the sponsor's relevance to the viewer.
	SponsorAndLifetimeValueOrderFieldSponsorRelevance SponsorAndLifetimeValueOrderField = "SPONSOR_RELEVANCE"
)

// A list of users and organizations sponsoring someone via GitHub Sponsors.
type SponsorConnection struct {
	// A list of edges.
	Edges []*SponsorEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*Sponsor `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// Represents a user or organization who is sponsoring someone in GitHub Sponsors.
type SponsorEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *Sponsor `json:"node,omitempty"`
}

// Ordering options for connections to get sponsor entities for GitHub Sponsors.
type SponsorOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order sponsor entities by.
	Field SponsorOrderField `json:"field"`
}

// Properties by which sponsor connections can be ordered.
type SponsorOrderField string

const (
	// Order sponsorable entities by login (username).
	SponsorOrderFieldLogin SponsorOrderField = "LOGIN"
	// Order sponsors by their relevance to the viewer.
	SponsorOrderFieldRelevance SponsorOrderField = "RELEVANCE"
)

// Entities that can sponsor or be sponsored through GitHub Sponsors.
type Sponsorable struct {
	// The estimated next GitHub Sponsors payout for this user/organization in cents (USD).
	EstimatedNextSponsorsPayoutInCents int32 `json:"estimatedNextSponsorsPayoutInCents"`
	// True if this user/organization has a GitHub Sponsors listing.
	HasSponsorsListing bool `json:"hasSponsorsListing"`
	// Whether the given account is sponsoring this user/organization.
	IsSponsoredBy bool `json:"isSponsoredBy"`
	// True if the viewer is sponsored by this user/organization.
	IsSponsoringViewer bool `json:"isSponsoringViewer"`
	// Calculate how much each sponsor has ever paid total to this maintainer via
	// GitHub Sponsors. Does not include sponsorships paid via Patreon.
	LifetimeReceivedSponsorshipValues *SponsorAndLifetimeValueConnection `json:"lifetimeReceivedSponsorshipValues"`
	// The estimated monthly GitHub Sponsors income for this user/organization in cents (USD).
	MonthlyEstimatedSponsorsIncomeInCents int32 `json:"monthlyEstimatedSponsorsIncomeInCents"`
	// List of users and organizations this entity is sponsoring.
	Sponsoring *SponsorConnection `json:"sponsoring"`
	// List of sponsors for this user or organization.
	Sponsors *SponsorConnection `json:"sponsors"`
	// Events involving this sponsorable, such as new sponsorships.
	SponsorsActivities *SponsorsActivityConnection `json:"sponsorsActivities"`
	// The GitHub Sponsors listing for this user or organization.
	SponsorsListing *SponsorsListing `json:"sponsorsListing,omitempty"`
	// The sponsorship from the viewer to this user/organization; that is, the sponsorship where you're the sponsor.
	SponsorshipForViewerAsSponsor *Sponsorship `json:"sponsorshipForViewerAsSponsor,omitempty"`
	// The sponsorship from this user/organization to the viewer; that is, the sponsorship you're receiving.
	SponsorshipForViewerAsSponsorable *Sponsorship `json:"sponsorshipForViewerAsSponsorable,omitempty"`
	// List of sponsorship updates sent from this sponsorable to sponsors.
	SponsorshipNewsletters *SponsorshipNewsletterConnection `json:"sponsorshipNewsletters"`
	// The sponsorships where this user or organization is the maintainer receiving the funds.
	SponsorshipsAsMaintainer *SponsorshipConnection `json:"sponsorshipsAsMaintainer"`
	// The sponsorships where this user or organization is the funder.
	SponsorshipsAsSponsor *SponsorshipConnection `json:"sponsorshipsAsSponsor"`
	// The amount in United States cents (e.g., 500 = $5.00 USD) that this entity has
	// spent on GitHub to fund sponsorships. Only returns a value when viewed by the
	// user themselves or by a user who can manage sponsorships for the requested organization.
	TotalSponsorshipAmountAsSponsorInCents *int32 `json:"totalSponsorshipAmountAsSponsorInCents,omitempty"`
	// Whether or not the viewer is able to sponsor this user/organization.
	ViewerCanSponsor bool `json:"viewerCanSponsor"`
	// True if the viewer is sponsoring this user/organization.
	ViewerIsSponsoring bool `json:"viewerIsSponsoring"`

	// Underlying value of the GraphQL interface
	Value SponsorableValue `json:"-"`
}

func (base *Sponsorable) UnmarshalJSON(b []byte) error {
	type Raw Sponsorable
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Organization":
		base.Value = new(Organization)
	case "User":
		base.Value = new(User)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface Sponsorable: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// SponsorableValue is one of: Organization | User
type SponsorableValue interface {
	isSponsorable()
}

// Entities that can be sponsored via GitHub Sponsors
type SponsorableItem struct {
	// Underlying value of the GraphQL union
	Value SponsorableItemValue `json:"-"`
}

func (base *SponsorableItem) UnmarshalJSON(b []byte) error {
	type Raw SponsorableItem
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Organization":
		base.Value = new(Organization)
	case "User":
		base.Value = new(User)
	case "":
		return fmt.Errorf("gqlclient: union SponsorableItem: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union SponsorableItem: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// SponsorableItemValue is one of: Organization | User
type SponsorableItemValue interface {
	isSponsorableItem()
}

// The connection type for SponsorableItem.
type SponsorableItemConnection struct {
	// A list of edges.
	Edges []*SponsorableItemEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*SponsorableItem `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type SponsorableItemEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *SponsorableItem `json:"node,omitempty"`
}

// Ordering options for connections to get sponsorable entities for GitHub Sponsors.
type SponsorableOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order sponsorable entities by.
	Field SponsorableOrderField `json:"field"`
}

// Properties by which sponsorable connections can be ordered.
type SponsorableOrderField string

const (
	// Order sponsorable entities by login (username).
	SponsorableOrderFieldLogin SponsorableOrderField = "LOGIN"
)

// An event related to sponsorship activity.
type SponsorsActivity struct {
	// What action this activity indicates took place.
	Action SponsorsActivityAction `json:"action"`
	// The sponsor's current privacy level.
	CurrentPrivacyLevel *SponsorshipPrivacy `json:"currentPrivacyLevel,omitempty"`
	// The Node ID of the SponsorsActivity object
	Id string `json:"id"`
	// The platform that was used to pay for the sponsorship.
	PaymentSource *SponsorshipPaymentSource `json:"paymentSource,omitempty"`
	// The tier that the sponsorship used to use, for tier change events.
	PreviousSponsorsTier *SponsorsTier `json:"previousSponsorsTier,omitempty"`
	// The user or organization who triggered this activity and was/is sponsoring the sponsorable.
	Sponsor *Sponsor `json:"sponsor,omitempty"`
	// The user or organization that is being sponsored, the maintainer.
	Sponsorable *Sponsorable `json:"sponsorable"`
	// The associated sponsorship tier.
	SponsorsTier *SponsorsTier `json:"sponsorsTier,omitempty"`
	// The timestamp of this event.
	Timestamp *DateTime `json:"timestamp,omitempty"`
	// Was this sponsorship made alongside other sponsorships at the same time from the same sponsor?
	ViaBulkSponsorship bool `json:"viaBulkSponsorship"`
}

func (*SponsorsActivity) isNode() {}

// The possible actions that GitHub Sponsors activities can represent.
type SponsorsActivityAction string

const (
	// The activity was cancelling a sponsorship.
	SponsorsActivityActionCancelledSponsorship SponsorsActivityAction = "CANCELLED_SPONSORSHIP"
	// The activity was starting a sponsorship.
	SponsorsActivityActionNewSponsorship SponsorsActivityAction = "NEW_SPONSORSHIP"
	// The activity was scheduling a downgrade or cancellation.
	SponsorsActivityActionPendingChange SponsorsActivityAction = "PENDING_CHANGE"
	// The activity was funds being refunded to the sponsor or GitHub.
	SponsorsActivityActionRefund SponsorsActivityAction = "REFUND"
	// The activity was disabling matching for a previously matched sponsorship.
	SponsorsActivityActionSponsorMatchDisabled SponsorsActivityAction = "SPONSOR_MATCH_DISABLED"
	// The activity was changing the sponsorship tier, either directly by the sponsor or by a scheduled/pending change.
	SponsorsActivityActionTierChange SponsorsActivityAction = "TIER_CHANGE"
)

// The connection type for SponsorsActivity.
type SponsorsActivityConnection struct {
	// A list of edges.
	Edges []*SponsorsActivityEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*SponsorsActivity `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type SponsorsActivityEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *SponsorsActivity `json:"node,omitempty"`
}

// Ordering options for GitHub Sponsors activity connections.
type SponsorsActivityOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order activity by.
	Field SponsorsActivityOrderField `json:"field"`
}

// Properties by which GitHub Sponsors activity connections can be ordered.
type SponsorsActivityOrderField string

const (
	// Order activities by when they happened.
	SponsorsActivityOrderFieldTimestamp SponsorsActivityOrderField = "TIMESTAMP"
)

// The possible time periods for which Sponsors activities can be requested.
type SponsorsActivityPeriod string

const (
	// Don't restrict the activity to any date range, include all activity.
	SponsorsActivityPeriodAll SponsorsActivityPeriod = "ALL"
	// The previous calendar day.
	SponsorsActivityPeriodDay SponsorsActivityPeriod = "DAY"
	// The previous thirty days.
	SponsorsActivityPeriodMonth SponsorsActivityPeriod = "MONTH"
	// The previous seven days.
	SponsorsActivityPeriodWeek SponsorsActivityPeriod = "WEEK"
)

// Represents countries or regions for billing and residence for a GitHub Sponsors profile.
type SponsorsCountryOrRegionCode string

const (
	// Andorra
	SponsorsCountryOrRegionCodeAd SponsorsCountryOrRegionCode = "AD"
	// United Arab Emirates
	SponsorsCountryOrRegionCodeAe SponsorsCountryOrRegionCode = "AE"
	// Afghanistan
	SponsorsCountryOrRegionCodeAf SponsorsCountryOrRegionCode = "AF"
	// Antigua and Barbuda
	SponsorsCountryOrRegionCodeAg SponsorsCountryOrRegionCode = "AG"
	// Anguilla
	SponsorsCountryOrRegionCodeAi SponsorsCountryOrRegionCode = "AI"
	// Albania
	SponsorsCountryOrRegionCodeAl SponsorsCountryOrRegionCode = "AL"
	// Armenia
	SponsorsCountryOrRegionCodeAm SponsorsCountryOrRegionCode = "AM"
	// Angola
	SponsorsCountryOrRegionCodeAo SponsorsCountryOrRegionCode = "AO"
	// Antarctica
	SponsorsCountryOrRegionCodeAq SponsorsCountryOrRegionCode = "AQ"
	// Argentina
	SponsorsCountryOrRegionCodeAr SponsorsCountryOrRegionCode = "AR"
	// American Samoa
	SponsorsCountryOrRegionCodeAs SponsorsCountryOrRegionCode = "AS"
	// Austria
	SponsorsCountryOrRegionCodeAt SponsorsCountryOrRegionCode = "AT"
	// Australia
	SponsorsCountryOrRegionCodeAu SponsorsCountryOrRegionCode = "AU"
	// Aruba
	SponsorsCountryOrRegionCodeAw SponsorsCountryOrRegionCode = "AW"
	// land
	SponsorsCountryOrRegionCodeAx SponsorsCountryOrRegionCode = "AX"
	// Azerbaijan
	SponsorsCountryOrRegionCodeAz SponsorsCountryOrRegionCode = "AZ"
	// Bosnia and Herzegovina
	SponsorsCountryOrRegionCodeBa SponsorsCountryOrRegionCode = "BA"
	// Barbados
	SponsorsCountryOrRegionCodeBb SponsorsCountryOrRegionCode = "BB"
	// Bangladesh
	SponsorsCountryOrRegionCodeBd SponsorsCountryOrRegionCode = "BD"
	// Belgium
	SponsorsCountryOrRegionCodeBe SponsorsCountryOrRegionCode = "BE"
	// Burkina Faso
	SponsorsCountryOrRegionCodeBf SponsorsCountryOrRegionCode = "BF"
	// Bulgaria
	SponsorsCountryOrRegionCodeBg SponsorsCountryOrRegionCode = "BG"
	// Bahrain
	SponsorsCountryOrRegionCodeBh SponsorsCountryOrRegionCode = "BH"
	// Burundi
	SponsorsCountryOrRegionCodeBi SponsorsCountryOrRegionCode = "BI"
	// Benin
	SponsorsCountryOrRegionCodeBj SponsorsCountryOrRegionCode = "BJ"
	// Saint Barthlemy
	SponsorsCountryOrRegionCodeBl SponsorsCountryOrRegionCode = "BL"
	// Bermuda
	SponsorsCountryOrRegionCodeBm SponsorsCountryOrRegionCode = "BM"
	// Brunei Darussalam
	SponsorsCountryOrRegionCodeBn SponsorsCountryOrRegionCode = "BN"
	// Bolivia
	SponsorsCountryOrRegionCodeBo SponsorsCountryOrRegionCode = "BO"
	// Bonaire, Sint Eustatius and Saba
	SponsorsCountryOrRegionCodeBq SponsorsCountryOrRegionCode = "BQ"
	// Brazil
	SponsorsCountryOrRegionCodeBr SponsorsCountryOrRegionCode = "BR"
	// Bahamas
	SponsorsCountryOrRegionCodeBs SponsorsCountryOrRegionCode = "BS"
	// Bhutan
	SponsorsCountryOrRegionCodeBt SponsorsCountryOrRegionCode = "BT"
	// Bouvet Island
	SponsorsCountryOrRegionCodeBv SponsorsCountryOrRegionCode = "BV"
	// Botswana
	SponsorsCountryOrRegionCodeBw SponsorsCountryOrRegionCode = "BW"
	// Belarus
	SponsorsCountryOrRegionCodeBy SponsorsCountryOrRegionCode = "BY"
	// Belize
	SponsorsCountryOrRegionCodeBz SponsorsCountryOrRegionCode = "BZ"
	// Canada
	SponsorsCountryOrRegionCodeCa SponsorsCountryOrRegionCode = "CA"
	// Cocos (Keeling) Islands
	SponsorsCountryOrRegionCodeCc SponsorsCountryOrRegionCode = "CC"
	// Congo (Kinshasa)
	SponsorsCountryOrRegionCodeCd SponsorsCountryOrRegionCode = "CD"
	// Central African Republic
	SponsorsCountryOrRegionCodeCf SponsorsCountryOrRegionCode = "CF"
	// Congo (Brazzaville)
	SponsorsCountryOrRegionCodeCg SponsorsCountryOrRegionCode = "CG"
	// Switzerland
	SponsorsCountryOrRegionCodeCh SponsorsCountryOrRegionCode = "CH"
	// Cte d'Ivoire
	SponsorsCountryOrRegionCodeCi SponsorsCountryOrRegionCode = "CI"
	// Cook Islands
	SponsorsCountryOrRegionCodeCk SponsorsCountryOrRegionCode = "CK"
	// Chile
	SponsorsCountryOrRegionCodeCl SponsorsCountryOrRegionCode = "CL"
	// Cameroon
	SponsorsCountryOrRegionCodeCm SponsorsCountryOrRegionCode = "CM"
	// China
	SponsorsCountryOrRegionCodeCn SponsorsCountryOrRegionCode = "CN"
	// Colombia
	SponsorsCountryOrRegionCodeCo SponsorsCountryOrRegionCode = "CO"
	// Costa Rica
	SponsorsCountryOrRegionCodeCr SponsorsCountryOrRegionCode = "CR"
	// Cape Verde
	SponsorsCountryOrRegionCodeCv SponsorsCountryOrRegionCode = "CV"
	// Curaao
	SponsorsCountryOrRegionCodeCw SponsorsCountryOrRegionCode = "CW"
	// Christmas Island
	SponsorsCountryOrRegionCodeCx SponsorsCountryOrRegionCode = "CX"
	// Cyprus
	SponsorsCountryOrRegionCodeCy SponsorsCountryOrRegionCode = "CY"
	// Czech Republic
	SponsorsCountryOrRegionCodeCz SponsorsCountryOrRegionCode = "CZ"
	// Germany
	SponsorsCountryOrRegionCodeDe SponsorsCountryOrRegionCode = "DE"
	// Djibouti
	SponsorsCountryOrRegionCodeDj SponsorsCountryOrRegionCode = "DJ"
	// Denmark
	SponsorsCountryOrRegionCodeDk SponsorsCountryOrRegionCode = "DK"
	// Dominica
	SponsorsCountryOrRegionCodeDm SponsorsCountryOrRegionCode = "DM"
	// Dominican Republic
	SponsorsCountryOrRegionCodeDo SponsorsCountryOrRegionCode = "DO"
	// Algeria
	SponsorsCountryOrRegionCodeDz SponsorsCountryOrRegionCode = "DZ"
	// Ecuador
	SponsorsCountryOrRegionCodeEc SponsorsCountryOrRegionCode = "EC"
	// Estonia
	SponsorsCountryOrRegionCodeEe SponsorsCountryOrRegionCode = "EE"
	// Egypt
	SponsorsCountryOrRegionCodeEg SponsorsCountryOrRegionCode = "EG"
	// Western Sahara
	SponsorsCountryOrRegionCodeEh SponsorsCountryOrRegionCode = "EH"
	// Eritrea
	SponsorsCountryOrRegionCodeEr SponsorsCountryOrRegionCode = "ER"
	// Spain
	SponsorsCountryOrRegionCodeEs SponsorsCountryOrRegionCode = "ES"
	// Ethiopia
	SponsorsCountryOrRegionCodeEt SponsorsCountryOrRegionCode = "ET"
	// Finland
	SponsorsCountryOrRegionCodeFi SponsorsCountryOrRegionCode = "FI"
	// Fiji
	SponsorsCountryOrRegionCodeFj SponsorsCountryOrRegionCode = "FJ"
	// Falkland Islands
	SponsorsCountryOrRegionCodeFk SponsorsCountryOrRegionCode = "FK"
	// Micronesia
	SponsorsCountryOrRegionCodeFm SponsorsCountryOrRegionCode = "FM"
	// Faroe Islands
	SponsorsCountryOrRegionCodeFo SponsorsCountryOrRegionCode = "FO"
	// France
	SponsorsCountryOrRegionCodeFr SponsorsCountryOrRegionCode = "FR"
	// Gabon
	SponsorsCountryOrRegionCodeGa SponsorsCountryOrRegionCode = "GA"
	// United Kingdom
	SponsorsCountryOrRegionCodeGb SponsorsCountryOrRegionCode = "GB"
	// Grenada
	SponsorsCountryOrRegionCodeGd SponsorsCountryOrRegionCode = "GD"
	// Georgia
	SponsorsCountryOrRegionCodeGe SponsorsCountryOrRegionCode = "GE"
	// French Guiana
	SponsorsCountryOrRegionCodeGf SponsorsCountryOrRegionCode = "GF"
	// Guernsey
	SponsorsCountryOrRegionCodeGg SponsorsCountryOrRegionCode = "GG"
	// Ghana
	SponsorsCountryOrRegionCodeGh SponsorsCountryOrRegionCode = "GH"
	// Gibraltar
	SponsorsCountryOrRegionCodeGi SponsorsCountryOrRegionCode = "GI"
	// Greenland
	SponsorsCountryOrRegionCodeGl SponsorsCountryOrRegionCode = "GL"
	// Gambia
	SponsorsCountryOrRegionCodeGm SponsorsCountryOrRegionCode = "GM"
	// Guinea
	SponsorsCountryOrRegionCodeGn SponsorsCountryOrRegionCode = "GN"
	// Guadeloupe
	SponsorsCountryOrRegionCodeGp SponsorsCountryOrRegionCode = "GP"
	// Equatorial Guinea
	SponsorsCountryOrRegionCodeGq SponsorsCountryOrRegionCode = "GQ"
	// Greece
	SponsorsCountryOrRegionCodeGr SponsorsCountryOrRegionCode = "GR"
	// South Georgia and South Sandwich Islands
	SponsorsCountryOrRegionCodeGs SponsorsCountryOrRegionCode = "GS"
	// Guatemala
	SponsorsCountryOrRegionCodeGt SponsorsCountryOrRegionCode = "GT"
	// Guam
	SponsorsCountryOrRegionCodeGu SponsorsCountryOrRegionCode = "GU"
	// Guinea-Bissau
	SponsorsCountryOrRegionCodeGw SponsorsCountryOrRegionCode = "GW"
	// Guyana
	SponsorsCountryOrRegionCodeGy SponsorsCountryOrRegionCode = "GY"
	// Hong Kong
	SponsorsCountryOrRegionCodeHk SponsorsCountryOrRegionCode = "HK"
	// Heard and McDonald Islands
	SponsorsCountryOrRegionCodeHm SponsorsCountryOrRegionCode = "HM"
	// Honduras
	SponsorsCountryOrRegionCodeHn SponsorsCountryOrRegionCode = "HN"
	// Croatia
	SponsorsCountryOrRegionCodeHr SponsorsCountryOrRegionCode = "HR"
	// Haiti
	SponsorsCountryOrRegionCodeHt SponsorsCountryOrRegionCode = "HT"
	// Hungary
	SponsorsCountryOrRegionCodeHu SponsorsCountryOrRegionCode = "HU"
	// Indonesia
	SponsorsCountryOrRegionCodeId SponsorsCountryOrRegionCode = "ID"
	// Ireland
	SponsorsCountryOrRegionCodeIe SponsorsCountryOrRegionCode = "IE"
	// Israel
	SponsorsCountryOrRegionCodeIl SponsorsCountryOrRegionCode = "IL"
	// Isle of Man
	SponsorsCountryOrRegionCodeIm SponsorsCountryOrRegionCode = "IM"
	// India
	SponsorsCountryOrRegionCodeIn SponsorsCountryOrRegionCode = "IN"
	// British Indian Ocean Territory
	SponsorsCountryOrRegionCodeIo SponsorsCountryOrRegionCode = "IO"
	// Iraq
	SponsorsCountryOrRegionCodeIq SponsorsCountryOrRegionCode = "IQ"
	// Iran
	SponsorsCountryOrRegionCodeIr SponsorsCountryOrRegionCode = "IR"
	// Iceland
	SponsorsCountryOrRegionCodeIs SponsorsCountryOrRegionCode = "IS"
	// Italy
	SponsorsCountryOrRegionCodeIt SponsorsCountryOrRegionCode = "IT"
	// Jersey
	SponsorsCountryOrRegionCodeJe SponsorsCountryOrRegionCode = "JE"
	// Jamaica
	SponsorsCountryOrRegionCodeJm SponsorsCountryOrRegionCode = "JM"
	// Jordan
	SponsorsCountryOrRegionCodeJo SponsorsCountryOrRegionCode = "JO"
	// Japan
	SponsorsCountryOrRegionCodeJp SponsorsCountryOrRegionCode = "JP"
	// Kenya
	SponsorsCountryOrRegionCodeKe SponsorsCountryOrRegionCode = "KE"
	// Kyrgyzstan
	SponsorsCountryOrRegionCodeKg SponsorsCountryOrRegionCode = "KG"
	// Cambodia
	SponsorsCountryOrRegionCodeKh SponsorsCountryOrRegionCode = "KH"
	// Kiribati
	SponsorsCountryOrRegionCodeKi SponsorsCountryOrRegionCode = "KI"
	// Comoros
	SponsorsCountryOrRegionCodeKm SponsorsCountryOrRegionCode = "KM"
	// Saint Kitts and Nevis
	SponsorsCountryOrRegionCodeKn SponsorsCountryOrRegionCode = "KN"
	// Korea, South
	SponsorsCountryOrRegionCodeKr SponsorsCountryOrRegionCode = "KR"
	// Kuwait
	SponsorsCountryOrRegionCodeKw SponsorsCountryOrRegionCode = "KW"
	// Cayman Islands
	SponsorsCountryOrRegionCodeKy SponsorsCountryOrRegionCode = "KY"
	// Kazakhstan
	SponsorsCountryOrRegionCodeKz SponsorsCountryOrRegionCode = "KZ"
	// Laos
	SponsorsCountryOrRegionCodeLa SponsorsCountryOrRegionCode = "LA"
	// Lebanon
	SponsorsCountryOrRegionCodeLb SponsorsCountryOrRegionCode = "LB"
	// Saint Lucia
	SponsorsCountryOrRegionCodeLc SponsorsCountryOrRegionCode = "LC"
	// Liechtenstein
	SponsorsCountryOrRegionCodeLi SponsorsCountryOrRegionCode = "LI"
	// Sri Lanka
	SponsorsCountryOrRegionCodeLk SponsorsCountryOrRegionCode = "LK"
	// Liberia
	SponsorsCountryOrRegionCodeLr SponsorsCountryOrRegionCode = "LR"
	// Lesotho
	SponsorsCountryOrRegionCodeLs SponsorsCountryOrRegionCode = "LS"
	// Lithuania
	SponsorsCountryOrRegionCodeLt SponsorsCountryOrRegionCode = "LT"
	// Luxembourg
	SponsorsCountryOrRegionCodeLu SponsorsCountryOrRegionCode = "LU"
	// Latvia
	SponsorsCountryOrRegionCodeLv SponsorsCountryOrRegionCode = "LV"
	// Libya
	SponsorsCountryOrRegionCodeLy SponsorsCountryOrRegionCode = "LY"
	// Morocco
	SponsorsCountryOrRegionCodeMa SponsorsCountryOrRegionCode = "MA"
	// Monaco
	SponsorsCountryOrRegionCodeMc SponsorsCountryOrRegionCode = "MC"
	// Moldova
	SponsorsCountryOrRegionCodeMd SponsorsCountryOrRegionCode = "MD"
	// Montenegro
	SponsorsCountryOrRegionCodeMe SponsorsCountryOrRegionCode = "ME"
	// Saint Martin (French part)
	SponsorsCountryOrRegionCodeMf SponsorsCountryOrRegionCode = "MF"
	// Madagascar
	SponsorsCountryOrRegionCodeMg SponsorsCountryOrRegionCode = "MG"
	// Marshall Islands
	SponsorsCountryOrRegionCodeMh SponsorsCountryOrRegionCode = "MH"
	// Macedonia
	SponsorsCountryOrRegionCodeMk SponsorsCountryOrRegionCode = "MK"
	// Mali
	SponsorsCountryOrRegionCodeMl SponsorsCountryOrRegionCode = "ML"
	// Myanmar
	SponsorsCountryOrRegionCodeMm SponsorsCountryOrRegionCode = "MM"
	// Mongolia
	SponsorsCountryOrRegionCodeMn SponsorsCountryOrRegionCode = "MN"
	// Macau
	SponsorsCountryOrRegionCodeMo SponsorsCountryOrRegionCode = "MO"
	// Northern Mariana Islands
	SponsorsCountryOrRegionCodeMp SponsorsCountryOrRegionCode = "MP"
	// Martinique
	SponsorsCountryOrRegionCodeMq SponsorsCountryOrRegionCode = "MQ"
	// Mauritania
	SponsorsCountryOrRegionCodeMr SponsorsCountryOrRegionCode = "MR"
	// Montserrat
	SponsorsCountryOrRegionCodeMs SponsorsCountryOrRegionCode = "MS"
	// Malta
	SponsorsCountryOrRegionCodeMt SponsorsCountryOrRegionCode = "MT"
	// Mauritius
	SponsorsCountryOrRegionCodeMu SponsorsCountryOrRegionCode = "MU"
	// Maldives
	SponsorsCountryOrRegionCodeMv SponsorsCountryOrRegionCode = "MV"
	// Malawi
	SponsorsCountryOrRegionCodeMw SponsorsCountryOrRegionCode = "MW"
	// Mexico
	SponsorsCountryOrRegionCodeMx SponsorsCountryOrRegionCode = "MX"
	// Malaysia
	SponsorsCountryOrRegionCodeMy SponsorsCountryOrRegionCode = "MY"
	// Mozambique
	SponsorsCountryOrRegionCodeMz SponsorsCountryOrRegionCode = "MZ"
	// Namibia
	SponsorsCountryOrRegionCodeNa SponsorsCountryOrRegionCode = "NA"
	// New Caledonia
	SponsorsCountryOrRegionCodeNc SponsorsCountryOrRegionCode = "NC"
	// Niger
	SponsorsCountryOrRegionCodeNe SponsorsCountryOrRegionCode = "NE"
	// Norfolk Island
	SponsorsCountryOrRegionCodeNf SponsorsCountryOrRegionCode = "NF"
	// Nigeria
	SponsorsCountryOrRegionCodeNg SponsorsCountryOrRegionCode = "NG"
	// Nicaragua
	SponsorsCountryOrRegionCodeNi SponsorsCountryOrRegionCode = "NI"
	// Netherlands
	SponsorsCountryOrRegionCodeNl SponsorsCountryOrRegionCode = "NL"
	// Norway
	SponsorsCountryOrRegionCodeNo SponsorsCountryOrRegionCode = "NO"
	// Nepal
	SponsorsCountryOrRegionCodeNp SponsorsCountryOrRegionCode = "NP"
	// Nauru
	SponsorsCountryOrRegionCodeNr SponsorsCountryOrRegionCode = "NR"
	// Niue
	SponsorsCountryOrRegionCodeNu SponsorsCountryOrRegionCode = "NU"
	// New Zealand
	SponsorsCountryOrRegionCodeNz SponsorsCountryOrRegionCode = "NZ"
	// Oman
	SponsorsCountryOrRegionCodeOm SponsorsCountryOrRegionCode = "OM"
	// Panama
	SponsorsCountryOrRegionCodePa SponsorsCountryOrRegionCode = "PA"
	// Peru
	SponsorsCountryOrRegionCodePe SponsorsCountryOrRegionCode = "PE"
	// French Polynesia
	SponsorsCountryOrRegionCodePf SponsorsCountryOrRegionCode = "PF"
	// Papua New Guinea
	SponsorsCountryOrRegionCodePg SponsorsCountryOrRegionCode = "PG"
	// Philippines
	SponsorsCountryOrRegionCodePh SponsorsCountryOrRegionCode = "PH"
	// Pakistan
	SponsorsCountryOrRegionCodePk SponsorsCountryOrRegionCode = "PK"
	// Poland
	SponsorsCountryOrRegionCodePl SponsorsCountryOrRegionCode = "PL"
	// Saint Pierre and Miquelon
	SponsorsCountryOrRegionCodePm SponsorsCountryOrRegionCode = "PM"
	// Pitcairn
	SponsorsCountryOrRegionCodePn SponsorsCountryOrRegionCode = "PN"
	// Puerto Rico
	SponsorsCountryOrRegionCodePr SponsorsCountryOrRegionCode = "PR"
	// Palestine
	SponsorsCountryOrRegionCodePs SponsorsCountryOrRegionCode = "PS"
	// Portugal
	SponsorsCountryOrRegionCodePt SponsorsCountryOrRegionCode = "PT"
	// Palau
	SponsorsCountryOrRegionCodePw SponsorsCountryOrRegionCode = "PW"
	// Paraguay
	SponsorsCountryOrRegionCodePy SponsorsCountryOrRegionCode = "PY"
	// Qatar
	SponsorsCountryOrRegionCodeQa SponsorsCountryOrRegionCode = "QA"
	// Reunion
	SponsorsCountryOrRegionCodeRe SponsorsCountryOrRegionCode = "RE"
	// Romania
	SponsorsCountryOrRegionCodeRo SponsorsCountryOrRegionCode = "RO"
	// Serbia
	SponsorsCountryOrRegionCodeRs SponsorsCountryOrRegionCode = "RS"
	// Russian Federation
	SponsorsCountryOrRegionCodeRu SponsorsCountryOrRegionCode = "RU"
	// Rwanda
	SponsorsCountryOrRegionCodeRw SponsorsCountryOrRegionCode = "RW"
	// Saudi Arabia
	SponsorsCountryOrRegionCodeSa SponsorsCountryOrRegionCode = "SA"
	// Solomon Islands
	SponsorsCountryOrRegionCodeSb SponsorsCountryOrRegionCode = "SB"
	// Seychelles
	SponsorsCountryOrRegionCodeSc SponsorsCountryOrRegionCode = "SC"
	// Sudan
	SponsorsCountryOrRegionCodeSd SponsorsCountryOrRegionCode = "SD"
	// Sweden
	SponsorsCountryOrRegionCodeSe SponsorsCountryOrRegionCode = "SE"
	// Singapore
	SponsorsCountryOrRegionCodeSg SponsorsCountryOrRegionCode = "SG"
	// Saint Helena
	SponsorsCountryOrRegionCodeSh SponsorsCountryOrRegionCode = "SH"
	// Slovenia
	SponsorsCountryOrRegionCodeSi SponsorsCountryOrRegionCode = "SI"
	// Svalbard and Jan Mayen Islands
	SponsorsCountryOrRegionCodeSj SponsorsCountryOrRegionCode = "SJ"
	// Slovakia
	SponsorsCountryOrRegionCodeSk SponsorsCountryOrRegionCode = "SK"
	// Sierra Leone
	SponsorsCountryOrRegionCodeSl SponsorsCountryOrRegionCode = "SL"
	// San Marino
	SponsorsCountryOrRegionCodeSm SponsorsCountryOrRegionCode = "SM"
	// Senegal
	SponsorsCountryOrRegionCodeSn SponsorsCountryOrRegionCode = "SN"
	// Somalia
	SponsorsCountryOrRegionCodeSo SponsorsCountryOrRegionCode = "SO"
	// Suriname
	SponsorsCountryOrRegionCodeSr SponsorsCountryOrRegionCode = "SR"
	// South Sudan
	SponsorsCountryOrRegionCodeSs SponsorsCountryOrRegionCode = "SS"
	// Sao Tome and Principe
	SponsorsCountryOrRegionCodeSt SponsorsCountryOrRegionCode = "ST"
	// El Salvador
	SponsorsCountryOrRegionCodeSv SponsorsCountryOrRegionCode = "SV"
	// Sint Maarten (Dutch part)
	SponsorsCountryOrRegionCodeSx SponsorsCountryOrRegionCode = "SX"
	// Swaziland
	SponsorsCountryOrRegionCodeSz SponsorsCountryOrRegionCode = "SZ"
	// Turks and Caicos Islands
	SponsorsCountryOrRegionCodeTc SponsorsCountryOrRegionCode = "TC"
	// Chad
	SponsorsCountryOrRegionCodeTd SponsorsCountryOrRegionCode = "TD"
	// French Southern Lands
	SponsorsCountryOrRegionCodeTf SponsorsCountryOrRegionCode = "TF"
	// Togo
	SponsorsCountryOrRegionCodeTg SponsorsCountryOrRegionCode = "TG"
	// Thailand
	SponsorsCountryOrRegionCodeTh SponsorsCountryOrRegionCode = "TH"
	// Tajikistan
	SponsorsCountryOrRegionCodeTj SponsorsCountryOrRegionCode = "TJ"
	// Tokelau
	SponsorsCountryOrRegionCodeTk SponsorsCountryOrRegionCode = "TK"
	// Timor-Leste
	SponsorsCountryOrRegionCodeTl SponsorsCountryOrRegionCode = "TL"
	// Turkmenistan
	SponsorsCountryOrRegionCodeTm SponsorsCountryOrRegionCode = "TM"
	// Tunisia
	SponsorsCountryOrRegionCodeTn SponsorsCountryOrRegionCode = "TN"
	// Tonga
	SponsorsCountryOrRegionCodeTo SponsorsCountryOrRegionCode = "TO"
	// Trkiye
	SponsorsCountryOrRegionCodeTr SponsorsCountryOrRegionCode = "TR"
	// Trinidad and Tobago
	SponsorsCountryOrRegionCodeTt SponsorsCountryOrRegionCode = "TT"
	// Tuvalu
	SponsorsCountryOrRegionCodeTv SponsorsCountryOrRegionCode = "TV"
	// Taiwan
	SponsorsCountryOrRegionCodeTw SponsorsCountryOrRegionCode = "TW"
	// Tanzania
	SponsorsCountryOrRegionCodeTz SponsorsCountryOrRegionCode = "TZ"
	// Ukraine
	SponsorsCountryOrRegionCodeUa SponsorsCountryOrRegionCode = "UA"
	// Uganda
	SponsorsCountryOrRegionCodeUg SponsorsCountryOrRegionCode = "UG"
	// United States Minor Outlying Islands
	SponsorsCountryOrRegionCodeUm SponsorsCountryOrRegionCode = "UM"
	// United States of America
	SponsorsCountryOrRegionCodeUs SponsorsCountryOrRegionCode = "US"
	// Uruguay
	SponsorsCountryOrRegionCodeUy SponsorsCountryOrRegionCode = "UY"
	// Uzbekistan
	SponsorsCountryOrRegionCodeUz SponsorsCountryOrRegionCode = "UZ"
	// Vatican City
	SponsorsCountryOrRegionCodeVa SponsorsCountryOrRegionCode = "VA"
	// Saint Vincent and the Grenadines
	SponsorsCountryOrRegionCodeVc SponsorsCountryOrRegionCode = "VC"
	// Venezuela
	SponsorsCountryOrRegionCodeVe SponsorsCountryOrRegionCode = "VE"
	// Virgin Islands, British
	SponsorsCountryOrRegionCodeVg SponsorsCountryOrRegionCode = "VG"
	// Virgin Islands, U.S.
	SponsorsCountryOrRegionCodeVi SponsorsCountryOrRegionCode = "VI"
	// Vietnam
	SponsorsCountryOrRegionCodeVn SponsorsCountryOrRegionCode = "VN"
	// Vanuatu
	SponsorsCountryOrRegionCodeVu SponsorsCountryOrRegionCode = "VU"
	// Wallis and Futuna Islands
	SponsorsCountryOrRegionCodeWf SponsorsCountryOrRegionCode = "WF"
	// Samoa
	SponsorsCountryOrRegionCodeWs SponsorsCountryOrRegionCode = "WS"
	// Yemen
	SponsorsCountryOrRegionCodeYe SponsorsCountryOrRegionCode = "YE"
	// Mayotte
	SponsorsCountryOrRegionCodeYt SponsorsCountryOrRegionCode = "YT"
	// South Africa
	SponsorsCountryOrRegionCodeZa SponsorsCountryOrRegionCode = "ZA"
	// Zambia
	SponsorsCountryOrRegionCodeZm SponsorsCountryOrRegionCode = "ZM"
	// Zimbabwe
	SponsorsCountryOrRegionCodeZw SponsorsCountryOrRegionCode = "ZW"
)

// A goal associated with a GitHub Sponsors listing, representing a target the sponsored maintainer would like to attain.
type SponsorsGoal struct {
	// A description of the goal from the maintainer.
	Description *string `json:"description,omitempty"`
	// What the objective of this goal is.
	Kind SponsorsGoalKind `json:"kind"`
	// The percentage representing how complete this goal is, between 0-100.
	PercentComplete int32 `json:"percentComplete"`
	// What the goal amount is. Represents an amount in USD for monthly sponsorship
	// amount goals. Represents a count of unique sponsors for total sponsors count goals.
	TargetValue int32 `json:"targetValue"`
	// A brief summary of the kind and target value of this goal.
	Title string `json:"title"`
}

// The different kinds of goals a GitHub Sponsors member can have.
type SponsorsGoalKind string

const (
	// The goal is about getting a certain amount in USD from sponsorships each month.
	SponsorsGoalKindMonthlySponsorshipAmount SponsorsGoalKind = "MONTHLY_SPONSORSHIP_AMOUNT"
	// The goal is about reaching a certain number of sponsors.
	SponsorsGoalKindTotalSponsorsCount SponsorsGoalKind = "TOTAL_SPONSORS_COUNT"
)

// A GitHub Sponsors listing.
type SponsorsListing struct {
	// The current goal the maintainer is trying to reach with GitHub Sponsors, if any.
	ActiveGoal *SponsorsGoal `json:"activeGoal,omitempty"`
	// The Stripe Connect account currently in use for payouts for this Sponsors
	// listing, if any. Will only return a value when queried by the maintainer
	// themselves, or by an admin of the sponsorable organization.
	ActiveStripeConnectAccount *StripeConnectAccount `json:"activeStripeConnectAccount,omitempty"`
	// The name of the country or region with the maintainer's bank account or fiscal
	// host. Will only return a value when queried by the maintainer themselves, or
	// by an admin of the sponsorable organization.
	BillingCountryOrRegion *string `json:"billingCountryOrRegion,omitempty"`
	// The email address used by GitHub to contact the sponsorable about their GitHub
	// Sponsors profile. Will only return a value when queried by the maintainer
	// themselves, or by an admin of the sponsorable organization.
	ContactEmailAddress *string `json:"contactEmailAddress,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The HTTP path for the Sponsors dashboard for this Sponsors listing.
	DashboardResourcePath URI `json:"dashboardResourcePath"`
	// The HTTP URL for the Sponsors dashboard for this Sponsors listing.
	DashboardUrl URI `json:"dashboardUrl"`
	// The records featured on the GitHub Sponsors profile.
	FeaturedItems []SponsorsListingFeaturedItem `json:"featuredItems"`
	// The fiscal host used for payments, if any. Will only return a value when
	// queried by the maintainer themselves, or by an admin of the sponsorable organization.
	FiscalHost *Organization `json:"fiscalHost,omitempty"`
	// The full description of the listing.
	FullDescription string `json:"fullDescription"`
	// The full description of the listing rendered to HTML.
	FullDescriptionHTML HTML `json:"fullDescriptionHTML"`
	// The Node ID of the SponsorsListing object
	Id string `json:"id"`
	// Whether this listing is publicly visible.
	IsPublic bool `json:"isPublic"`
	// The listing's full name.
	Name string `json:"name"`
	// A future date on which this listing is eligible to receive a payout.
	NextPayoutDate *Date `json:"nextPayoutDate,omitempty"`
	// The name of the country or region where the maintainer resides. Will only
	// return a value when queried by the maintainer themselves, or by an admin of
	// the sponsorable organization.
	ResidenceCountryOrRegion *string `json:"residenceCountryOrRegion,omitempty"`
	// The HTTP path for this Sponsors listing.
	ResourcePath URI `json:"resourcePath"`
	// The short description of the listing.
	ShortDescription string `json:"shortDescription"`
	// The short name of the listing.
	Slug string `json:"slug"`
	// The entity this listing represents who can be sponsored on GitHub Sponsors.
	Sponsorable *Sponsorable `json:"sponsorable"`
	// The tiers for this GitHub Sponsors profile.
	Tiers *SponsorsTierConnection `json:"tiers,omitempty"`
	// The HTTP URL for this Sponsors listing.
	Url URI `json:"url"`
}

func (*SponsorsListing) isNode() {}

// A record that can be featured on a GitHub Sponsors profile.
type SponsorsListingFeatureableItem struct {
	// Underlying value of the GraphQL union
	Value SponsorsListingFeatureableItemValue `json:"-"`
}

func (base *SponsorsListingFeatureableItem) UnmarshalJSON(b []byte) error {
	type Raw SponsorsListingFeatureableItem
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Repository":
		base.Value = new(Repository)
	case "User":
		base.Value = new(User)
	case "":
		return fmt.Errorf("gqlclient: union SponsorsListingFeatureableItem: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union SponsorsListingFeatureableItem: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// SponsorsListingFeatureableItemValue is one of: Repository | User
type SponsorsListingFeatureableItemValue interface {
	isSponsorsListingFeatureableItem()
}

// A record that is promoted on a GitHub Sponsors profile.
type SponsorsListingFeaturedItem struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Will either be a description from the sponsorable maintainer about why they
	// featured this item, or the item's description itself, such as a user's bio
	// from their GitHub profile page.
	Description *string `json:"description,omitempty"`
	// The record that is featured on the GitHub Sponsors profile.
	Featureable SponsorsListingFeatureableItem `json:"featureable"`
	// The Node ID of the SponsorsListingFeaturedItem object
	Id string `json:"id"`
	// The position of this featured item on the GitHub Sponsors profile with a lower
	// position indicating higher precedence. Starts at 1.
	Position int32 `json:"position"`
	// The GitHub Sponsors profile that features this record.
	SponsorsListing *SponsorsListing `json:"sponsorsListing"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
}

func (*SponsorsListingFeaturedItem) isNode() {}

// The different kinds of records that can be featured on a GitHub Sponsors profile page.
type SponsorsListingFeaturedItemFeatureableType string

const (
	// A repository owned by the user or organization with the GitHub Sponsors profile.
	SponsorsListingFeaturedItemFeatureableTypeRepository SponsorsListingFeaturedItemFeatureableType = "REPOSITORY"
	// A user who belongs to the organization with the GitHub Sponsors profile.
	SponsorsListingFeaturedItemFeatureableTypeUser SponsorsListingFeaturedItemFeatureableType = "USER"
)

// A GitHub Sponsors tier associated with a GitHub Sponsors listing.
type SponsorsTier struct {
	// SponsorsTier information only visible to users that can administer the associated Sponsors listing.
	AdminInfo *SponsorsTierAdminInfo `json:"adminInfo,omitempty"`
	// Get a different tier for this tier's maintainer that is at the same frequency
	// as this tier but with an equal or lesser cost. Returns the published tier with
	// the monthly price closest to this tier's without going over.
	ClosestLesserValueTier *SponsorsTier `json:"closestLesserValueTier,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The description of the tier.
	Description string `json:"description"`
	// The tier description rendered to HTML
	DescriptionHTML HTML `json:"descriptionHTML"`
	// The Node ID of the SponsorsTier object
	Id string `json:"id"`
	// Whether this tier was chosen at checkout time by the sponsor rather than
	// defined ahead of time by the maintainer who manages the Sponsors listing.
	IsCustomAmount bool `json:"isCustomAmount"`
	// Whether this tier is only for use with one-time sponsorships.
	IsOneTime bool `json:"isOneTime"`
	// How much this tier costs per month in cents.
	MonthlyPriceInCents int32 `json:"monthlyPriceInCents"`
	// How much this tier costs per month in USD.
	MonthlyPriceInDollars int32 `json:"monthlyPriceInDollars"`
	// The name of the tier.
	Name string `json:"name"`
	// The sponsors listing that this tier belongs to.
	SponsorsListing *SponsorsListing `json:"sponsorsListing"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
}

func (*SponsorsTier) isNode() {}

// SponsorsTier information only visible to users that can administer the associated Sponsors listing.
type SponsorsTierAdminInfo struct {
	// Indicates whether this tier is still a work in progress by the sponsorable and
	// not yet published to the associated GitHub Sponsors profile. Draft tiers
	// cannot be used for new sponsorships and will not be in use on existing
	// sponsorships. Draft tiers cannot be seen by anyone but the admins of the
	// GitHub Sponsors profile.
	IsDraft bool `json:"isDraft"`
	// Indicates whether this tier is published to the associated GitHub Sponsors
	// profile. Published tiers are visible to anyone who can see the GitHub Sponsors
	// profile, and are available for use in sponsorships if the GitHub Sponsors
	// profile is publicly visible.
	IsPublished bool `json:"isPublished"`
	// Indicates whether this tier has been retired from the associated GitHub
	// Sponsors profile. Retired tiers are no longer shown on the GitHub Sponsors
	// profile and cannot be chosen for new sponsorships. Existing sponsorships may
	// still use retired tiers if the sponsor selected the tier before it was retired.
	IsRetired bool `json:"isRetired"`
	// The sponsorships using this tier.
	Sponsorships *SponsorshipConnection `json:"sponsorships"`
}

// The connection type for SponsorsTier.
type SponsorsTierConnection struct {
	// A list of edges.
	Edges []*SponsorsTierEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*SponsorsTier `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type SponsorsTierEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *SponsorsTier `json:"node,omitempty"`
}

// Ordering options for Sponsors tiers connections.
type SponsorsTierOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order tiers by.
	Field SponsorsTierOrderField `json:"field"`
}

// Properties by which Sponsors tiers connections can be ordered.
type SponsorsTierOrderField string

const (
	// Order tiers by creation time.
	SponsorsTierOrderFieldCreatedAt SponsorsTierOrderField = "CREATED_AT"
	// Order tiers by their monthly price in cents
	SponsorsTierOrderFieldMonthlyPriceInCents SponsorsTierOrderField = "MONTHLY_PRICE_IN_CENTS"
)

// A sponsorship relationship between a sponsor and a maintainer
type Sponsorship struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the Sponsorship object
	Id string `json:"id"`
	// Whether the sponsorship is active. False implies the sponsor is a past sponsor
	// of the maintainer, while true implies they are a current sponsor.
	IsActive bool `json:"isActive"`
	// Whether this sponsorship represents a one-time payment versus a recurring sponsorship.
	IsOneTimePayment bool `json:"isOneTimePayment"`
	// Whether the sponsor has chosen to receive sponsorship update emails sent from
	// the sponsorable. Only returns a non-null value when the viewer has permission to know this.
	IsSponsorOptedIntoEmail *bool `json:"isSponsorOptedIntoEmail,omitempty"`
	// The entity that is being sponsored
	Maintainer *User `json:"maintainer"`
	// The platform that was most recently used to pay for the sponsorship.
	PaymentSource *SponsorshipPaymentSource `json:"paymentSource,omitempty"`
	// The privacy level for this sponsorship.
	PrivacyLevel SponsorshipPrivacy `json:"privacyLevel"`
	// The user that is sponsoring. Returns null if the sponsorship is private or if sponsor is not a user.
	Sponsor *User `json:"sponsor,omitempty"`
	// The user or organization that is sponsoring, if you have permission to view them.
	SponsorEntity *Sponsor `json:"sponsorEntity,omitempty"`
	// The entity that is being sponsored
	Sponsorable *Sponsorable `json:"sponsorable"`
	// The associated sponsorship tier
	Tier *SponsorsTier `json:"tier,omitempty"`
	// Identifies the date and time when the current tier was chosen for this sponsorship.
	TierSelectedAt *DateTime `json:"tierSelectedAt,omitempty"`
}

func (*Sponsorship) isNode() {}

// A list of sponsorships either from the subject or received by the subject.
type SponsorshipConnection struct {
	// A list of edges.
	Edges []*SponsorshipEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*Sponsorship `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
	// The total amount in cents of all recurring sponsorships in the connection
	// whose amount you can view. Does not include one-time sponsorships.
	TotalRecurringMonthlyPriceInCents int32 `json:"totalRecurringMonthlyPriceInCents"`
	// The total amount in USD of all recurring sponsorships in the connection whose
	// amount you can view. Does not include one-time sponsorships.
	TotalRecurringMonthlyPriceInDollars int32 `json:"totalRecurringMonthlyPriceInDollars"`
}

// An edge in a connection.
type SponsorshipEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *Sponsorship `json:"node,omitempty"`
}

// An update sent to sponsors of a user or organization on GitHub Sponsors.
type SponsorshipNewsletter struct {
	// The author of the newsletter.
	Author *User `json:"author,omitempty"`
	// The contents of the newsletter, the message the sponsorable wanted to give.
	Body string `json:"body"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the SponsorshipNewsletter object
	Id string `json:"id"`
	// Indicates if the newsletter has been made available to sponsors.
	IsPublished bool `json:"isPublished"`
	// The user or organization this newsletter is from.
	Sponsorable *Sponsorable `json:"sponsorable"`
	// The subject of the newsletter, what it's about.
	Subject string `json:"subject"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
}

func (*SponsorshipNewsletter) isNode() {}

// The connection type for SponsorshipNewsletter.
type SponsorshipNewsletterConnection struct {
	// A list of edges.
	Edges []*SponsorshipNewsletterEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*SponsorshipNewsletter `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type SponsorshipNewsletterEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *SponsorshipNewsletter `json:"node,omitempty"`
}

// Ordering options for sponsorship newsletter connections.
type SponsorshipNewsletterOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order sponsorship newsletters by.
	Field SponsorshipNewsletterOrderField `json:"field"`
}

// Properties by which sponsorship update connections can be ordered.
type SponsorshipNewsletterOrderField string

const (
	// Order sponsorship newsletters by when they were created.
	SponsorshipNewsletterOrderFieldCreatedAt SponsorshipNewsletterOrderField = "CREATED_AT"
)

// Ordering options for sponsorship connections.
type SponsorshipOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order sponsorship by.
	Field SponsorshipOrderField `json:"field"`
}

// Properties by which sponsorship connections can be ordered.
type SponsorshipOrderField string

const (
	// Order sponsorship by creation time.
	SponsorshipOrderFieldCreatedAt SponsorshipOrderField = "CREATED_AT"
)

// How payment was made for funding a GitHub Sponsors sponsorship.
type SponsorshipPaymentSource string

const (
	// Payment was made through GitHub.
	SponsorshipPaymentSourceGithub SponsorshipPaymentSource = "GITHUB"
	// Payment was made through Patreon.
	SponsorshipPaymentSourcePatreon SponsorshipPaymentSource = "PATREON"
)

// The privacy of a sponsorship
type SponsorshipPrivacy string

const (
	// Private
	SponsorshipPrivacyPrivate SponsorshipPrivacy = "PRIVATE"
	// Public
	SponsorshipPrivacyPublic SponsorshipPrivacy = "PUBLIC"
)

// The possible default commit messages for squash merges.
type SquashMergeCommitMessage string

const (
	// Default to a blank commit message.
	SquashMergeCommitMessageBlank SquashMergeCommitMessage = "BLANK"
	// Default to the branch's commit messages.
	SquashMergeCommitMessageCommitMessages SquashMergeCommitMessage = "COMMIT_MESSAGES"
	// Default to the pull request's body.
	SquashMergeCommitMessagePrBody SquashMergeCommitMessage = "PR_BODY"
)

// The possible default commit titles for squash merges.
type SquashMergeCommitTitle string

const (
	// Default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
	SquashMergeCommitTitleCommitOrPrTitle SquashMergeCommitTitle = "COMMIT_OR_PR_TITLE"
	// Default to the pull request's title.
	SquashMergeCommitTitlePrTitle SquashMergeCommitTitle = "PR_TITLE"
)

// Represents an SSH signature on a Commit or Tag.
type SshSignature struct {
	// Email used to sign this object.
	Email string `json:"email"`
	// True if the signature is valid and verified by GitHub.
	IsValid bool `json:"isValid"`
	// Hex-encoded fingerprint of the key that signed this object.
	KeyFingerprint *string `json:"keyFingerprint,omitempty"`
	// Payload for GPG signing object. Raw ODB object without the signature header.
	Payload string `json:"payload"`
	// ASCII-armored signature header from object.
	Signature string `json:"signature"`
	// GitHub user corresponding to the email signing this commit.
	Signer *User `json:"signer,omitempty"`
	// The state of this signature. `VALID` if signature is valid and verified by
	// GitHub, otherwise represents reason why signature is considered invalid.
	State GitSignatureState `json:"state"`
	// The date the signature was verified, if valid
	VerifiedAt *DateTime `json:"verifiedAt,omitempty"`
	// True if the signature was made with GitHub's signing key.
	WasSignedByGitHub bool `json:"wasSignedByGitHub"`
}

func (*SshSignature) isGitSignature() {}

// Ways in which star connections can be ordered.
type StarOrder struct {
	// The direction in which to order nodes.
	Direction OrderDirection `json:"direction"`
	// The field in which to order nodes by.
	Field StarOrderField `json:"field"`
}

// Properties by which star connections can be ordered.
type StarOrderField string

const (
	// Allows ordering a list of stars by when they were created.
	StarOrderFieldStarredAt StarOrderField = "STARRED_AT"
)

// The connection type for User.
type StargazerConnection struct {
	// A list of edges.
	Edges []*StargazerEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*User `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// Represents a user that's starred a repository.
type StargazerEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	Node   *User  `json:"node"`
	// Identifies when the item was starred.
	StarredAt DateTime `json:"starredAt"`
}

// Things that can be starred.
type Starrable struct {
	// The Node ID of the Starrable object
	Id string `json:"id"`
	// Returns a count of how many stargazers there are on this object
	StargazerCount int32 `json:"stargazerCount"`
	// A list of users who have starred this starrable.
	Stargazers *StargazerConnection `json:"stargazers"`
	// Returns a boolean indicating whether the viewing user has starred this starrable.
	ViewerHasStarred bool `json:"viewerHasStarred"`

	// Underlying value of the GraphQL interface
	Value StarrableValue `json:"-"`
}

func (base *Starrable) UnmarshalJSON(b []byte) error {
	type Raw Starrable
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Gist":
		base.Value = new(Gist)
	case "Repository":
		base.Value = new(Repository)
	case "Topic":
		base.Value = new(Topic)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface Starrable: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// StarrableValue is one of: Gist | Repository | Topic
type StarrableValue interface {
	isStarrable()
}

// The connection type for Repository.
type StarredRepositoryConnection struct {
	// A list of edges.
	Edges []*StarredRepositoryEdge `json:"edges,omitempty"`
	// Is the list of stars for this user truncated? This is true for users that have many stars.
	IsOverLimit bool `json:"isOverLimit"`
	// A list of nodes.
	Nodes []*Repository `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// Represents a starred repository.
type StarredRepositoryEdge struct {
	// A cursor for use in pagination.
	Cursor string      `json:"cursor"`
	Node   *Repository `json:"node"`
	// Identifies when the item was starred.
	StarredAt DateTime `json:"starredAt"`
}

// Autogenerated input type of StartOrganizationMigration
type StartOrganizationMigrationInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The migration source access token.
	SourceAccessToken string `json:"sourceAccessToken"`
	// The URL of the organization to migrate.
	SourceOrgUrl URI `json:"sourceOrgUrl"`
	// The ID of the enterprise the target organization belongs to.
	TargetEnterpriseId string `json:"targetEnterpriseId"`
	// The name of the target organization.
	TargetOrgName string `json:"targetOrgName"`
}

// Autogenerated return type of StartOrganizationMigration.
type StartOrganizationMigrationPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The new organization migration.
	OrgMigration *OrganizationMigration `json:"orgMigration,omitempty"`
}

// Autogenerated input type of StartRepositoryMigration
type StartRepositoryMigrationInput struct {
	// The migration source access token.
	AccessToken *string `json:"accessToken,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Whether to continue the migration on error. Defaults to `true`.
	ContinueOnError *bool `json:"continueOnError,omitempty"`
	// The signed URL to access the user-uploaded git archive.
	GitArchiveUrl *string `json:"gitArchiveUrl,omitempty"`
	// The GitHub personal access token of the user importing to the target repository.
	GithubPat *string `json:"githubPat,omitempty"`
	// Whether to lock the source repository.
	LockSource *bool `json:"lockSource,omitempty"`
	// The signed URL to access the user-uploaded metadata archive.
	MetadataArchiveUrl *string `json:"metadataArchiveUrl,omitempty"`
	// The ID of the organization that will own the imported repository.
	OwnerId string `json:"ownerId"`
	// The name of the imported repository.
	RepositoryName string `json:"repositoryName"`
	// Whether to skip migrating releases for the repository.
	SkipReleases *bool `json:"skipReleases,omitempty"`
	// The ID of the migration source.
	SourceId string `json:"sourceId"`
	// The URL of the source repository.
	SourceRepositoryUrl URI `json:"sourceRepositoryUrl"`
	// The visibility of the imported repository.
	TargetRepoVisibility *string `json:"targetRepoVisibility,omitempty"`
}

// Autogenerated return type of StartRepositoryMigration.
type StartRepositoryMigrationPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The new repository migration.
	RepositoryMigration *RepositoryMigration `json:"repositoryMigration,omitempty"`
}

// Represents a commit status.
type Status struct {
	// A list of status contexts and check runs for this commit.
	CombinedContexts *StatusCheckRollupContextConnection `json:"combinedContexts"`
	// The commit this status is attached to.
	Commit *Commit `json:"commit,omitempty"`
	// Looks up an individual status context by context name.
	Context *StatusContext `json:"context,omitempty"`
	// The individual status contexts for this commit.
	Contexts []StatusContext `json:"contexts"`
	// The Node ID of the Status object
	Id string `json:"id"`
	// The combined commit status.
	State StatusState `json:"state"`
}

func (*Status) isNode() {}

// Required status check
type StatusCheckConfiguration struct {
	// The status check context name that must be present on the commit.
	Context string `json:"context"`
	// The optional integration ID that this status check must originate from.
	IntegrationId *int32 `json:"integrationId,omitempty"`
}

// Required status check
type StatusCheckConfigurationInput struct {
	// The status check context name that must be present on the commit.
	Context string `json:"context"`
	// The optional integration ID that this status check must originate from.
	IntegrationId *int32 `json:"integrationId,omitempty"`
}

// Represents the rollup for both the check runs and status for a commit.
type StatusCheckRollup struct {
	// The commit the status and check runs are attached to.
	Commit *Commit `json:"commit,omitempty"`
	// A list of status contexts and check runs for this commit.
	Contexts *StatusCheckRollupContextConnection `json:"contexts"`
	// The Node ID of the StatusCheckRollup object
	Id string `json:"id"`
	// The combined status for the commit.
	State StatusState `json:"state"`
}

func (*StatusCheckRollup) isNode() {}

// Types that can be inside a StatusCheckRollup context.
type StatusCheckRollupContext struct {
	// Underlying value of the GraphQL union
	Value StatusCheckRollupContextValue `json:"-"`
}

func (base *StatusCheckRollupContext) UnmarshalJSON(b []byte) error {
	type Raw StatusCheckRollupContext
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "CheckRun":
		base.Value = new(CheckRun)
	case "StatusContext":
		base.Value = new(StatusContext)
	case "":
		return fmt.Errorf("gqlclient: union StatusCheckRollupContext: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union StatusCheckRollupContext: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// StatusCheckRollupContextValue is one of: CheckRun | StatusContext
type StatusCheckRollupContextValue interface {
	isStatusCheckRollupContext()
}

// The connection type for StatusCheckRollupContext.
type StatusCheckRollupContextConnection struct {
	// The number of check runs in this rollup.
	CheckRunCount int32 `json:"checkRunCount"`
	// Counts of check runs by state.
	CheckRunCountsByState []CheckRunStateCount `json:"checkRunCountsByState,omitempty"`
	// A list of edges.
	Edges []*StatusCheckRollupContextEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*StatusCheckRollupContext `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// The number of status contexts in this rollup.
	StatusContextCount int32 `json:"statusContextCount"`
	// Counts of status contexts by state.
	StatusContextCountsByState []StatusContextStateCount `json:"statusContextCountsByState,omitempty"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type StatusCheckRollupContextEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *StatusCheckRollupContext `json:"node,omitempty"`
}

// Represents an individual commit status context
type StatusContext struct {
	// The avatar of the OAuth application or the user that created the status
	AvatarUrl *URI `json:"avatarUrl,omitempty"`
	// This commit this status context is attached to.
	Commit *Commit `json:"commit,omitempty"`
	// The name of this status context.
	Context string `json:"context"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The actor who created this status context.
	Creator *Actor `json:"creator,omitempty"`
	// The description for this status context.
	Description *string `json:"description,omitempty"`
	// The Node ID of the StatusContext object
	Id string `json:"id"`
	// Whether this is required to pass before merging for a specific pull request.
	IsRequired bool `json:"isRequired"`
	// The state of this status context.
	State StatusState `json:"state"`
	// The URL for this status context.
	TargetUrl *URI `json:"targetUrl,omitempty"`
}

func (*StatusContext) isStatusCheckRollupContext() {}

func (*StatusContext) isNode() {}

func (*StatusContext) isRequirableByPullRequest() {}

// Represents a count of the state of a status context.
type StatusContextStateCount struct {
	// The number of statuses with this state.
	Count int32 `json:"count"`
	// The state of a status context.
	State StatusState `json:"state"`
}

// The possible commit status states.
type StatusState string

const (
	// Status is errored.
	StatusStateError StatusState = "ERROR"
	// Status is expected.
	StatusStateExpected StatusState = "EXPECTED"
	// Status is failing.
	StatusStateFailure StatusState = "FAILURE"
	// Status is pending.
	StatusStatePending StatusState = "PENDING"
	// Status is successful.
	StatusStateSuccess StatusState = "SUCCESS"
)

// A Stripe Connect account for receiving sponsorship funds from GitHub Sponsors.
type StripeConnectAccount struct {
	// The account number used to identify this Stripe Connect account.
	AccountId string `json:"accountId"`
	// The name of the country or region of an external account, such as a bank
	// account, tied to the Stripe Connect account. Will only return a value when
	// queried by the maintainer of the associated GitHub Sponsors profile
	// themselves, or by an admin of the sponsorable organization.
	BillingCountryOrRegion *string `json:"billingCountryOrRegion,omitempty"`
	// The name of the country or region of the Stripe Connect account. Will only
	// return a value when queried by the maintainer of the associated GitHub
	// Sponsors profile themselves, or by an admin of the sponsorable organization.
	CountryOrRegion *string `json:"countryOrRegion,omitempty"`
	// Whether this Stripe Connect account is currently in use for the associated GitHub Sponsors profile.
	IsActive bool `json:"isActive"`
	// The GitHub Sponsors profile associated with this Stripe Connect account.
	SponsorsListing *SponsorsListing `json:"sponsorsListing"`
	// The URL to access this Stripe Connect account on Stripe's website.
	StripeDashboardUrl URI `json:"stripeDashboardUrl"`
}

// Represents a 'sub_issue_added' event on a given issue.
type SubIssueAddedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the SubIssueAddedEvent object
	Id string `json:"id"`
	// The sub-issue added.
	SubIssue *Issue `json:"subIssue,omitempty"`
}

func (*SubIssueAddedEvent) isIssueTimelineItems() {}

func (*SubIssueAddedEvent) isPullRequestTimelineItems() {}

func (*SubIssueAddedEvent) isNode() {}

// Represents a 'sub_issue_removed' event on a given issue.
type SubIssueRemovedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the SubIssueRemovedEvent object
	Id string `json:"id"`
	// The sub-issue removed.
	SubIssue *Issue `json:"subIssue,omitempty"`
}

func (*SubIssueRemovedEvent) isIssueTimelineItems() {}

func (*SubIssueRemovedEvent) isPullRequestTimelineItems() {}

func (*SubIssueRemovedEvent) isNode() {}

// Summary of the state of an issue's sub-issues
type SubIssuesSummary struct {
	// Count of completed sub-issues
	Completed int32 `json:"completed"`
	// Percent of sub-issues which are completed
	PercentCompleted int32 `json:"percentCompleted"`
	// Count of total number of sub-issues
	Total int32 `json:"total"`
}

// Autogenerated input type of SubmitPullRequestReview
type SubmitPullRequestReviewInput struct {
	// The text field to set on the Pull Request Review.
	Body *string `json:"body,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The event to send to the Pull Request Review.
	Event PullRequestReviewEvent `json:"event"`
	// The Pull Request ID to submit any pending reviews.
	PullRequestId string `json:"pullRequestId,omitempty"`
	// The Pull Request Review ID to submit.
	PullRequestReviewId string `json:"pullRequestReviewId,omitempty"`
}

// Autogenerated return type of SubmitPullRequestReview.
type SubmitPullRequestReviewPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The submitted pull request review.
	PullRequestReview *PullRequestReview `json:"pullRequestReview,omitempty"`
}

// A pointer to a repository at a specific revision embedded inside another repository.
type Submodule struct {
	// The branch of the upstream submodule for tracking updates
	Branch *string `json:"branch,omitempty"`
	// The git URL of the submodule repository
	GitUrl URI `json:"gitUrl"`
	// The name of the submodule in .gitmodules
	Name string `json:"name"`
	// The name of the submodule in .gitmodules (Base64-encoded)
	NameRaw Base64String `json:"nameRaw"`
	// The path in the superproject that this submodule is located in
	Path string `json:"path"`
	// The path in the superproject that this submodule is located in (Base64-encoded)
	PathRaw Base64String `json:"pathRaw"`
	// The commit revision of the subproject repository being tracked by the submodule
	SubprojectCommitOid *GitObjectID `json:"subprojectCommitOid,omitempty"`
}

// The connection type for Submodule.
type SubmoduleConnection struct {
	// A list of edges.
	Edges []*SubmoduleEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*Submodule `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type SubmoduleEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *Submodule `json:"node,omitempty"`
}

// Entities that can be subscribed to for web and email notifications.
type Subscribable struct {
	// The Node ID of the Subscribable object
	Id string `json:"id"`
	// Check if the viewer is able to change their subscription status for the repository.
	ViewerCanSubscribe bool `json:"viewerCanSubscribe"`
	// Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
	ViewerSubscription *SubscriptionState `json:"viewerSubscription,omitempty"`

	// Underlying value of the GraphQL interface
	Value SubscribableValue `json:"-"`
}

func (base *Subscribable) UnmarshalJSON(b []byte) error {
	type Raw Subscribable
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Commit":
		base.Value = new(Commit)
	case "Discussion":
		base.Value = new(Discussion)
	case "Issue":
		base.Value = new(Issue)
	case "PullRequest":
		base.Value = new(PullRequest)
	case "Repository":
		base.Value = new(Repository)
	case "Team":
		base.Value = new(Team)
	case "TeamDiscussion":
		base.Value = new(TeamDiscussion)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface Subscribable: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// SubscribableValue is one of: Commit | Discussion | Issue | PullRequest | Repository | Team | TeamDiscussion
type SubscribableValue interface {
	isSubscribable()
}

// Entities that can be subscribed to for web and email notifications.
type SubscribableThread struct {
	// The Node ID of the SubscribableThread object
	Id string `json:"id"`
	// Identifies the viewer's thread subscription form action.
	ViewerThreadSubscriptionFormAction *ThreadSubscriptionFormAction `json:"viewerThreadSubscriptionFormAction,omitempty"`
	// Identifies the viewer's thread subscription status.
	ViewerThreadSubscriptionStatus *ThreadSubscriptionState `json:"viewerThreadSubscriptionStatus,omitempty"`

	// Underlying value of the GraphQL interface
	Value SubscribableThreadValue `json:"-"`
}

func (base *SubscribableThread) UnmarshalJSON(b []byte) error {
	type Raw SubscribableThread
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Issue":
		base.Value = new(Issue)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface SubscribableThread: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// SubscribableThreadValue is one of: Issue
type SubscribableThreadValue interface {
	isSubscribableThread()
}

// Represents a 'subscribed' event on a given `Subscribable`.
type SubscribedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the SubscribedEvent object
	Id string `json:"id"`
	// Object referenced by event.
	Subscribable *Subscribable `json:"subscribable"`
}

func (*SubscribedEvent) isIssueTimelineItem() {}

func (*SubscribedEvent) isIssueTimelineItems() {}

func (*SubscribedEvent) isPullRequestTimelineItem() {}

func (*SubscribedEvent) isPullRequestTimelineItems() {}

func (*SubscribedEvent) isNode() {}

// The possible states of a subscription.
type SubscriptionState string

const (
	// The User is never notified.
	SubscriptionStateIgnored SubscriptionState = "IGNORED"
	// The User is notified of all conversations.
	SubscriptionStateSubscribed SubscriptionState = "SUBSCRIBED"
	// The User is only notified when participating or @mentioned.
	SubscriptionStateUnsubscribed SubscriptionState = "UNSUBSCRIBED"
)

// A suggestion to review a pull request based on a user's commit history and review comments.
type SuggestedReviewer struct {
	// Is this suggestion based on past commits?
	IsAuthor bool `json:"isAuthor"`
	// Is this suggestion based on past review comments?
	IsCommenter bool `json:"isCommenter"`
	// Identifies the user suggested to review the pull request.
	Reviewer *User `json:"reviewer"`
}

// Represents a Git tag.
type Tag struct {
	// An abbreviated version of the Git object ID
	AbbreviatedOid string `json:"abbreviatedOid"`
	// The HTTP path for this Git object
	CommitResourcePath URI `json:"commitResourcePath"`
	// The HTTP URL for this Git object
	CommitUrl URI `json:"commitUrl"`
	// The Node ID of the Tag object
	Id string `json:"id"`
	// The Git tag message.
	Message *string `json:"message,omitempty"`
	// The Git tag name.
	Name string `json:"name"`
	// The Git object ID
	Oid GitObjectID `json:"oid"`
	// The Repository the Git object belongs to
	Repository *Repository `json:"repository"`
	// Details about the tag author.
	Tagger *GitActor `json:"tagger,omitempty"`
	// The Git object the tag points to.
	Target *GitObject `json:"target"`
}

func (*Tag) isGitObject() {}

func (*Tag) isNode() {}

// Parameters to be used for the tag_name_pattern rule
type TagNamePatternParameters struct {
	// How this rule will appear to users.
	Name *string `json:"name,omitempty"`
	// If true, the rule will fail if the pattern matches.
	Negate bool `json:"negate"`
	// The operator to use for matching.
	Operator string `json:"operator"`
	// The pattern to match with.
	Pattern string `json:"pattern"`
}

func (*TagNamePatternParameters) isRuleParameters() {}

// Parameters to be used for the tag_name_pattern rule
type TagNamePatternParametersInput struct {
	// How this rule will appear to users.
	Name *string `json:"name,omitempty"`
	// If true, the rule will fail if the pattern matches.
	Negate *bool `json:"negate,omitempty"`
	// The operator to use for matching.
	Operator string `json:"operator"`
	// The pattern to match with.
	Pattern string `json:"pattern"`
}

// A team of users in an organization.
type Team struct {
	// A list of teams that are ancestors of this team.
	Ancestors *TeamConnection `json:"ancestors"`
	// A URL pointing to the team's avatar.
	AvatarUrl *URI `json:"avatarUrl,omitempty"`
	// List of child teams belonging to this team
	ChildTeams *TeamConnection `json:"childTeams"`
	// The slug corresponding to the organization and team.
	CombinedSlug string `json:"combinedSlug"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The description of the team.
	Description *string `json:"description,omitempty"`
	// Find a team discussion by its number.
	Discussion *TeamDiscussion `json:"discussion,omitempty"`
	// A list of team discussions.
	Discussions *TeamDiscussionConnection `json:"discussions"`
	// The HTTP path for team discussions
	DiscussionsResourcePath URI `json:"discussionsResourcePath"`
	// The HTTP URL for team discussions
	DiscussionsUrl URI `json:"discussionsUrl"`
	// The HTTP path for editing this team
	EditTeamResourcePath URI `json:"editTeamResourcePath"`
	// The HTTP URL for editing this team
	EditTeamUrl URI `json:"editTeamUrl"`
	// The Node ID of the Team object
	Id string `json:"id"`
	// A list of pending invitations for users to this team
	Invitations *OrganizationInvitationConnection `json:"invitations,omitempty"`
	// Get the status messages members of this entity have set that are either public or visible only to the organization.
	MemberStatuses *UserStatusConnection `json:"memberStatuses"`
	// A list of users who are members of this team.
	Members *TeamMemberConnection `json:"members"`
	// The HTTP path for the team' members
	MembersResourcePath URI `json:"membersResourcePath"`
	// The HTTP URL for the team' members
	MembersUrl URI `json:"membersUrl"`
	// The name of the team.
	Name string `json:"name"`
	// The HTTP path creating a new team
	NewTeamResourcePath URI `json:"newTeamResourcePath"`
	// The HTTP URL creating a new team
	NewTeamUrl URI `json:"newTeamUrl"`
	// The notification setting that the team has set.
	NotificationSetting TeamNotificationSetting `json:"notificationSetting"`
	// The organization that owns this team.
	Organization *Organization `json:"organization"`
	// The parent team of the team.
	ParentTeam *Team `json:"parentTeam,omitempty"`
	// The level of privacy the team has.
	Privacy TeamPrivacy `json:"privacy"`
	// Finds and returns the project according to the provided project number.
	ProjectV2 *ProjectV2 `json:"projectV2,omitempty"`
	// List of projects this team has collaborator access to.
	ProjectsV2 *ProjectV2Connection `json:"projectsV2"`
	// A list of repositories this team has access to.
	Repositories *TeamRepositoryConnection `json:"repositories"`
	// The HTTP path for this team's repositories
	RepositoriesResourcePath URI `json:"repositoriesResourcePath"`
	// The HTTP URL for this team's repositories
	RepositoriesUrl URI `json:"repositoriesUrl"`
	// The HTTP path for this team
	ResourcePath URI `json:"resourcePath"`
	// What algorithm is used for review assignment for this team
	ReviewRequestDelegationAlgorithm *TeamReviewAssignmentAlgorithm `json:"reviewRequestDelegationAlgorithm,omitempty"`
	// True if review assignment is enabled for this team
	ReviewRequestDelegationEnabled bool `json:"reviewRequestDelegationEnabled"`
	// How many team members are required for review assignment for this team
	ReviewRequestDelegationMemberCount *int32 `json:"reviewRequestDelegationMemberCount,omitempty"`
	// When assigning team members via delegation, whether the entire team should be notified as well.
	ReviewRequestDelegationNotifyTeam bool `json:"reviewRequestDelegationNotifyTeam"`
	// The slug corresponding to the team.
	Slug string `json:"slug"`
	// The HTTP path for this team's teams
	TeamsResourcePath URI `json:"teamsResourcePath"`
	// The HTTP URL for this team's teams
	TeamsUrl URI `json:"teamsUrl"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The HTTP URL for this team
	Url URI `json:"url"`
	// Team is adminable by the viewer.
	ViewerCanAdminister bool `json:"viewerCanAdminister"`
	// Check if the viewer is able to change their subscription status for the repository.
	ViewerCanSubscribe bool `json:"viewerCanSubscribe"`
	// Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
	ViewerSubscription *SubscriptionState `json:"viewerSubscription,omitempty"`
}

func (*Team) isBranchActorAllowanceActor() {}

func (*Team) isBypassActor() {}

func (*Team) isDeploymentReviewer() {}

func (*Team) isPermissionGranter() {}

func (*Team) isProjectV2Actor() {}

func (*Team) isPushAllowanceActor() {}

func (*Team) isRequestedReviewer() {}

func (*Team) isReviewDismissalAllowanceActor() {}

func (*Team) isMemberStatusable() {}

func (*Team) isNode() {}

func (*Team) isSubscribable() {}

// Audit log entry for a team.add_member event.
type TeamAddMemberAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the TeamAddMemberAuditEntry object
	Id string `json:"id"`
	// Whether the team was mapped to an LDAP Group.
	IsLdapMapped *bool `json:"isLdapMapped,omitempty"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The team associated with the action
	Team *Team `json:"team,omitempty"`
	// The name of the team
	TeamName *string `json:"teamName,omitempty"`
	// The HTTP path for this team
	TeamResourcePath *URI `json:"teamResourcePath,omitempty"`
	// The HTTP URL for this team
	TeamUrl *URI `json:"teamUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*TeamAddMemberAuditEntry) isOrganizationAuditEntry() {}

func (*TeamAddMemberAuditEntry) isAuditEntry() {}

func (*TeamAddMemberAuditEntry) isNode() {}

func (*TeamAddMemberAuditEntry) isOrganizationAuditEntryData() {}

func (*TeamAddMemberAuditEntry) isTeamAuditEntryData() {}

// Audit log entry for a team.add_repository event.
type TeamAddRepositoryAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the TeamAddRepositoryAuditEntry object
	Id string `json:"id"`
	// Whether the team was mapped to an LDAP Group.
	IsLdapMapped *bool `json:"isLdapMapped,omitempty"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The repository associated with the action
	Repository *Repository `json:"repository,omitempty"`
	// The name of the repository
	RepositoryName *string `json:"repositoryName,omitempty"`
	// The HTTP path for the repository
	RepositoryResourcePath *URI `json:"repositoryResourcePath,omitempty"`
	// The HTTP URL for the repository
	RepositoryUrl *URI `json:"repositoryUrl,omitempty"`
	// The team associated with the action
	Team *Team `json:"team,omitempty"`
	// The name of the team
	TeamName *string `json:"teamName,omitempty"`
	// The HTTP path for this team
	TeamResourcePath *URI `json:"teamResourcePath,omitempty"`
	// The HTTP URL for this team
	TeamUrl *URI `json:"teamUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*TeamAddRepositoryAuditEntry) isOrganizationAuditEntry() {}

func (*TeamAddRepositoryAuditEntry) isAuditEntry() {}

func (*TeamAddRepositoryAuditEntry) isNode() {}

func (*TeamAddRepositoryAuditEntry) isOrganizationAuditEntryData() {}

func (*TeamAddRepositoryAuditEntry) isRepositoryAuditEntryData() {}

func (*TeamAddRepositoryAuditEntry) isTeamAuditEntryData() {}

// Metadata for an audit entry with action team.*
type TeamAuditEntryData struct {
	// The team associated with the action
	Team *Team `json:"team,omitempty"`
	// The name of the team
	TeamName *string `json:"teamName,omitempty"`
	// The HTTP path for this team
	TeamResourcePath *URI `json:"teamResourcePath,omitempty"`
	// The HTTP URL for this team
	TeamUrl *URI `json:"teamUrl,omitempty"`

	// Underlying value of the GraphQL interface
	Value TeamAuditEntryDataValue `json:"-"`
}

func (base *TeamAuditEntryData) UnmarshalJSON(b []byte) error {
	type Raw TeamAuditEntryData
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "OrgRestoreMemberMembershipTeamAuditEntryData":
		base.Value = new(OrgRestoreMemberMembershipTeamAuditEntryData)
	case "TeamAddMemberAuditEntry":
		base.Value = new(TeamAddMemberAuditEntry)
	case "TeamAddRepositoryAuditEntry":
		base.Value = new(TeamAddRepositoryAuditEntry)
	case "TeamChangeParentTeamAuditEntry":
		base.Value = new(TeamChangeParentTeamAuditEntry)
	case "TeamRemoveMemberAuditEntry":
		base.Value = new(TeamRemoveMemberAuditEntry)
	case "TeamRemoveRepositoryAuditEntry":
		base.Value = new(TeamRemoveRepositoryAuditEntry)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface TeamAuditEntryData: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// TeamAuditEntryDataValue is one of: OrgRestoreMemberMembershipTeamAuditEntryData | TeamAddMemberAuditEntry | TeamAddRepositoryAuditEntry | TeamChangeParentTeamAuditEntry | TeamRemoveMemberAuditEntry | TeamRemoveRepositoryAuditEntry
type TeamAuditEntryDataValue interface {
	isTeamAuditEntryData()
}

// Audit log entry for a team.change_parent_team event.
type TeamChangeParentTeamAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the TeamChangeParentTeamAuditEntry object
	Id string `json:"id"`
	// Whether the team was mapped to an LDAP Group.
	IsLdapMapped *bool `json:"isLdapMapped,omitempty"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The new parent team.
	ParentTeam *Team `json:"parentTeam,omitempty"`
	// The name of the new parent team
	ParentTeamName *string `json:"parentTeamName,omitempty"`
	// The name of the former parent team
	ParentTeamNameWas *string `json:"parentTeamNameWas,omitempty"`
	// The HTTP path for the parent team
	ParentTeamResourcePath *URI `json:"parentTeamResourcePath,omitempty"`
	// The HTTP URL for the parent team
	ParentTeamUrl *URI `json:"parentTeamUrl,omitempty"`
	// The former parent team.
	ParentTeamWas *Team `json:"parentTeamWas,omitempty"`
	// The HTTP path for the previous parent team
	ParentTeamWasResourcePath *URI `json:"parentTeamWasResourcePath,omitempty"`
	// The HTTP URL for the previous parent team
	ParentTeamWasUrl *URI `json:"parentTeamWasUrl,omitempty"`
	// The team associated with the action
	Team *Team `json:"team,omitempty"`
	// The name of the team
	TeamName *string `json:"teamName,omitempty"`
	// The HTTP path for this team
	TeamResourcePath *URI `json:"teamResourcePath,omitempty"`
	// The HTTP URL for this team
	TeamUrl *URI `json:"teamUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*TeamChangeParentTeamAuditEntry) isOrganizationAuditEntry() {}

func (*TeamChangeParentTeamAuditEntry) isAuditEntry() {}

func (*TeamChangeParentTeamAuditEntry) isNode() {}

func (*TeamChangeParentTeamAuditEntry) isOrganizationAuditEntryData() {}

func (*TeamChangeParentTeamAuditEntry) isTeamAuditEntryData() {}

// The connection type for Team.
type TeamConnection struct {
	// A list of edges.
	Edges []*TeamEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*Team `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// A team discussion.
type TeamDiscussion struct {
	// The actor who authored the comment.
	Author *Actor `json:"author,omitempty"`
	// Author's association with the discussion's team.
	AuthorAssociation CommentAuthorAssociation `json:"authorAssociation"`
	// The body as Markdown.
	Body string `json:"body"`
	// The body rendered to HTML.
	BodyHTML HTML `json:"bodyHTML"`
	// The body rendered to text.
	BodyText string `json:"bodyText"`
	// Identifies the discussion body hash.
	BodyVersion string `json:"bodyVersion"`
	// A list of comments on this discussion.
	Comments *TeamDiscussionCommentConnection `json:"comments"`
	// The HTTP path for discussion comments
	CommentsResourcePath URI `json:"commentsResourcePath"`
	// The HTTP URL for discussion comments
	CommentsUrl URI `json:"commentsUrl"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Check if this comment was created via an email reply.
	CreatedViaEmail bool `json:"createdViaEmail"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The actor who edited the comment.
	Editor *Actor `json:"editor,omitempty"`
	// The Node ID of the TeamDiscussion object
	Id string `json:"id"`
	// Check if this comment was edited and includes an edit with the creation data
	IncludesCreatedEdit bool `json:"includesCreatedEdit"`
	// Whether or not the discussion is pinned.
	IsPinned bool `json:"isPinned"`
	// Whether or not the discussion is only visible to team members and organization owners.
	IsPrivate bool `json:"isPrivate"`
	// The moment the editor made the last edit
	LastEditedAt *DateTime `json:"lastEditedAt,omitempty"`
	// Identifies the discussion within its team.
	Number int32 `json:"number"`
	// Identifies when the comment was published at.
	PublishedAt *DateTime `json:"publishedAt,omitempty"`
	// A list of reactions grouped by content left on the subject.
	ReactionGroups []ReactionGroup `json:"reactionGroups,omitempty"`
	// A list of Reactions left on the Issue.
	Reactions *ReactionConnection `json:"reactions"`
	// The HTTP path for this discussion
	ResourcePath URI `json:"resourcePath"`
	// The team that defines the context of this discussion.
	Team *Team `json:"team"`
	// The title of the discussion
	Title string `json:"title"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The HTTP URL for this discussion
	Url URI `json:"url"`
	// A list of edits to this content.
	UserContentEdits *UserContentEditConnection `json:"userContentEdits,omitempty"`
	// Check if the current viewer can delete this object.
	ViewerCanDelete bool `json:"viewerCanDelete"`
	// Whether or not the current viewer can pin this discussion.
	ViewerCanPin bool `json:"viewerCanPin"`
	// Can user react to this subject
	ViewerCanReact bool `json:"viewerCanReact"`
	// Check if the viewer is able to change their subscription status for the repository.
	ViewerCanSubscribe bool `json:"viewerCanSubscribe"`
	// Check if the current viewer can update this object.
	ViewerCanUpdate bool `json:"viewerCanUpdate"`
	// Reasons why the current viewer can not update this comment.
	ViewerCannotUpdateReasons []CommentCannotUpdateReason `json:"viewerCannotUpdateReasons"`
	// Did the viewer author this comment.
	ViewerDidAuthor bool `json:"viewerDidAuthor"`
	// Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
	ViewerSubscription *SubscriptionState `json:"viewerSubscription,omitempty"`
}

func (*TeamDiscussion) isComment() {}

func (*TeamDiscussion) isDeletable() {}

func (*TeamDiscussion) isNode() {}

func (*TeamDiscussion) isReactable() {}

func (*TeamDiscussion) isSubscribable() {}

func (*TeamDiscussion) isUniformResourceLocatable() {}

func (*TeamDiscussion) isUpdatable() {}

func (*TeamDiscussion) isUpdatableComment() {}

// A comment on a team discussion.
type TeamDiscussionComment struct {
	// The actor who authored the comment.
	Author *Actor `json:"author,omitempty"`
	// Author's association with the comment's team.
	AuthorAssociation CommentAuthorAssociation `json:"authorAssociation"`
	// The body as Markdown.
	Body string `json:"body"`
	// The body rendered to HTML.
	BodyHTML HTML `json:"bodyHTML"`
	// The body rendered to text.
	BodyText string `json:"bodyText"`
	// The current version of the body content.
	BodyVersion string `json:"bodyVersion"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Check if this comment was created via an email reply.
	CreatedViaEmail bool `json:"createdViaEmail"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The discussion this comment is about.
	Discussion *TeamDiscussion `json:"discussion"`
	// The actor who edited the comment.
	Editor *Actor `json:"editor,omitempty"`
	// The Node ID of the TeamDiscussionComment object
	Id string `json:"id"`
	// Check if this comment was edited and includes an edit with the creation data
	IncludesCreatedEdit bool `json:"includesCreatedEdit"`
	// The moment the editor made the last edit
	LastEditedAt *DateTime `json:"lastEditedAt,omitempty"`
	// Identifies the comment number.
	Number int32 `json:"number"`
	// Identifies when the comment was published at.
	PublishedAt *DateTime `json:"publishedAt,omitempty"`
	// A list of reactions grouped by content left on the subject.
	ReactionGroups []ReactionGroup `json:"reactionGroups,omitempty"`
	// A list of Reactions left on the Issue.
	Reactions *ReactionConnection `json:"reactions"`
	// The HTTP path for this comment
	ResourcePath URI `json:"resourcePath"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The HTTP URL for this comment
	Url URI `json:"url"`
	// A list of edits to this content.
	UserContentEdits *UserContentEditConnection `json:"userContentEdits,omitempty"`
	// Check if the current viewer can delete this object.
	ViewerCanDelete bool `json:"viewerCanDelete"`
	// Can user react to this subject
	ViewerCanReact bool `json:"viewerCanReact"`
	// Check if the current viewer can update this object.
	ViewerCanUpdate bool `json:"viewerCanUpdate"`
	// Reasons why the current viewer can not update this comment.
	ViewerCannotUpdateReasons []CommentCannotUpdateReason `json:"viewerCannotUpdateReasons"`
	// Did the viewer author this comment.
	ViewerDidAuthor bool `json:"viewerDidAuthor"`
}

func (*TeamDiscussionComment) isComment() {}

func (*TeamDiscussionComment) isDeletable() {}

func (*TeamDiscussionComment) isNode() {}

func (*TeamDiscussionComment) isReactable() {}

func (*TeamDiscussionComment) isUniformResourceLocatable() {}

func (*TeamDiscussionComment) isUpdatable() {}

func (*TeamDiscussionComment) isUpdatableComment() {}

// The connection type for TeamDiscussionComment.
type TeamDiscussionCommentConnection struct {
	// A list of edges.
	Edges []*TeamDiscussionCommentEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*TeamDiscussionComment `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type TeamDiscussionCommentEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *TeamDiscussionComment `json:"node,omitempty"`
}

// Ways in which team discussion comment connections can be ordered.
type TeamDiscussionCommentOrder struct {
	// The direction in which to order nodes.
	Direction OrderDirection `json:"direction"`
	// The field by which to order nodes.
	Field TeamDiscussionCommentOrderField `json:"field"`
}

// Properties by which team discussion comment connections can be ordered.
type TeamDiscussionCommentOrderField string

const (
	// Allows sequential ordering of team discussion comments (which is equivalent to chronological ordering).
	TeamDiscussionCommentOrderFieldNumber TeamDiscussionCommentOrderField = "NUMBER"
)

// The connection type for TeamDiscussion.
type TeamDiscussionConnection struct {
	// A list of edges.
	Edges []*TeamDiscussionEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*TeamDiscussion `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type TeamDiscussionEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *TeamDiscussion `json:"node,omitempty"`
}

// Ways in which team discussion connections can be ordered.
type TeamDiscussionOrder struct {
	// The direction in which to order nodes.
	Direction OrderDirection `json:"direction"`
	// The field by which to order nodes.
	Field TeamDiscussionOrderField `json:"field"`
}

// Properties by which team discussion connections can be ordered.
type TeamDiscussionOrderField string

const (
	// Allows chronological ordering of team discussions.
	TeamDiscussionOrderFieldCreatedAt TeamDiscussionOrderField = "CREATED_AT"
)

// An edge in a connection.
type TeamEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *Team `json:"node,omitempty"`
}

// The connection type for User.
type TeamMemberConnection struct {
	// A list of edges.
	Edges []*TeamMemberEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*User `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// Represents a user who is a member of a team.
type TeamMemberEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The HTTP path to the organization's member access page.
	MemberAccessResourcePath URI `json:"memberAccessResourcePath"`
	// The HTTP URL to the organization's member access page.
	MemberAccessUrl URI   `json:"memberAccessUrl"`
	Node            *User `json:"node"`
	// The role the member has on the team.
	Role TeamMemberRole `json:"role"`
}

// Ordering options for team member connections
type TeamMemberOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order team members by.
	Field TeamMemberOrderField `json:"field"`
}

// Properties by which team member connections can be ordered.
type TeamMemberOrderField string

const (
	// Order team members by creation time
	TeamMemberOrderFieldCreatedAt TeamMemberOrderField = "CREATED_AT"
	// Order team members by login
	TeamMemberOrderFieldLogin TeamMemberOrderField = "LOGIN"
)

// The possible team member roles; either 'maintainer' or 'member'.
type TeamMemberRole string

const (
	// A team maintainer has permission to add and remove team members.
	TeamMemberRoleMaintainer TeamMemberRole = "MAINTAINER"
	// A team member has no administrative permissions on the team.
	TeamMemberRoleMember TeamMemberRole = "MEMBER"
)

// Defines which types of team members are included in the returned list. Can be one of IMMEDIATE, CHILD_TEAM or ALL.
type TeamMembershipType string

const (
	// Includes immediate and child team members for the team.
	TeamMembershipTypeAll TeamMembershipType = "ALL"
	// Includes only child team members for the team.
	TeamMembershipTypeChildTeam TeamMembershipType = "CHILD_TEAM"
	// Includes only immediate members of the team.
	TeamMembershipTypeImmediate TeamMembershipType = "IMMEDIATE"
)

// The possible team notification values.
type TeamNotificationSetting string

const (
	// No one will receive notifications.
	TeamNotificationSettingNotificationsDisabled TeamNotificationSetting = "NOTIFICATIONS_DISABLED"
	// Everyone will receive notifications when the team is @mentioned.
	TeamNotificationSettingNotificationsEnabled TeamNotificationSetting = "NOTIFICATIONS_ENABLED"
)

// Ways in which team connections can be ordered.
type TeamOrder struct {
	// The direction in which to order nodes.
	Direction OrderDirection `json:"direction"`
	// The field in which to order nodes by.
	Field TeamOrderField `json:"field"`
}

// Properties by which team connections can be ordered.
type TeamOrderField string

const (
	// Allows ordering a list of teams by name.
	TeamOrderFieldName TeamOrderField = "NAME"
)

// The possible team privacy values.
type TeamPrivacy string

const (
	// A secret team can only be seen by its members.
	TeamPrivacySecret TeamPrivacy = "SECRET"
	// A visible team can be seen and @mentioned by every member of the organization.
	TeamPrivacyVisible TeamPrivacy = "VISIBLE"
)

// Audit log entry for a team.remove_member event.
type TeamRemoveMemberAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the TeamRemoveMemberAuditEntry object
	Id string `json:"id"`
	// Whether the team was mapped to an LDAP Group.
	IsLdapMapped *bool `json:"isLdapMapped,omitempty"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The team associated with the action
	Team *Team `json:"team,omitempty"`
	// The name of the team
	TeamName *string `json:"teamName,omitempty"`
	// The HTTP path for this team
	TeamResourcePath *URI `json:"teamResourcePath,omitempty"`
	// The HTTP URL for this team
	TeamUrl *URI `json:"teamUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*TeamRemoveMemberAuditEntry) isOrganizationAuditEntry() {}

func (*TeamRemoveMemberAuditEntry) isAuditEntry() {}

func (*TeamRemoveMemberAuditEntry) isNode() {}

func (*TeamRemoveMemberAuditEntry) isOrganizationAuditEntryData() {}

func (*TeamRemoveMemberAuditEntry) isTeamAuditEntryData() {}

// Audit log entry for a team.remove_repository event.
type TeamRemoveRepositoryAuditEntry struct {
	// The action name
	Action string `json:"action"`
	// The user who initiated the action
	Actor *AuditEntryActor `json:"actor,omitempty"`
	// The IP address of the actor
	ActorIp *string `json:"actorIp,omitempty"`
	// A readable representation of the actor's location
	ActorLocation *ActorLocation `json:"actorLocation,omitempty"`
	// The username of the user who initiated the action
	ActorLogin *string `json:"actorLogin,omitempty"`
	// The HTTP path for the actor.
	ActorResourcePath *URI `json:"actorResourcePath,omitempty"`
	// The HTTP URL for the actor.
	ActorUrl *URI `json:"actorUrl,omitempty"`
	// The time the action was initiated
	CreatedAt PreciseDateTime `json:"createdAt"`
	// The Node ID of the TeamRemoveRepositoryAuditEntry object
	Id string `json:"id"`
	// Whether the team was mapped to an LDAP Group.
	IsLdapMapped *bool `json:"isLdapMapped,omitempty"`
	// The corresponding operation type for the action
	OperationType *OperationType `json:"operationType,omitempty"`
	// The Organization associated with the Audit Entry.
	Organization *Organization `json:"organization,omitempty"`
	// The name of the Organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// The HTTP path for the organization
	OrganizationResourcePath *URI `json:"organizationResourcePath,omitempty"`
	// The HTTP URL for the organization
	OrganizationUrl *URI `json:"organizationUrl,omitempty"`
	// The repository associated with the action
	Repository *Repository `json:"repository,omitempty"`
	// The name of the repository
	RepositoryName *string `json:"repositoryName,omitempty"`
	// The HTTP path for the repository
	RepositoryResourcePath *URI `json:"repositoryResourcePath,omitempty"`
	// The HTTP URL for the repository
	RepositoryUrl *URI `json:"repositoryUrl,omitempty"`
	// The team associated with the action
	Team *Team `json:"team,omitempty"`
	// The name of the team
	TeamName *string `json:"teamName,omitempty"`
	// The HTTP path for this team
	TeamResourcePath *URI `json:"teamResourcePath,omitempty"`
	// The HTTP URL for this team
	TeamUrl *URI `json:"teamUrl,omitempty"`
	// The user affected by the action
	User *User `json:"user,omitempty"`
	// For actions involving two users, the actor is the initiator and the user is the affected user.
	UserLogin *string `json:"userLogin,omitempty"`
	// The HTTP path for the user.
	UserResourcePath *URI `json:"userResourcePath,omitempty"`
	// The HTTP URL for the user.
	UserUrl *URI `json:"userUrl,omitempty"`
}

func (*TeamRemoveRepositoryAuditEntry) isOrganizationAuditEntry() {}

func (*TeamRemoveRepositoryAuditEntry) isAuditEntry() {}

func (*TeamRemoveRepositoryAuditEntry) isNode() {}

func (*TeamRemoveRepositoryAuditEntry) isOrganizationAuditEntryData() {}

func (*TeamRemoveRepositoryAuditEntry) isRepositoryAuditEntryData() {}

func (*TeamRemoveRepositoryAuditEntry) isTeamAuditEntryData() {}

// The connection type for Repository.
type TeamRepositoryConnection struct {
	// A list of edges.
	Edges []*TeamRepositoryEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*Repository `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// Represents a team repository.
type TeamRepositoryEdge struct {
	// A cursor for use in pagination.
	Cursor string      `json:"cursor"`
	Node   *Repository `json:"node"`
	// The permission level the team has on the repository
	Permission RepositoryPermission `json:"permission"`
}

// Ordering options for team repository connections
type TeamRepositoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order repositories by.
	Field TeamRepositoryOrderField `json:"field"`
}

// Properties by which team repository connections can be ordered.
type TeamRepositoryOrderField string

const (
	// Order repositories by creation time
	TeamRepositoryOrderFieldCreatedAt TeamRepositoryOrderField = "CREATED_AT"
	// Order repositories by name
	TeamRepositoryOrderFieldName TeamRepositoryOrderField = "NAME"
	// Order repositories by permission
	TeamRepositoryOrderFieldPermission TeamRepositoryOrderField = "PERMISSION"
	// Order repositories by push time
	TeamRepositoryOrderFieldPushedAt TeamRepositoryOrderField = "PUSHED_AT"
	// Order repositories by number of stargazers
	TeamRepositoryOrderFieldStargazers TeamRepositoryOrderField = "STARGAZERS"
	// Order repositories by update time
	TeamRepositoryOrderFieldUpdatedAt TeamRepositoryOrderField = "UPDATED_AT"
)

// The possible team review assignment algorithms
type TeamReviewAssignmentAlgorithm string

const (
	// Balance review load across the entire team
	TeamReviewAssignmentAlgorithmLoadBalance TeamReviewAssignmentAlgorithm = "LOAD_BALANCE"
	// Alternate reviews between each team member
	TeamReviewAssignmentAlgorithmRoundRobin TeamReviewAssignmentAlgorithm = "ROUND_ROBIN"
)

// The role of a user on a team.
type TeamRole string

const (
	// User has admin rights on the team.
	TeamRoleAdmin TeamRole = "ADMIN"
	// User is a member of the team.
	TeamRoleMember TeamRole = "MEMBER"
)

// A text match within a search result.
type TextMatch struct {
	// The specific text fragment within the property matched on.
	Fragment string `json:"fragment"`
	// Highlights within the matched fragment.
	Highlights []TextMatchHighlight `json:"highlights"`
	// The property matched on.
	Property string `json:"property"`
}

// Represents a single highlight in a search result match.
type TextMatchHighlight struct {
	// The indice in the fragment where the matched text begins.
	BeginIndice int32 `json:"beginIndice"`
	// The indice in the fragment where the matched text ends.
	EndIndice int32 `json:"endIndice"`
	// The text matched.
	Text string `json:"text"`
}

// The possible states of a thread subscription form action
type ThreadSubscriptionFormAction string

const (
	// The User cannot subscribe or unsubscribe to the thread
	ThreadSubscriptionFormActionNone ThreadSubscriptionFormAction = "NONE"
	// The User can subscribe to the thread
	ThreadSubscriptionFormActionSubscribe ThreadSubscriptionFormAction = "SUBSCRIBE"
	// The User can unsubscribe to the thread
	ThreadSubscriptionFormActionUnsubscribe ThreadSubscriptionFormAction = "UNSUBSCRIBE"
)

// The possible states of a subscription.
type ThreadSubscriptionState string

const (
	// The subscription status is currently disabled.
	ThreadSubscriptionStateDisabled ThreadSubscriptionState = "DISABLED"
	// The User is never notified because they are ignoring the list
	ThreadSubscriptionStateIgnoringList ThreadSubscriptionState = "IGNORING_LIST"
	// The User is never notified because they are ignoring the thread
	ThreadSubscriptionStateIgnoringThread ThreadSubscriptionState = "IGNORING_THREAD"
	// The User is not recieving notifications from this thread
	ThreadSubscriptionStateNone ThreadSubscriptionState = "NONE"
	// The User is notified becuase they are watching the list
	ThreadSubscriptionStateSubscribedToList ThreadSubscriptionState = "SUBSCRIBED_TO_LIST"
	// The User is notified because they are subscribed to the thread
	ThreadSubscriptionStateSubscribedToThread ThreadSubscriptionState = "SUBSCRIBED_TO_THREAD"
	// The User is notified because they chose custom settings for this thread.
	ThreadSubscriptionStateSubscribedToThreadEvents ThreadSubscriptionState = "SUBSCRIBED_TO_THREAD_EVENTS"
	// The User is notified because they chose custom settings for this thread.
	ThreadSubscriptionStateSubscribedToThreadType ThreadSubscriptionState = "SUBSCRIBED_TO_THREAD_TYPE"
	// The subscription status is currently unavailable.
	ThreadSubscriptionStateUnavailable ThreadSubscriptionState = "UNAVAILABLE"
)

// A topic aggregates entities that are related to a subject.
type Topic struct {
	// The Node ID of the Topic object
	Id string `json:"id"`
	// The topic's name.
	Name string `json:"name"`
	// A list of related topics, including aliases of this topic, sorted with the most relevant
	// first. Returns up to 10 Topics.
	RelatedTopics []Topic `json:"relatedTopics"`
	// A list of repositories.
	Repositories *RepositoryConnection `json:"repositories"`
	// Returns a count of how many stargazers there are on this object
	StargazerCount int32 `json:"stargazerCount"`
	// A list of users who have starred this starrable.
	Stargazers *StargazerConnection `json:"stargazers"`
	// Returns a boolean indicating whether the viewing user has starred this starrable.
	ViewerHasStarred bool `json:"viewerHasStarred"`
}

func (*Topic) isNode() {}

func (*Topic) isStarrable() {}

// Metadata for an audit entry with a topic.
type TopicAuditEntryData struct {
	// The name of the topic added to the repository
	Topic *Topic `json:"topic,omitempty"`
	// The name of the topic added to the repository
	TopicName *string `json:"topicName,omitempty"`

	// Underlying value of the GraphQL interface
	Value TopicAuditEntryDataValue `json:"-"`
}

func (base *TopicAuditEntryData) UnmarshalJSON(b []byte) error {
	type Raw TopicAuditEntryData
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "RepoAddTopicAuditEntry":
		base.Value = new(RepoAddTopicAuditEntry)
	case "RepoRemoveTopicAuditEntry":
		base.Value = new(RepoRemoveTopicAuditEntry)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface TopicAuditEntryData: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// TopicAuditEntryDataValue is one of: RepoAddTopicAuditEntry | RepoRemoveTopicAuditEntry
type TopicAuditEntryDataValue interface {
	isTopicAuditEntryData()
}

// Reason that the suggested topic is declined.
type TopicSuggestionDeclineReason string

const (
	// The suggested topic is not relevant to the repository.
	TopicSuggestionDeclineReasonNotRelevant TopicSuggestionDeclineReason = "NOT_RELEVANT"
	// The viewer does not like the suggested topic.
	TopicSuggestionDeclineReasonPersonalPreference TopicSuggestionDeclineReason = "PERSONAL_PREFERENCE"
	// The suggested topic is too general for the repository.
	TopicSuggestionDeclineReasonTooGeneral TopicSuggestionDeclineReason = "TOO_GENERAL"
	// The suggested topic is too specific for the repository (e.g. #ruby-on-rails-version-4-2-1).
	TopicSuggestionDeclineReasonTooSpecific TopicSuggestionDeclineReason = "TOO_SPECIFIC"
)

// The possible states of a tracked issue.
type TrackedIssueStates string

const (
	// The tracked issue is closed
	TrackedIssueStatesClosed TrackedIssueStates = "CLOSED"
	// The tracked issue is open
	TrackedIssueStatesOpen TrackedIssueStates = "OPEN"
)

// Autogenerated input type of TransferEnterpriseOrganization
type TransferEnterpriseOrganizationInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the enterprise where the organization should be transferred.
	DestinationEnterpriseId string `json:"destinationEnterpriseId"`
	// The ID of the organization to transfer.
	OrganizationId string `json:"organizationId"`
}

// Autogenerated return type of TransferEnterpriseOrganization.
type TransferEnterpriseOrganizationPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The organization for which a transfer was initiated.
	Organization *Organization `json:"organization,omitempty"`
}

// Autogenerated input type of TransferIssue
type TransferIssueInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Whether to create labels if they don't exist in the target repository (matched by name)
	CreateLabelsIfMissing *bool `json:"createLabelsIfMissing,omitempty"`
	// The Node ID of the issue to be transferred
	IssueId string `json:"issueId"`
	// The Node ID of the repository the issue should be transferred to
	RepositoryId string `json:"repositoryId"`
}

// Autogenerated return type of TransferIssue.
type TransferIssuePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The issue that was transferred
	Issue *Issue `json:"issue,omitempty"`
}

// Represents a 'transferred' event on a given issue or pull request.
type TransferredEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The repository this came from
	FromRepository *Repository `json:"fromRepository,omitempty"`
	// The Node ID of the TransferredEvent object
	Id string `json:"id"`
	// Identifies the issue associated with the event.
	Issue *Issue `json:"issue"`
}

func (*TransferredEvent) isIssueTimelineItem() {}

func (*TransferredEvent) isIssueTimelineItems() {}

func (*TransferredEvent) isPullRequestTimelineItems() {}

func (*TransferredEvent) isNode() {}

// Represents a Git tree.
type Tree struct {
	// An abbreviated version of the Git object ID
	AbbreviatedOid string `json:"abbreviatedOid"`
	// The HTTP path for this Git object
	CommitResourcePath URI `json:"commitResourcePath"`
	// The HTTP URL for this Git object
	CommitUrl URI `json:"commitUrl"`
	// A list of tree entries.
	Entries []TreeEntry `json:"entries,omitempty"`
	// The Node ID of the Tree object
	Id string `json:"id"`
	// The Git object ID
	Oid GitObjectID `json:"oid"`
	// The Repository the Git object belongs to
	Repository *Repository `json:"repository"`
}

func (*Tree) isGitObject() {}

func (*Tree) isNode() {}

// Represents a Git tree entry.
type TreeEntry struct {
	// The extension of the file
	Extension *string `json:"extension,omitempty"`
	// Whether or not this tree entry is generated
	IsGenerated bool `json:"isGenerated"`
	// The programming language this file is written in.
	Language *Language `json:"language,omitempty"`
	// Number of lines in the file.
	LineCount *int32 `json:"lineCount,omitempty"`
	// Entry file mode.
	Mode int32 `json:"mode"`
	// Entry file name.
	Name string `json:"name"`
	// Entry file name. (Base64-encoded)
	NameRaw Base64String `json:"nameRaw"`
	// Entry file object.
	Object *GitObject `json:"object,omitempty"`
	// Entry file Git object ID.
	Oid GitObjectID `json:"oid"`
	// The full path of the file.
	Path *string `json:"path,omitempty"`
	// The full path of the file. (Base64-encoded)
	PathRaw *Base64String `json:"pathRaw,omitempty"`
	// The Repository the tree entry belongs to
	Repository *Repository `json:"repository"`
	// Entry byte size
	Size int32 `json:"size"`
	// If the TreeEntry is for a directory occupied by a submodule project, this returns the corresponding submodule
	Submodule *Submodule `json:"submodule,omitempty"`
	// Entry file type.
	Type string `json:"type"`
}

// Filters by whether or not 2FA is enabled and if the method configured is considered secure or insecure.
type TwoFactorCredentialSecurityType string

const (
	// No method of two-factor authentication.
	TwoFactorCredentialSecurityTypeDisabled TwoFactorCredentialSecurityType = "DISABLED"
	// Has an insecure method of two-factor authentication. GitHub currently defines this as SMS two-factor authentication.
	TwoFactorCredentialSecurityTypeInsecure TwoFactorCredentialSecurityType = "INSECURE"
	// Has only secure methods of two-factor authentication.
	TwoFactorCredentialSecurityTypeSecure TwoFactorCredentialSecurityType = "SECURE"
)

// An RFC 3986, RFC 3987, and RFC 6570 (level 4) compliant URI string.
type URI string

// Autogenerated input type of UnarchiveProjectV2Item
type UnarchiveProjectV2ItemInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the ProjectV2Item to unarchive.
	ItemId string `json:"itemId"`
	// The ID of the Project to archive the item from.
	ProjectId string `json:"projectId"`
}

// Autogenerated return type of UnarchiveProjectV2Item.
type UnarchiveProjectV2ItemPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The item unarchived from the project.
	Item *ProjectV2Item `json:"item,omitempty"`
}

// Autogenerated input type of UnarchiveRepository
type UnarchiveRepositoryInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the repository to unarchive.
	RepositoryId string `json:"repositoryId"`
}

// Autogenerated return type of UnarchiveRepository.
type UnarchiveRepositoryPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The repository that was unarchived.
	Repository *Repository `json:"repository,omitempty"`
}

// Represents an 'unassigned' event on any assignable object.
type UnassignedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the assignable associated with the event.
	Assignable *Assignable `json:"assignable"`
	// Identifies the user or mannequin that was unassigned.
	Assignee *Assignee `json:"assignee,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the UnassignedEvent object
	Id string `json:"id"`
	// Identifies the subject (user) who was unassigned.
	User *User `json:"user,omitempty"`
}

func (*UnassignedEvent) isIssueTimelineItem() {}

func (*UnassignedEvent) isIssueTimelineItems() {}

func (*UnassignedEvent) isPullRequestTimelineItem() {}

func (*UnassignedEvent) isPullRequestTimelineItems() {}

func (*UnassignedEvent) isNode() {}

// Autogenerated input type of UnfollowOrganization
type UnfollowOrganizationInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// ID of the organization to unfollow.
	OrganizationId string `json:"organizationId"`
}

// Autogenerated return type of UnfollowOrganization.
type UnfollowOrganizationPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The organization that was unfollowed.
	Organization *Organization `json:"organization,omitempty"`
}

// Autogenerated input type of UnfollowUser
type UnfollowUserInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// ID of the user to unfollow.
	UserId string `json:"userId"`
}

// Autogenerated return type of UnfollowUser.
type UnfollowUserPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The user that was unfollowed.
	User *User `json:"user,omitempty"`
}

// Represents a type that can be retrieved by a URL.
type UniformResourceLocatable struct {
	// The HTML path to this resource.
	ResourcePath URI `json:"resourcePath"`
	// The URL to this resource.
	Url URI `json:"url"`

	// Underlying value of the GraphQL interface
	Value UniformResourceLocatableValue `json:"-"`
}

func (base *UniformResourceLocatable) UnmarshalJSON(b []byte) error {
	type Raw UniformResourceLocatable
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Bot":
		base.Value = new(Bot)
	case "CheckRun":
		base.Value = new(CheckRun)
	case "ClosedEvent":
		base.Value = new(ClosedEvent)
	case "Commit":
		base.Value = new(Commit)
	case "ConvertToDraftEvent":
		base.Value = new(ConvertToDraftEvent)
	case "CrossReferencedEvent":
		base.Value = new(CrossReferencedEvent)
	case "Gist":
		base.Value = new(Gist)
	case "Issue":
		base.Value = new(Issue)
	case "Mannequin":
		base.Value = new(Mannequin)
	case "MergedEvent":
		base.Value = new(MergedEvent)
	case "Milestone":
		base.Value = new(Milestone)
	case "Organization":
		base.Value = new(Organization)
	case "PullRequest":
		base.Value = new(PullRequest)
	case "PullRequestCommit":
		base.Value = new(PullRequestCommit)
	case "ReadyForReviewEvent":
		base.Value = new(ReadyForReviewEvent)
	case "Release":
		base.Value = new(Release)
	case "Repository":
		base.Value = new(Repository)
	case "RepositoryTopic":
		base.Value = new(RepositoryTopic)
	case "ReviewDismissedEvent":
		base.Value = new(ReviewDismissedEvent)
	case "TeamDiscussion":
		base.Value = new(TeamDiscussion)
	case "TeamDiscussionComment":
		base.Value = new(TeamDiscussionComment)
	case "User":
		base.Value = new(User)
	case "Workflow":
		base.Value = new(Workflow)
	case "WorkflowRun":
		base.Value = new(WorkflowRun)
	case "WorkflowRunFile":
		base.Value = new(WorkflowRunFile)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface UniformResourceLocatable: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// UniformResourceLocatableValue is one of: Bot | CheckRun | ClosedEvent | Commit | ConvertToDraftEvent | CrossReferencedEvent | Gist | Issue | Mannequin | MergedEvent | Milestone | Organization | PullRequest | PullRequestCommit | ReadyForReviewEvent | Release | Repository | RepositoryTopic | ReviewDismissedEvent | TeamDiscussion | TeamDiscussionComment | User | Workflow | WorkflowRun | WorkflowRunFile
type UniformResourceLocatableValue interface {
	isUniformResourceLocatable()
}

// Represents an unknown signature on a Commit or Tag.
type UnknownSignature struct {
	// Email used to sign this object.
	Email string `json:"email"`
	// True if the signature is valid and verified by GitHub.
	IsValid bool `json:"isValid"`
	// Payload for GPG signing object. Raw ODB object without the signature header.
	Payload string `json:"payload"`
	// ASCII-armored signature header from object.
	Signature string `json:"signature"`
	// GitHub user corresponding to the email signing this commit.
	Signer *User `json:"signer,omitempty"`
	// The state of this signature. `VALID` if signature is valid and verified by
	// GitHub, otherwise represents reason why signature is considered invalid.
	State GitSignatureState `json:"state"`
	// The date the signature was verified, if valid
	VerifiedAt *DateTime `json:"verifiedAt,omitempty"`
	// True if the signature was made with GitHub's signing key.
	WasSignedByGitHub bool `json:"wasSignedByGitHub"`
}

func (*UnknownSignature) isGitSignature() {}

// Represents an 'unlabeled' event on a given issue or pull request.
type UnlabeledEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the UnlabeledEvent object
	Id string `json:"id"`
	// Identifies the label associated with the 'unlabeled' event.
	Label *Label `json:"label"`
	// Identifies the `Labelable` associated with the event.
	Labelable *Labelable `json:"labelable"`
}

func (*UnlabeledEvent) isIssueTimelineItem() {}

func (*UnlabeledEvent) isIssueTimelineItems() {}

func (*UnlabeledEvent) isPullRequestTimelineItem() {}

func (*UnlabeledEvent) isPullRequestTimelineItems() {}

func (*UnlabeledEvent) isNode() {}

// Autogenerated input type of UnlinkProjectV2FromRepository
type UnlinkProjectV2FromRepositoryInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the project to unlink from the repository.
	ProjectId string `json:"projectId"`
	// The ID of the repository to unlink from the project.
	RepositoryId string `json:"repositoryId"`
}

// Autogenerated return type of UnlinkProjectV2FromRepository.
type UnlinkProjectV2FromRepositoryPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The repository the project is no longer linked to.
	Repository *Repository `json:"repository,omitempty"`
}

// Autogenerated input type of UnlinkProjectV2FromTeam
type UnlinkProjectV2FromTeamInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the project to unlink from the team.
	ProjectId string `json:"projectId"`
	// The ID of the team to unlink from the project.
	TeamId string `json:"teamId"`
}

// Autogenerated return type of UnlinkProjectV2FromTeam.
type UnlinkProjectV2FromTeamPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The team the project is unlinked from
	Team *Team `json:"team,omitempty"`
}

// Autogenerated input type of UnlinkRepositoryFromProject
type UnlinkRepositoryFromProjectInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the Project linked to the Repository.
	ProjectId string `json:"projectId"`
	// The ID of the Repository linked to the Project.
	RepositoryId string `json:"repositoryId"`
}

// Autogenerated return type of UnlinkRepositoryFromProject.
type UnlinkRepositoryFromProjectPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The linked Project.
	Project *Project `json:"project,omitempty"`
	// The linked Repository.
	Repository *Repository `json:"repository,omitempty"`
}

// Autogenerated input type of UnlockLockable
type UnlockLockableInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// ID of the item to be unlocked.
	LockableId string `json:"lockableId"`
}

// Autogenerated return type of UnlockLockable.
type UnlockLockablePayload struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The item that was unlocked.
	UnlockedRecord *Lockable `json:"unlockedRecord,omitempty"`
}

// Represents an 'unlocked' event on a given issue or pull request.
type UnlockedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the UnlockedEvent object
	Id string `json:"id"`
	// Object that was unlocked.
	Lockable *Lockable `json:"lockable"`
}

func (*UnlockedEvent) isIssueTimelineItem() {}

func (*UnlockedEvent) isIssueTimelineItems() {}

func (*UnlockedEvent) isPullRequestTimelineItem() {}

func (*UnlockedEvent) isPullRequestTimelineItems() {}

func (*UnlockedEvent) isNode() {}

// Autogenerated input type of UnmarkDiscussionCommentAsAnswer
type UnmarkDiscussionCommentAsAnswerInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Node ID of the discussion comment to unmark as an answer.
	Id string `json:"id"`
}

// Autogenerated return type of UnmarkDiscussionCommentAsAnswer.
type UnmarkDiscussionCommentAsAnswerPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The discussion that includes the comment.
	Discussion *Discussion `json:"discussion,omitempty"`
}

// Autogenerated input type of UnmarkFileAsViewed
type UnmarkFileAsViewedInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The path of the file to mark as unviewed
	Path string `json:"path"`
	// The Node ID of the pull request.
	PullRequestId string `json:"pullRequestId"`
}

// Autogenerated return type of UnmarkFileAsViewed.
type UnmarkFileAsViewedPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The updated pull request.
	PullRequest *PullRequest `json:"pullRequest,omitempty"`
}

// Autogenerated input type of UnmarkIssueAsDuplicate
type UnmarkIssueAsDuplicateInput struct {
	// ID of the issue or pull request currently considered canonical/authoritative/original.
	CanonicalId string `json:"canonicalId"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// ID of the issue or pull request currently marked as a duplicate.
	DuplicateId string `json:"duplicateId"`
}

// Autogenerated return type of UnmarkIssueAsDuplicate.
type UnmarkIssueAsDuplicatePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The issue or pull request that was marked as a duplicate.
	Duplicate *IssueOrPullRequest `json:"duplicate,omitempty"`
}

// Autogenerated input type of UnmarkProjectV2AsTemplate
type UnmarkProjectV2AsTemplateInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the Project to unmark as a template.
	ProjectId string `json:"projectId"`
}

// Autogenerated return type of UnmarkProjectV2AsTemplate.
type UnmarkProjectV2AsTemplatePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The project.
	ProjectV2 *ProjectV2 `json:"projectV2,omitempty"`
}

// Represents an 'unmarked_as_duplicate' event on a given issue or pull request.
type UnmarkedAsDuplicateEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// The authoritative issue or pull request which has been duplicated by another.
	Canonical *IssueOrPullRequest `json:"canonical,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The issue or pull request which has been marked as a duplicate of another.
	Duplicate *IssueOrPullRequest `json:"duplicate,omitempty"`
	// The Node ID of the UnmarkedAsDuplicateEvent object
	Id string `json:"id"`
	// Canonical and duplicate belong to different repositories.
	IsCrossRepository bool `json:"isCrossRepository"`
}

func (*UnmarkedAsDuplicateEvent) isIssueTimelineItems() {}

func (*UnmarkedAsDuplicateEvent) isPullRequestTimelineItems() {}

func (*UnmarkedAsDuplicateEvent) isNode() {}

// Autogenerated input type of UnminimizeComment
type UnminimizeCommentInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Node ID of the subject to modify.
	SubjectId string `json:"subjectId"`
}

// Autogenerated return type of UnminimizeComment.
type UnminimizeCommentPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The comment that was unminimized.
	UnminimizedComment *Minimizable `json:"unminimizedComment,omitempty"`
}

// Autogenerated input type of UnpinIssue
type UnpinIssueInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the issue to be unpinned
	IssueId string `json:"issueId"`
}

// Autogenerated return type of UnpinIssue.
type UnpinIssuePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The id of the pinned issue that was unpinned
	Id string `json:"id,omitempty"`
	// The issue that was unpinned
	Issue *Issue `json:"issue,omitempty"`
}

// Represents an 'unpinned' event on a given issue or pull request.
type UnpinnedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the UnpinnedEvent object
	Id string `json:"id"`
	// Identifies the issue associated with the event.
	Issue *Issue `json:"issue"`
}

func (*UnpinnedEvent) isIssueTimelineItems() {}

func (*UnpinnedEvent) isPullRequestTimelineItems() {}

func (*UnpinnedEvent) isNode() {}

// Autogenerated input type of UnresolveReviewThread
type UnresolveReviewThreadInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the thread to unresolve
	ThreadId string `json:"threadId"`
}

// Autogenerated return type of UnresolveReviewThread.
type UnresolveReviewThreadPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The thread to resolve.
	Thread *PullRequestReviewThread `json:"thread,omitempty"`
}

// Represents an 'unsubscribed' event on a given `Subscribable`.
type UnsubscribedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the UnsubscribedEvent object
	Id string `json:"id"`
	// Object referenced by event.
	Subscribable *Subscribable `json:"subscribable"`
}

func (*UnsubscribedEvent) isIssueTimelineItem() {}

func (*UnsubscribedEvent) isIssueTimelineItems() {}

func (*UnsubscribedEvent) isPullRequestTimelineItem() {}

func (*UnsubscribedEvent) isPullRequestTimelineItems() {}

func (*UnsubscribedEvent) isNode() {}

// Entities that can be updated.
type Updatable struct {
	// Check if the current viewer can update this object.
	ViewerCanUpdate bool `json:"viewerCanUpdate"`

	// Underlying value of the GraphQL interface
	Value UpdatableValue `json:"-"`
}

func (base *Updatable) UnmarshalJSON(b []byte) error {
	type Raw Updatable
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "CommitComment":
		base.Value = new(CommitComment)
	case "Discussion":
		base.Value = new(Discussion)
	case "DiscussionComment":
		base.Value = new(DiscussionComment)
	case "GistComment":
		base.Value = new(GistComment)
	case "Issue":
		base.Value = new(Issue)
	case "IssueComment":
		base.Value = new(IssueComment)
	case "Project":
		base.Value = new(Project)
	case "ProjectV2":
		base.Value = new(ProjectV2)
	case "PullRequest":
		base.Value = new(PullRequest)
	case "PullRequestReview":
		base.Value = new(PullRequestReview)
	case "PullRequestReviewComment":
		base.Value = new(PullRequestReviewComment)
	case "TeamDiscussion":
		base.Value = new(TeamDiscussion)
	case "TeamDiscussionComment":
		base.Value = new(TeamDiscussionComment)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface Updatable: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// UpdatableValue is one of: CommitComment | Discussion | DiscussionComment | GistComment | Issue | IssueComment | Project | ProjectV2 | PullRequest | PullRequestReview | PullRequestReviewComment | TeamDiscussion | TeamDiscussionComment
type UpdatableValue interface {
	isUpdatable()
}

// Comments that can be updated.
type UpdatableComment struct {
	// Reasons why the current viewer can not update this comment.
	ViewerCannotUpdateReasons []CommentCannotUpdateReason `json:"viewerCannotUpdateReasons"`

	// Underlying value of the GraphQL interface
	Value UpdatableCommentValue `json:"-"`
}

func (base *UpdatableComment) UnmarshalJSON(b []byte) error {
	type Raw UpdatableComment
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "CommitComment":
		base.Value = new(CommitComment)
	case "DiscussionComment":
		base.Value = new(DiscussionComment)
	case "GistComment":
		base.Value = new(GistComment)
	case "Issue":
		base.Value = new(Issue)
	case "IssueComment":
		base.Value = new(IssueComment)
	case "PullRequest":
		base.Value = new(PullRequest)
	case "PullRequestReview":
		base.Value = new(PullRequestReview)
	case "PullRequestReviewComment":
		base.Value = new(PullRequestReviewComment)
	case "TeamDiscussion":
		base.Value = new(TeamDiscussion)
	case "TeamDiscussionComment":
		base.Value = new(TeamDiscussionComment)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface UpdatableComment: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// UpdatableCommentValue is one of: CommitComment | DiscussionComment | GistComment | Issue | IssueComment | PullRequest | PullRequestReview | PullRequestReviewComment | TeamDiscussion | TeamDiscussionComment
type UpdatableCommentValue interface {
	isUpdatableComment()
}

// Autogenerated input type of UpdateBranchProtectionRule
type UpdateBranchProtectionRuleInput struct {
	// Can this branch be deleted.
	AllowsDeletions *bool `json:"allowsDeletions,omitempty"`
	// Are force pushes allowed on this branch.
	AllowsForcePushes *bool `json:"allowsForcePushes,omitempty"`
	// Is branch creation a protected operation.
	BlocksCreations *bool `json:"blocksCreations,omitempty"`
	// The global relay id of the branch protection rule to be updated.
	BranchProtectionRuleId string `json:"branchProtectionRuleId"`
	// A list of User, Team, or App IDs allowed to bypass force push targeting matching branches.
	BypassForcePushActorIds []string `json:"bypassForcePushActorIds,omitempty"`
	// A list of User, Team, or App IDs allowed to bypass pull requests targeting matching branches.
	BypassPullRequestActorIds []string `json:"bypassPullRequestActorIds,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Will new commits pushed to matching branches dismiss pull request review approvals.
	DismissesStaleReviews *bool `json:"dismissesStaleReviews,omitempty"`
	// Can admins override branch protection.
	IsAdminEnforced *bool `json:"isAdminEnforced,omitempty"`
	// Whether users can pull changes from upstream when the branch is locked. Set to
	// `true` to allow fork syncing. Set to `false` to prevent fork syncing.
	LockAllowsFetchAndMerge *bool `json:"lockAllowsFetchAndMerge,omitempty"`
	// Whether to set the branch as read-only. If this is true, users will not be able to push to the branch.
	LockBranch *bool `json:"lockBranch,omitempty"`
	// The glob-like pattern used to determine matching branches.
	Pattern *string `json:"pattern,omitempty"`
	// A list of User, Team, or App IDs allowed to push to matching branches.
	PushActorIds []string `json:"pushActorIds,omitempty"`
	// Whether the most recent push must be approved by someone other than the person who pushed it
	RequireLastPushApproval *bool `json:"requireLastPushApproval,omitempty"`
	// Number of approving reviews required to update matching branches.
	RequiredApprovingReviewCount *int32 `json:"requiredApprovingReviewCount,omitempty"`
	// The list of required deployment environments
	RequiredDeploymentEnvironments []string `json:"requiredDeploymentEnvironments,omitempty"`
	// List of required status check contexts that must pass for commits to be accepted to matching branches.
	RequiredStatusCheckContexts []string `json:"requiredStatusCheckContexts,omitempty"`
	// The list of required status checks
	RequiredStatusChecks []RequiredStatusCheckInput `json:"requiredStatusChecks,omitempty"`
	// Are approving reviews required to update matching branches.
	RequiresApprovingReviews *bool `json:"requiresApprovingReviews,omitempty"`
	// Are reviews from code owners required to update matching branches.
	RequiresCodeOwnerReviews *bool `json:"requiresCodeOwnerReviews,omitempty"`
	// Are commits required to be signed.
	RequiresCommitSignatures *bool `json:"requiresCommitSignatures,omitempty"`
	// Are conversations required to be resolved before merging.
	RequiresConversationResolution *bool `json:"requiresConversationResolution,omitempty"`
	// Are successful deployments required before merging.
	RequiresDeployments *bool `json:"requiresDeployments,omitempty"`
	// Are merge commits prohibited from being pushed to this branch.
	RequiresLinearHistory *bool `json:"requiresLinearHistory,omitempty"`
	// Are status checks required to update matching branches.
	RequiresStatusChecks *bool `json:"requiresStatusChecks,omitempty"`
	// Are branches required to be up to date before merging.
	RequiresStrictStatusChecks *bool `json:"requiresStrictStatusChecks,omitempty"`
	// Is pushing to matching branches restricted.
	RestrictsPushes *bool `json:"restrictsPushes,omitempty"`
	// Is dismissal of pull request reviews restricted.
	RestrictsReviewDismissals *bool `json:"restrictsReviewDismissals,omitempty"`
	// A list of User, Team, or App IDs allowed to dismiss reviews on pull requests targeting matching branches.
	ReviewDismissalActorIds []string `json:"reviewDismissalActorIds,omitempty"`
}

// Autogenerated return type of UpdateBranchProtectionRule.
type UpdateBranchProtectionRulePayload struct {
	// The newly created BranchProtectionRule.
	BranchProtectionRule *BranchProtectionRule `json:"branchProtectionRule,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
}

// Autogenerated input type of UpdateCheckRun
type UpdateCheckRunInput struct {
	// Possible further actions the integrator can perform, which a user may trigger.
	Actions []CheckRunAction `json:"actions,omitempty"`
	// The node of the check.
	CheckRunId string `json:"checkRunId"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The time that the check run finished.
	CompletedAt *DateTime `json:"completedAt,omitempty"`
	// The final conclusion of the check.
	Conclusion *CheckConclusionState `json:"conclusion,omitempty"`
	// The URL of the integrator's site that has the full details of the check.
	DetailsUrl *URI `json:"detailsUrl,omitempty"`
	// A reference for the run on the integrator's system.
	ExternalId *string `json:"externalId,omitempty"`
	// The name of the check.
	Name *string `json:"name,omitempty"`
	// Descriptive details about the run.
	Output *CheckRunOutput `json:"output,omitempty"`
	// The node ID of the repository.
	RepositoryId string `json:"repositoryId"`
	// The time that the check run began.
	StartedAt *DateTime `json:"startedAt,omitempty"`
	// The current status.
	Status *RequestableCheckStatusState `json:"status,omitempty"`
}

// Autogenerated return type of UpdateCheckRun.
type UpdateCheckRunPayload struct {
	// The updated check run.
	CheckRun *CheckRun `json:"checkRun,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
}

// Autogenerated input type of UpdateCheckSuitePreferences
type UpdateCheckSuitePreferencesInput struct {
	// The check suite preferences to modify.
	AutoTriggerPreferences []CheckSuiteAutoTriggerPreference `json:"autoTriggerPreferences"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Node ID of the repository.
	RepositoryId string `json:"repositoryId"`
}

// Autogenerated return type of UpdateCheckSuitePreferences.
type UpdateCheckSuitePreferencesPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The updated repository.
	Repository *Repository `json:"repository,omitempty"`
}

// Autogenerated input type of UpdateDiscussionComment
type UpdateDiscussionCommentInput struct {
	// The new contents of the comment body.
	Body string `json:"body"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Node ID of the discussion comment to update.
	CommentId string `json:"commentId"`
}

// Autogenerated return type of UpdateDiscussionComment.
type UpdateDiscussionCommentPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The modified discussion comment.
	Comment *DiscussionComment `json:"comment,omitempty"`
}

// Autogenerated input type of UpdateDiscussion
type UpdateDiscussionInput struct {
	// The new contents of the discussion body.
	Body *string `json:"body,omitempty"`
	// The Node ID of a discussion category within the same repository to change this discussion to.
	CategoryId string `json:"categoryId,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Node ID of the discussion to update.
	DiscussionId string `json:"discussionId"`
	// The new discussion title.
	Title *string `json:"title,omitempty"`
}

// Autogenerated return type of UpdateDiscussion.
type UpdateDiscussionPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The modified discussion.
	Discussion *Discussion `json:"discussion,omitempty"`
}

// Autogenerated input type of UpdateEnterpriseAdministratorRole
type UpdateEnterpriseAdministratorRoleInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the Enterprise which the admin belongs to.
	EnterpriseId string `json:"enterpriseId"`
	// The login of a administrator whose role is being changed.
	Login string `json:"login"`
	// The new role for the Enterprise administrator.
	Role EnterpriseAdministratorRole `json:"role"`
}

// Autogenerated return type of UpdateEnterpriseAdministratorRole.
type UpdateEnterpriseAdministratorRolePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// A message confirming the result of changing the administrator's role.
	Message *string `json:"message,omitempty"`
}

// Autogenerated input type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting
type UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the enterprise on which to set the allow private repository forking setting.
	EnterpriseId string `json:"enterpriseId"`
	// The value for the allow private repository forking policy on the enterprise.
	PolicyValue *EnterpriseAllowPrivateRepositoryForkingPolicyValue `json:"policyValue,omitempty"`
	// The value for the allow private repository forking setting on the enterprise.
	SettingValue EnterpriseEnabledDisabledSettingValue `json:"settingValue"`
}

// Autogenerated return type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting.
type UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The enterprise with the updated allow private repository forking setting.
	Enterprise *Enterprise `json:"enterprise,omitempty"`
	// A message confirming the result of updating the allow private repository forking setting.
	Message *string `json:"message,omitempty"`
}

// Autogenerated input type of UpdateEnterpriseDefaultRepositoryPermissionSetting
type UpdateEnterpriseDefaultRepositoryPermissionSettingInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the enterprise on which to set the base repository permission setting.
	EnterpriseId string `json:"enterpriseId"`
	// The value for the base repository permission setting on the enterprise.
	SettingValue EnterpriseDefaultRepositoryPermissionSettingValue `json:"settingValue"`
}

// Autogenerated return type of UpdateEnterpriseDefaultRepositoryPermissionSetting.
type UpdateEnterpriseDefaultRepositoryPermissionSettingPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The enterprise with the updated base repository permission setting.
	Enterprise *Enterprise `json:"enterprise,omitempty"`
	// A message confirming the result of updating the base repository permission setting.
	Message *string `json:"message,omitempty"`
}

// Autogenerated input type of UpdateEnterpriseDeployKeySetting
type UpdateEnterpriseDeployKeySettingInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the enterprise on which to set the deploy key setting.
	EnterpriseId string `json:"enterpriseId"`
	// The value for the deploy key setting on the enterprise.
	SettingValue EnterpriseEnabledDisabledSettingValue `json:"settingValue"`
}

// Autogenerated return type of UpdateEnterpriseDeployKeySetting.
type UpdateEnterpriseDeployKeySettingPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The enterprise with the updated deploy key setting.
	Enterprise *Enterprise `json:"enterprise,omitempty"`
	// A message confirming the result of updating the deploy key setting.
	Message *string `json:"message,omitempty"`
}

// Autogenerated input type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting
type UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the enterprise on which to set the members can change repository visibility setting.
	EnterpriseId string `json:"enterpriseId"`
	// The value for the members can change repository visibility setting on the enterprise.
	SettingValue EnterpriseEnabledDisabledSettingValue `json:"settingValue"`
}

// Autogenerated return type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting.
type UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The enterprise with the updated members can change repository visibility setting.
	Enterprise *Enterprise `json:"enterprise,omitempty"`
	// A message confirming the result of updating the members can change repository visibility setting.
	Message *string `json:"message,omitempty"`
}

// Autogenerated input type of UpdateEnterpriseMembersCanCreateRepositoriesSetting
type UpdateEnterpriseMembersCanCreateRepositoriesSettingInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the enterprise on which to set the members can create repositories setting.
	EnterpriseId string `json:"enterpriseId"`
	// Allow members to create internal repositories. Defaults to current value.
	MembersCanCreateInternalRepositories *bool `json:"membersCanCreateInternalRepositories,omitempty"`
	// Allow members to create private repositories. Defaults to current value.
	MembersCanCreatePrivateRepositories *bool `json:"membersCanCreatePrivateRepositories,omitempty"`
	// Allow members to create public repositories. Defaults to current value.
	MembersCanCreatePublicRepositories *bool `json:"membersCanCreatePublicRepositories,omitempty"`
	// When false, allow member organizations to set their own repository creation member privileges.
	MembersCanCreateRepositoriesPolicyEnabled *bool `json:"membersCanCreateRepositoriesPolicyEnabled,omitempty"`
	// Value for the members can create repositories setting on the enterprise. This
	// or the granular public/private/internal allowed fields (but not both) must be provided.
	SettingValue *EnterpriseMembersCanCreateRepositoriesSettingValue `json:"settingValue,omitempty"`
}

// Autogenerated return type of UpdateEnterpriseMembersCanCreateRepositoriesSetting.
type UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The enterprise with the updated members can create repositories setting.
	Enterprise *Enterprise `json:"enterprise,omitempty"`
	// A message confirming the result of updating the members can create repositories setting.
	Message *string `json:"message,omitempty"`
}

// Autogenerated input type of UpdateEnterpriseMembersCanDeleteIssuesSetting
type UpdateEnterpriseMembersCanDeleteIssuesSettingInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the enterprise on which to set the members can delete issues setting.
	EnterpriseId string `json:"enterpriseId"`
	// The value for the members can delete issues setting on the enterprise.
	SettingValue EnterpriseEnabledDisabledSettingValue `json:"settingValue"`
}

// Autogenerated return type of UpdateEnterpriseMembersCanDeleteIssuesSetting.
type UpdateEnterpriseMembersCanDeleteIssuesSettingPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The enterprise with the updated members can delete issues setting.
	Enterprise *Enterprise `json:"enterprise,omitempty"`
	// A message confirming the result of updating the members can delete issues setting.
	Message *string `json:"message,omitempty"`
}

// Autogenerated input type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting
type UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the enterprise on which to set the members can delete repositories setting.
	EnterpriseId string `json:"enterpriseId"`
	// The value for the members can delete repositories setting on the enterprise.
	SettingValue EnterpriseEnabledDisabledSettingValue `json:"settingValue"`
}

// Autogenerated return type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting.
type UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The enterprise with the updated members can delete repositories setting.
	Enterprise *Enterprise `json:"enterprise,omitempty"`
	// A message confirming the result of updating the members can delete repositories setting.
	Message *string `json:"message,omitempty"`
}

// Autogenerated input type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting
type UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the enterprise on which to set the members can invite collaborators setting.
	EnterpriseId string `json:"enterpriseId"`
	// The value for the members can invite collaborators setting on the enterprise.
	SettingValue EnterpriseEnabledDisabledSettingValue `json:"settingValue"`
}

// Autogenerated return type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting.
type UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The enterprise with the updated members can invite collaborators setting.
	Enterprise *Enterprise `json:"enterprise,omitempty"`
	// A message confirming the result of updating the members can invite collaborators setting.
	Message *string `json:"message,omitempty"`
}

// Autogenerated input type of UpdateEnterpriseMembersCanMakePurchasesSetting
type UpdateEnterpriseMembersCanMakePurchasesSettingInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the enterprise on which to set the members can make purchases setting.
	EnterpriseId string `json:"enterpriseId"`
	// The value for the members can make purchases setting on the enterprise.
	SettingValue EnterpriseMembersCanMakePurchasesSettingValue `json:"settingValue"`
}

// Autogenerated return type of UpdateEnterpriseMembersCanMakePurchasesSetting.
type UpdateEnterpriseMembersCanMakePurchasesSettingPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The enterprise with the updated members can make purchases setting.
	Enterprise *Enterprise `json:"enterprise,omitempty"`
	// A message confirming the result of updating the members can make purchases setting.
	Message *string `json:"message,omitempty"`
}

// Autogenerated input type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting
type UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the enterprise on which to set the members can update protected branches setting.
	EnterpriseId string `json:"enterpriseId"`
	// The value for the members can update protected branches setting on the enterprise.
	SettingValue EnterpriseEnabledDisabledSettingValue `json:"settingValue"`
}

// Autogenerated return type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting.
type UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The enterprise with the updated members can update protected branches setting.
	Enterprise *Enterprise `json:"enterprise,omitempty"`
	// A message confirming the result of updating the members can update protected branches setting.
	Message *string `json:"message,omitempty"`
}

// Autogenerated input type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting
type UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the enterprise on which to set the members can view dependency insights setting.
	EnterpriseId string `json:"enterpriseId"`
	// The value for the members can view dependency insights setting on the enterprise.
	SettingValue EnterpriseEnabledDisabledSettingValue `json:"settingValue"`
}

// Autogenerated return type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting.
type UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The enterprise with the updated members can view dependency insights setting.
	Enterprise *Enterprise `json:"enterprise,omitempty"`
	// A message confirming the result of updating the members can view dependency insights setting.
	Message *string `json:"message,omitempty"`
}

// Autogenerated input type of UpdateEnterpriseOrganizationProjectsSetting
type UpdateEnterpriseOrganizationProjectsSettingInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the enterprise on which to set the organization projects setting.
	EnterpriseId string `json:"enterpriseId"`
	// The value for the organization projects setting on the enterprise.
	SettingValue EnterpriseEnabledDisabledSettingValue `json:"settingValue"`
}

// Autogenerated return type of UpdateEnterpriseOrganizationProjectsSetting.
type UpdateEnterpriseOrganizationProjectsSettingPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The enterprise with the updated organization projects setting.
	Enterprise *Enterprise `json:"enterprise,omitempty"`
	// A message confirming the result of updating the organization projects setting.
	Message *string `json:"message,omitempty"`
}

// Autogenerated input type of UpdateEnterpriseOwnerOrganizationRole
type UpdateEnterpriseOwnerOrganizationRoleInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the Enterprise which the owner belongs to.
	EnterpriseId string `json:"enterpriseId"`
	// The ID of the organization for membership change.
	OrganizationId string `json:"organizationId"`
	// The role to assume in the organization.
	OrganizationRole RoleInOrganization `json:"organizationRole"`
}

// Autogenerated return type of UpdateEnterpriseOwnerOrganizationRole.
type UpdateEnterpriseOwnerOrganizationRolePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// A message confirming the result of changing the owner's organization role.
	Message *string `json:"message,omitempty"`
}

// Autogenerated input type of UpdateEnterpriseProfile
type UpdateEnterpriseProfileInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The description of the enterprise.
	Description *string `json:"description,omitempty"`
	// The Enterprise ID to update.
	EnterpriseId string `json:"enterpriseId"`
	// The location of the enterprise.
	Location *string `json:"location,omitempty"`
	// The name of the enterprise.
	Name *string `json:"name,omitempty"`
	// The URL of the enterprise's website.
	WebsiteUrl *string `json:"websiteUrl,omitempty"`
}

// Autogenerated return type of UpdateEnterpriseProfile.
type UpdateEnterpriseProfilePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The updated enterprise.
	Enterprise *Enterprise `json:"enterprise,omitempty"`
}

// Autogenerated input type of UpdateEnterpriseRepositoryProjectsSetting
type UpdateEnterpriseRepositoryProjectsSettingInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the enterprise on which to set the repository projects setting.
	EnterpriseId string `json:"enterpriseId"`
	// The value for the repository projects setting on the enterprise.
	SettingValue EnterpriseEnabledDisabledSettingValue `json:"settingValue"`
}

// Autogenerated return type of UpdateEnterpriseRepositoryProjectsSetting.
type UpdateEnterpriseRepositoryProjectsSettingPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The enterprise with the updated repository projects setting.
	Enterprise *Enterprise `json:"enterprise,omitempty"`
	// A message confirming the result of updating the repository projects setting.
	Message *string `json:"message,omitempty"`
}

// Autogenerated input type of UpdateEnterpriseTeamDiscussionsSetting
type UpdateEnterpriseTeamDiscussionsSettingInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the enterprise on which to set the team discussions setting.
	EnterpriseId string `json:"enterpriseId"`
	// The value for the team discussions setting on the enterprise.
	SettingValue EnterpriseEnabledDisabledSettingValue `json:"settingValue"`
}

// Autogenerated return type of UpdateEnterpriseTeamDiscussionsSetting.
type UpdateEnterpriseTeamDiscussionsSettingPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The enterprise with the updated team discussions setting.
	Enterprise *Enterprise `json:"enterprise,omitempty"`
	// A message confirming the result of updating the team discussions setting.
	Message *string `json:"message,omitempty"`
}

// Autogenerated input type of UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSetting
type UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the enterprise on which to set the two-factor authentication disallowed methods setting.
	EnterpriseId string `json:"enterpriseId"`
	// The value for the two-factor authentication disallowed methods setting on the enterprise.
	SettingValue EnterpriseDisallowedMethodsSettingValue `json:"settingValue"`
}

// Autogenerated return type of UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSetting.
type UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The enterprise with the updated two-factor authentication disallowed methods setting.
	Enterprise *Enterprise `json:"enterprise,omitempty"`
	// A message confirming the result of updating the two-factor authentication disallowed methods setting.
	Message *string `json:"message,omitempty"`
}

// Autogenerated input type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting
type UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the enterprise on which to set the two factor authentication required setting.
	EnterpriseId string `json:"enterpriseId"`
	// The value for the two factor authentication required setting on the enterprise.
	SettingValue EnterpriseEnabledSettingValue `json:"settingValue"`
}

// Autogenerated return type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting.
type UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The enterprise with the updated two factor authentication required setting.
	Enterprise *Enterprise `json:"enterprise,omitempty"`
	// A message confirming the result of updating the two factor authentication required setting.
	Message *string `json:"message,omitempty"`
}

// Autogenerated input type of UpdateEnvironment
type UpdateEnvironmentInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The node ID of the environment.
	EnvironmentId string `json:"environmentId"`
	// Whether deployments to this environment can be approved by the user who created the deployment.
	PreventSelfReview *bool `json:"preventSelfReview,omitempty"`
	// The ids of users or teams that can approve deployments to this environment
	Reviewers []string `json:"reviewers,omitempty"`
	// The wait timer in minutes.
	WaitTimer *int32 `json:"waitTimer,omitempty"`
}

// Autogenerated return type of UpdateEnvironment.
type UpdateEnvironmentPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The updated environment.
	Environment *Environment `json:"environment,omitempty"`
}

// Autogenerated input type of UpdateIpAllowListEnabledSetting
type UpdateIpAllowListEnabledSettingInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the owner on which to set the IP allow list enabled setting.
	OwnerId string `json:"ownerId"`
	// The value for the IP allow list enabled setting.
	SettingValue IpAllowListEnabledSettingValue `json:"settingValue"`
}

// Autogenerated return type of UpdateIpAllowListEnabledSetting.
type UpdateIpAllowListEnabledSettingPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The IP allow list owner on which the setting was updated.
	Owner *IpAllowListOwner `json:"owner,omitempty"`
}

// Autogenerated input type of UpdateIpAllowListEntry
type UpdateIpAllowListEntryInput struct {
	// An IP address or range of addresses in CIDR notation.
	AllowListValue string `json:"allowListValue"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the IP allow list entry to update.
	IpAllowListEntryId string `json:"ipAllowListEntryId"`
	// Whether the IP allow list entry is active when an IP allow list is enabled.
	IsActive bool `json:"isActive"`
	// An optional name for the IP allow list entry.
	Name *string `json:"name,omitempty"`
}

// Autogenerated return type of UpdateIpAllowListEntry.
type UpdateIpAllowListEntryPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The IP allow list entry that was updated.
	IpAllowListEntry *IpAllowListEntry `json:"ipAllowListEntry,omitempty"`
}

// Autogenerated input type of UpdateIpAllowListForInstalledAppsEnabledSetting
type UpdateIpAllowListForInstalledAppsEnabledSettingInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the owner.
	OwnerId string `json:"ownerId"`
	// The value for the IP allow list configuration for installed GitHub Apps setting.
	SettingValue IpAllowListForInstalledAppsEnabledSettingValue `json:"settingValue"`
}

// Autogenerated return type of UpdateIpAllowListForInstalledAppsEnabledSetting.
type UpdateIpAllowListForInstalledAppsEnabledSettingPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The IP allow list owner on which the setting was updated.
	Owner *IpAllowListOwner `json:"owner,omitempty"`
}

// Autogenerated input type of UpdateIssueComment
type UpdateIssueCommentInput struct {
	// The updated text of the comment.
	Body string `json:"body"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the IssueComment to modify.
	Id string `json:"id"`
}

// Autogenerated return type of UpdateIssueComment.
type UpdateIssueCommentPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The updated comment.
	IssueComment *IssueComment `json:"issueComment,omitempty"`
}

// Autogenerated input type of UpdateIssue
type UpdateIssueInput struct {
	// An array of Node IDs of users for this issue.
	AssigneeIds []string `json:"assigneeIds,omitempty"`
	// The body for the issue description.
	Body *string `json:"body,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the Issue to modify.
	Id string `json:"id"`
	// The ID of the Issue Type for this issue.
	IssueTypeId string `json:"issueTypeId,omitempty"`
	// An array of Node IDs of labels for this issue.
	LabelIds []string `json:"labelIds,omitempty"`
	// The Node ID of the milestone for this issue.
	MilestoneId string `json:"milestoneId,omitempty"`
	// An array of Node IDs for projects associated with this issue.
	ProjectIds []string `json:"projectIds,omitempty"`
	// The desired issue state.
	State *IssueState `json:"state,omitempty"`
	// The title for the issue.
	Title *string `json:"title,omitempty"`
}

// Autogenerated input type of UpdateIssueIssueType
type UpdateIssueIssueTypeInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the issue to update
	IssueId string `json:"issueId"`
	// The ID of the issue type to update on the issue
	IssueTypeId string `json:"issueTypeId,omitempty"`
}

// Autogenerated return type of UpdateIssueIssueType.
type UpdateIssueIssueTypePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The updated issue
	Issue *Issue `json:"issue,omitempty"`
}

// Autogenerated return type of UpdateIssue.
type UpdateIssuePayload struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The issue.
	Issue *Issue `json:"issue,omitempty"`
}

// Autogenerated input type of UpdateIssueType
type UpdateIssueTypeInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Color for the issue type
	Color *IssueTypeColor `json:"color,omitempty"`
	// The description of the issue type
	Description *string `json:"description,omitempty"`
	// Whether or not the issue type is enabled for the organization
	IsEnabled *bool `json:"isEnabled,omitempty"`
	// The ID of the issue type to update
	IssueTypeId string `json:"issueTypeId"`
	// The name of the issue type
	Name *string `json:"name,omitempty"`
}

// Autogenerated return type of UpdateIssueType.
type UpdateIssueTypePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The updated issue type
	IssueType *IssueType `json:"issueType,omitempty"`
}

// Autogenerated input type of UpdateLabel
type UpdateLabelInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// A 6 character hex code, without the leading #, identifying the updated color of the label.
	Color *string `json:"color,omitempty"`
	// A brief description of the label, such as its purpose.
	Description *string `json:"description,omitempty"`
	// The Node ID of the label to be updated.
	Id string `json:"id"`
	// The updated name of the label.
	Name *string `json:"name,omitempty"`
}

// Autogenerated return type of UpdateLabel.
type UpdateLabelPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The updated label.
	Label *Label `json:"label,omitempty"`
}

// Autogenerated input type of UpdateNotificationRestrictionSetting
type UpdateNotificationRestrictionSettingInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the owner on which to set the restrict notifications setting.
	OwnerId string `json:"ownerId"`
	// The value for the restrict notifications setting.
	SettingValue NotificationRestrictionSettingValue `json:"settingValue"`
}

// Autogenerated return type of UpdateNotificationRestrictionSetting.
type UpdateNotificationRestrictionSettingPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The owner on which the setting was updated.
	Owner *VerifiableDomainOwner `json:"owner,omitempty"`
}

// Autogenerated input type of UpdateOrganizationAllowPrivateRepositoryForkingSetting
type UpdateOrganizationAllowPrivateRepositoryForkingSettingInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Enable forking of private repositories in the organization?
	ForkingEnabled bool `json:"forkingEnabled"`
	// The ID of the organization on which to set the allow private repository forking setting.
	OrganizationId string `json:"organizationId"`
}

// Autogenerated return type of UpdateOrganizationAllowPrivateRepositoryForkingSetting.
type UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// A message confirming the result of updating the allow private repository forking setting.
	Message *string `json:"message,omitempty"`
	// The organization with the updated allow private repository forking setting.
	Organization *Organization `json:"organization,omitempty"`
}

// Autogenerated input type of UpdateOrganizationWebCommitSignoffSetting
type UpdateOrganizationWebCommitSignoffSettingInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the organization on which to set the web commit signoff setting.
	OrganizationId string `json:"organizationId"`
	// Enable signoff on web-based commits for repositories in the organization?
	WebCommitSignoffRequired bool `json:"webCommitSignoffRequired"`
}

// Autogenerated return type of UpdateOrganizationWebCommitSignoffSetting.
type UpdateOrganizationWebCommitSignoffSettingPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// A message confirming the result of updating the web commit signoff setting.
	Message *string `json:"message,omitempty"`
	// The organization with the updated web commit signoff setting.
	Organization *Organization `json:"organization,omitempty"`
}

// Only allow users with bypass permission to update matching refs.
type UpdateParameters struct {
	// Branch can pull changes from its upstream repository
	UpdateAllowsFetchAndMerge bool `json:"updateAllowsFetchAndMerge"`
}

func (*UpdateParameters) isRuleParameters() {}

// Only allow users with bypass permission to update matching refs.
type UpdateParametersInput struct {
	// Branch can pull changes from its upstream repository
	UpdateAllowsFetchAndMerge bool `json:"updateAllowsFetchAndMerge"`
}

// Autogenerated input type of UpdatePatreonSponsorability
type UpdatePatreonSponsorabilityInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Whether Patreon tiers should be shown on the GitHub Sponsors profile page,
	// allowing potential sponsors to make their payment through Patreon instead of GitHub.
	EnablePatreonSponsorships bool `json:"enablePatreonSponsorships"`
	// The username of the organization with the GitHub Sponsors profile, if any.
	// Defaults to the GitHub Sponsors profile for the authenticated user if omitted.
	SponsorableLogin *string `json:"sponsorableLogin,omitempty"`
}

// Autogenerated return type of UpdatePatreonSponsorability.
type UpdatePatreonSponsorabilityPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The GitHub Sponsors profile.
	SponsorsListing *SponsorsListing `json:"sponsorsListing,omitempty"`
}

// Autogenerated input type of UpdateProjectCard
type UpdateProjectCardInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Whether or not the ProjectCard should be archived
	IsArchived *bool `json:"isArchived,omitempty"`
	// The note of ProjectCard.
	Note *string `json:"note,omitempty"`
	// The ProjectCard ID to update.
	ProjectCardId string `json:"projectCardId"`
}

// Autogenerated return type of UpdateProjectCard.
type UpdateProjectCardPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The updated ProjectCard.
	ProjectCard *ProjectCard `json:"projectCard,omitempty"`
}

// Autogenerated input type of UpdateProjectColumn
type UpdateProjectColumnInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The name of project column.
	Name string `json:"name"`
	// The ProjectColumn ID to update.
	ProjectColumnId string `json:"projectColumnId"`
}

// Autogenerated return type of UpdateProjectColumn.
type UpdateProjectColumnPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The updated project column.
	ProjectColumn *ProjectColumn `json:"projectColumn,omitempty"`
}

// Autogenerated input type of UpdateProject
type UpdateProjectInput struct {
	// The description of project.
	Body *string `json:"body,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The name of project.
	Name *string `json:"name,omitempty"`
	// The Project ID to update.
	ProjectId string `json:"projectId"`
	// Whether the project is public or not.
	Public *bool `json:"public,omitempty"`
	// Whether the project is open or closed.
	State *ProjectState `json:"state,omitempty"`
}

// Autogenerated return type of UpdateProject.
type UpdateProjectPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The updated project.
	Project *Project `json:"project,omitempty"`
}

// Autogenerated input type of UpdateProjectV2Collaborators
type UpdateProjectV2CollaboratorsInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The collaborators to update.
	Collaborators []ProjectV2Collaborator `json:"collaborators"`
	// The ID of the project to update the collaborators for.
	ProjectId string `json:"projectId"`
}

// Autogenerated return type of UpdateProjectV2Collaborators.
type UpdateProjectV2CollaboratorsPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The collaborators granted a role
	Collaborators *ProjectV2ActorConnection `json:"collaborators,omitempty"`
}

// Autogenerated input type of UpdateProjectV2DraftIssue
type UpdateProjectV2DraftIssueInput struct {
	// The IDs of the assignees of the draft issue.
	AssigneeIds []string `json:"assigneeIds,omitempty"`
	// The body of the draft issue.
	Body *string `json:"body,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the draft issue to update.
	DraftIssueId string `json:"draftIssueId"`
	// The title of the draft issue.
	Title *string `json:"title,omitempty"`
}

// Autogenerated return type of UpdateProjectV2DraftIssue.
type UpdateProjectV2DraftIssuePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The draft issue updated in the project.
	DraftIssue *DraftIssue `json:"draftIssue,omitempty"`
}

// Autogenerated input type of UpdateProjectV2Field
type UpdateProjectV2FieldInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the field to update.
	FieldId string `json:"fieldId"`
	// Configuration for an iteration field.
	IterationConfiguration *ProjectV2IterationFieldConfigurationInput `json:"iterationConfiguration,omitempty"`
	// The name to update.
	Name *string `json:"name,omitempty"`
	// Options for a field of type SINGLE_SELECT. If empty, no changes will be made
	// to the options. If values are present, they will overwrite the existing
	// options for the field.
	SingleSelectOptions []ProjectV2SingleSelectFieldOptionInput `json:"singleSelectOptions,omitempty"`
}

// Autogenerated return type of UpdateProjectV2Field.
type UpdateProjectV2FieldPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The updated field.
	ProjectV2Field *ProjectV2FieldConfiguration `json:"projectV2Field,omitempty"`
}

// Autogenerated input type of UpdateProjectV2
type UpdateProjectV2Input struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Set the project to closed or open.
	Closed *bool `json:"closed,omitempty"`
	// The ID of the Project to update.
	ProjectId string `json:"projectId"`
	// Set the project to public or private.
	Public *bool `json:"public,omitempty"`
	// Set the readme description of the project.
	Readme *string `json:"readme,omitempty"`
	// Set the short description of the project.
	ShortDescription *string `json:"shortDescription,omitempty"`
	// Set the title of the project.
	Title *string `json:"title,omitempty"`
}

// Autogenerated input type of UpdateProjectV2ItemFieldValue
type UpdateProjectV2ItemFieldValueInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the field to be updated.
	FieldId string `json:"fieldId"`
	// The ID of the item to be updated.
	ItemId string `json:"itemId"`
	// The ID of the Project.
	ProjectId string `json:"projectId"`
	// The value which will be set on the field.
	Value ProjectV2FieldValue `json:"value"`
}

// Autogenerated return type of UpdateProjectV2ItemFieldValue.
type UpdateProjectV2ItemFieldValuePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The updated item.
	ProjectV2Item *ProjectV2Item `json:"projectV2Item,omitempty"`
}

// Autogenerated input type of UpdateProjectV2ItemPosition
type UpdateProjectV2ItemPositionInput struct {
	// The ID of the item to position this item after. If omitted or set to null the item will be moved to top.
	AfterId string `json:"afterId,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the item to be moved.
	ItemId string `json:"itemId"`
	// The ID of the Project.
	ProjectId string `json:"projectId"`
}

// Autogenerated return type of UpdateProjectV2ItemPosition.
type UpdateProjectV2ItemPositionPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The items in the new order
	Items *ProjectV2ItemConnection `json:"items,omitempty"`
}

// Autogenerated return type of UpdateProjectV2.
type UpdateProjectV2Payload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The updated Project.
	ProjectV2 *ProjectV2 `json:"projectV2,omitempty"`
}

// Autogenerated input type of UpdateProjectV2StatusUpdate
type UpdateProjectV2StatusUpdateInput struct {
	// The body of the status update.
	Body *string `json:"body,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The start date of the status update.
	StartDate *Date `json:"startDate,omitempty"`
	// The status of the status update.
	Status *ProjectV2StatusUpdateStatus `json:"status,omitempty"`
	// The ID of the status update to be updated.
	StatusUpdateId string `json:"statusUpdateId"`
	// The target date of the status update.
	TargetDate *Date `json:"targetDate,omitempty"`
}

// Autogenerated return type of UpdateProjectV2StatusUpdate.
type UpdateProjectV2StatusUpdatePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The status update updated in the project.
	StatusUpdate *ProjectV2StatusUpdate `json:"statusUpdate,omitempty"`
}

// Autogenerated input type of UpdatePullRequestBranch
type UpdatePullRequestBranchInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The head ref oid for the upstream branch.
	ExpectedHeadOid *GitObjectID `json:"expectedHeadOid,omitempty"`
	// The Node ID of the pull request.
	PullRequestId string `json:"pullRequestId"`
	// The update branch method to use. If omitted, defaults to 'MERGE'
	UpdateMethod *PullRequestBranchUpdateMethod `json:"updateMethod,omitempty"`
}

// Autogenerated return type of UpdatePullRequestBranch.
type UpdatePullRequestBranchPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The updated pull request.
	PullRequest *PullRequest `json:"pullRequest,omitempty"`
}

// Autogenerated input type of UpdatePullRequest
type UpdatePullRequestInput struct {
	// An array of Node IDs of users for this pull request.
	AssigneeIds []string `json:"assigneeIds,omitempty"`
	// The name of the branch you want your changes pulled into. This should be an existing branch
	// on the current repository.
	BaseRefName *string `json:"baseRefName,omitempty"`
	// The contents of the pull request.
	Body *string `json:"body,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// An array of Node IDs of labels for this pull request.
	LabelIds []string `json:"labelIds,omitempty"`
	// Indicates whether maintainers can modify the pull request.
	MaintainerCanModify *bool `json:"maintainerCanModify,omitempty"`
	// The Node ID of the milestone for this pull request.
	MilestoneId string `json:"milestoneId,omitempty"`
	// An array of Node IDs for projects associated with this pull request.
	ProjectIds []string `json:"projectIds,omitempty"`
	// The Node ID of the pull request.
	PullRequestId string `json:"pullRequestId"`
	// The target state of the pull request.
	State *PullRequestUpdateState `json:"state,omitempty"`
	// The title of the pull request.
	Title *string `json:"title,omitempty"`
}

// Autogenerated return type of UpdatePullRequest.
type UpdatePullRequestPayload struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The updated pull request.
	PullRequest *PullRequest `json:"pullRequest,omitempty"`
}

// Autogenerated input type of UpdatePullRequestReviewComment
type UpdatePullRequestReviewCommentInput struct {
	// The text of the comment.
	Body string `json:"body"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Node ID of the comment to modify.
	PullRequestReviewCommentId string `json:"pullRequestReviewCommentId"`
}

// Autogenerated return type of UpdatePullRequestReviewComment.
type UpdatePullRequestReviewCommentPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The updated comment.
	PullRequestReviewComment *PullRequestReviewComment `json:"pullRequestReviewComment,omitempty"`
}

// Autogenerated input type of UpdatePullRequestReview
type UpdatePullRequestReviewInput struct {
	// The contents of the pull request review body.
	Body string `json:"body"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Node ID of the pull request review to modify.
	PullRequestReviewId string `json:"pullRequestReviewId"`
}

// Autogenerated return type of UpdatePullRequestReview.
type UpdatePullRequestReviewPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The updated pull request review.
	PullRequestReview *PullRequestReview `json:"pullRequestReview,omitempty"`
}

// Autogenerated input type of UpdateRef
type UpdateRefInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Permit updates of branch Refs that are not fast-forwards?
	Force *bool `json:"force,omitempty"`
	// The GitObjectID that the Ref shall be updated to target.
	Oid GitObjectID `json:"oid"`
	// The Node ID of the Ref to be updated.
	RefId string `json:"refId"`
}

// Autogenerated return type of UpdateRef.
type UpdateRefPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The updated Ref.
	Ref *Ref `json:"ref,omitempty"`
}

// Autogenerated input type of UpdateRefs
type UpdateRefsInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// A list of ref updates.
	RefUpdates []RefUpdate `json:"refUpdates"`
	// The Node ID of the repository.
	RepositoryId string `json:"repositoryId"`
}

// Autogenerated return type of UpdateRefs.
type UpdateRefsPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
}

// Autogenerated input type of UpdateRepository
type UpdateRepositoryInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// A new description for the repository. Pass an empty string to erase the existing description.
	Description *string `json:"description,omitempty"`
	// Indicates if the repository should have the discussions feature enabled.
	HasDiscussionsEnabled *bool `json:"hasDiscussionsEnabled,omitempty"`
	// Indicates if the repository should have the issues feature enabled.
	HasIssuesEnabled *bool `json:"hasIssuesEnabled,omitempty"`
	// Indicates if the repository should have the project boards feature enabled.
	HasProjectsEnabled *bool `json:"hasProjectsEnabled,omitempty"`
	// Indicates if the repository displays a Sponsor button for financial contributions.
	HasSponsorshipsEnabled *bool `json:"hasSponsorshipsEnabled,omitempty"`
	// Indicates if the repository should have the wiki feature enabled.
	HasWikiEnabled *bool `json:"hasWikiEnabled,omitempty"`
	// The URL for a web page about this repository. Pass an empty string to erase the existing URL.
	HomepageUrl *URI `json:"homepageUrl,omitempty"`
	// The new name of the repository.
	Name *string `json:"name,omitempty"`
	// The ID of the repository to update.
	RepositoryId string `json:"repositoryId"`
	// Whether this repository should be marked as a template such that anyone who
	// can access it can create new repositories with the same files and directory structure.
	Template *bool `json:"template,omitempty"`
}

// Autogenerated return type of UpdateRepository.
type UpdateRepositoryPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The updated repository.
	Repository *Repository `json:"repository,omitempty"`
}

// Autogenerated input type of UpdateRepositoryRuleset
type UpdateRepositoryRulesetInput struct {
	// A list of actors that are allowed to bypass rules in this ruleset.
	BypassActors []RepositoryRulesetBypassActorInput `json:"bypassActors,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The list of conditions for this ruleset
	Conditions *RepositoryRuleConditionsInput `json:"conditions,omitempty"`
	// The enforcement level for this ruleset
	Enforcement *RuleEnforcement `json:"enforcement,omitempty"`
	// The name of the ruleset.
	Name *string `json:"name,omitempty"`
	// The global relay id of the repository ruleset to be updated.
	RepositoryRulesetId string `json:"repositoryRulesetId"`
	// The list of rules for this ruleset
	Rules []RepositoryRuleInput `json:"rules,omitempty"`
	// The target of the ruleset.
	Target *RepositoryRulesetTarget `json:"target,omitempty"`
}

// Autogenerated return type of UpdateRepositoryRuleset.
type UpdateRepositoryRulesetPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The newly created Ruleset.
	Ruleset *RepositoryRuleset `json:"ruleset,omitempty"`
}

// Autogenerated input type of UpdateRepositoryWebCommitSignoffSetting
type UpdateRepositoryWebCommitSignoffSettingInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the repository to update.
	RepositoryId string `json:"repositoryId"`
	// Indicates if the repository should require signoff on web-based commits.
	WebCommitSignoffRequired bool `json:"webCommitSignoffRequired"`
}

// Autogenerated return type of UpdateRepositoryWebCommitSignoffSetting.
type UpdateRepositoryWebCommitSignoffSettingPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// A message confirming the result of updating the web commit signoff setting.
	Message *string `json:"message,omitempty"`
	// The updated repository.
	Repository *Repository `json:"repository,omitempty"`
}

// Autogenerated input type of UpdateSponsorshipPreferences
type UpdateSponsorshipPreferencesInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Specify whether others should be able to see that the sponsor is sponsoring
	// the sponsorable. Public visibility still does not reveal which tier is used.
	PrivacyLevel *SponsorshipPrivacy `json:"privacyLevel,omitempty"`
	// Whether the sponsor should receive email updates from the sponsorable.
	ReceiveEmails *bool `json:"receiveEmails,omitempty"`
	// The ID of the user or organization who is acting as the sponsor, paying for
	// the sponsorship. Required if sponsorLogin is not given.
	SponsorId string `json:"sponsorId,omitempty"`
	// The username of the user or organization who is acting as the sponsor, paying
	// for the sponsorship. Required if sponsorId is not given.
	SponsorLogin *string `json:"sponsorLogin,omitempty"`
	// The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given.
	SponsorableId string `json:"sponsorableId,omitempty"`
	// The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given.
	SponsorableLogin *string `json:"sponsorableLogin,omitempty"`
}

// Autogenerated return type of UpdateSponsorshipPreferences.
type UpdateSponsorshipPreferencesPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The sponsorship that was updated.
	Sponsorship *Sponsorship `json:"sponsorship,omitempty"`
}

// Autogenerated input type of UpdateSubscription
type UpdateSubscriptionInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The new state of the subscription.
	State SubscriptionState `json:"state"`
	// The Node ID of the subscribable object to modify.
	SubscribableId string `json:"subscribableId"`
}

// Autogenerated return type of UpdateSubscription.
type UpdateSubscriptionPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The input subscribable entity.
	Subscribable *Subscribable `json:"subscribable,omitempty"`
}

// Autogenerated input type of UpdateTeamDiscussionComment
type UpdateTeamDiscussionCommentInput struct {
	// The updated text of the comment.
	Body string `json:"body"`
	// The current version of the body content.
	BodyVersion *string `json:"bodyVersion,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the comment to modify.
	Id string `json:"id"`
}

// Autogenerated return type of UpdateTeamDiscussionComment.
type UpdateTeamDiscussionCommentPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The updated comment.
	TeamDiscussionComment *TeamDiscussionComment `json:"teamDiscussionComment,omitempty"`
}

// Autogenerated input type of UpdateTeamDiscussion
type UpdateTeamDiscussionInput struct {
	// The updated text of the discussion.
	Body *string `json:"body,omitempty"`
	// The current version of the body content. If provided, this update operation
	// will be rejected if the given version does not match the latest version on the server.
	BodyVersion *string `json:"bodyVersion,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Node ID of the discussion to modify.
	Id string `json:"id"`
	// If provided, sets the pinned state of the updated discussion.
	Pinned *bool `json:"pinned,omitempty"`
	// The updated title of the discussion.
	Title *string `json:"title,omitempty"`
}

// Autogenerated return type of UpdateTeamDiscussion.
type UpdateTeamDiscussionPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The updated discussion.
	TeamDiscussion *TeamDiscussion `json:"teamDiscussion,omitempty"`
}

// Autogenerated input type of UpdateTeamReviewAssignment
type UpdateTeamReviewAssignmentInput struct {
	// The algorithm to use for review assignment
	Algorithm *TeamReviewAssignmentAlgorithm `json:"algorithm,omitempty"`
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Count any members whose review has already been requested against the required number of members assigned to review
	CountMembersAlreadyRequested *bool `json:"countMembersAlreadyRequested,omitempty"`
	// Turn on or off review assignment
	Enabled bool `json:"enabled"`
	// An array of team member IDs to exclude
	ExcludedTeamMemberIds []string `json:"excludedTeamMemberIds,omitempty"`
	// The Node ID of the team to update review assignments of
	Id string `json:"id"`
	// Include the members of any child teams when assigning
	IncludeChildTeamMembers *bool `json:"includeChildTeamMembers,omitempty"`
	// Notify the entire team of the PR if it is delegated
	NotifyTeam *bool `json:"notifyTeam,omitempty"`
	// Remove the team review request when assigning
	RemoveTeamRequest *bool `json:"removeTeamRequest,omitempty"`
	// The number of team members to assign
	TeamMemberCount *int32 `json:"teamMemberCount,omitempty"`
}

// Autogenerated return type of UpdateTeamReviewAssignment.
type UpdateTeamReviewAssignmentPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The team that was modified
	Team *Team `json:"team,omitempty"`
}

// Autogenerated input type of UpdateTeamsRepository
type UpdateTeamsRepositoryInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Permission that should be granted to the teams.
	Permission RepositoryPermission `json:"permission"`
	// Repository ID being granted access to.
	RepositoryId string `json:"repositoryId"`
	// A list of teams being granted access. Limit: 10
	TeamIds []string `json:"teamIds"`
}

// Autogenerated return type of UpdateTeamsRepository.
type UpdateTeamsRepositoryPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The repository that was updated.
	Repository *Repository `json:"repository,omitempty"`
	// The teams granted permission on the repository.
	Teams []Team `json:"teams,omitempty"`
}

// Autogenerated input type of UpdateTopics
type UpdateTopicsInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The Node ID of the repository.
	RepositoryId string `json:"repositoryId"`
	// An array of topic names.
	TopicNames []string `json:"topicNames"`
}

// Autogenerated return type of UpdateTopics.
type UpdateTopicsPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// Names of the provided topics that are not valid.
	InvalidTopicNames []string `json:"invalidTopicNames,omitempty"`
	// The updated repository.
	Repository *Repository `json:"repository,omitempty"`
}

// Autogenerated input type of UpdateUserList
type UpdateUserListInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// A description of the list
	Description *string `json:"description,omitempty"`
	// Whether or not the list is private
	IsPrivate *bool `json:"isPrivate,omitempty"`
	// The ID of the list to update.
	ListId string `json:"listId"`
	// The name of the list
	Name *string `json:"name,omitempty"`
}

// Autogenerated return type of UpdateUserList.
type UpdateUserListPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The list that was just updated
	List *UserList `json:"list,omitempty"`
}

// Autogenerated input type of UpdateUserListsForItem
type UpdateUserListsForItemInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The item to add to the list
	ItemId string `json:"itemId"`
	// The lists to which this item should belong
	ListIds []string `json:"listIds"`
	// The suggested lists to create and add this item to
	SuggestedListIds []string `json:"suggestedListIds,omitempty"`
}

// Autogenerated return type of UpdateUserListsForItem.
type UpdateUserListsForItemPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The item that was added
	Item *UserListItems `json:"item,omitempty"`
	// The lists to which this item belongs
	Lists []UserList `json:"lists,omitempty"`
	// The user who owns the lists
	User *User `json:"user,omitempty"`
}

// A user is an individual's account on GitHub that owns repositories and can make new content.
type User struct {
	// Determine if this repository owner has any items that can be pinned to their profile.
	AnyPinnableItems bool `json:"anyPinnableItems"`
	// A URL pointing to the user's public avatar.
	AvatarUrl URI `json:"avatarUrl"`
	// The user's public profile bio.
	Bio *string `json:"bio,omitempty"`
	// The user's public profile bio as HTML.
	BioHTML HTML `json:"bioHTML"`
	// Could this user receive email notifications, if the organization had notification restrictions enabled?
	CanReceiveOrganizationEmailsWhenNotificationsRestricted bool `json:"canReceiveOrganizationEmailsWhenNotificationsRestricted"`
	// A list of commit comments made by this user.
	CommitComments *CommitCommentConnection `json:"commitComments"`
	// The user's public profile company.
	Company *string `json:"company,omitempty"`
	// The user's public profile company as HTML.
	CompanyHTML HTML `json:"companyHTML"`
	// The collection of contributions this user has made to different repositories.
	ContributionsCollection *ContributionsCollection `json:"contributionsCollection"`
	// The user's Copilot endpoint information
	CopilotEndpoints *CopilotEndpoints `json:"copilotEndpoints,omitempty"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The user's publicly visible profile email.
	Email string `json:"email"`
	// A list of enterprises that the user belongs to.
	Enterprises *EnterpriseConnection `json:"enterprises,omitempty"`
	// The estimated next GitHub Sponsors payout for this user/organization in cents (USD).
	EstimatedNextSponsorsPayoutInCents int32 `json:"estimatedNextSponsorsPayoutInCents"`
	// A list of users the given user is followed by.
	Followers *FollowerConnection `json:"followers"`
	// A list of users the given user is following.
	Following *FollowingConnection `json:"following"`
	// Find gist by repo name.
	Gist *Gist `json:"gist,omitempty"`
	// A list of gist comments made by this user.
	GistComments *GistCommentConnection `json:"gistComments"`
	// A list of the Gists the user has created.
	Gists *GistConnection `json:"gists"`
	// True if this user/organization has a GitHub Sponsors listing.
	HasSponsorsListing bool `json:"hasSponsorsListing"`
	// The hovercard information for this user in a given context
	Hovercard *Hovercard `json:"hovercard"`
	// The Node ID of the User object
	Id string `json:"id"`
	// The interaction ability settings for this user.
	InteractionAbility *RepositoryInteractionAbility `json:"interactionAbility,omitempty"`
	// Whether or not this user is a participant in the GitHub Security Bug Bounty.
	IsBountyHunter bool `json:"isBountyHunter"`
	// Whether or not this user is a participant in the GitHub Campus Experts Program.
	IsCampusExpert bool `json:"isCampusExpert"`
	// Whether or not this user is a GitHub Developer Program member.
	IsDeveloperProgramMember bool `json:"isDeveloperProgramMember"`
	// Whether or not this user is a GitHub employee.
	IsEmployee bool `json:"isEmployee"`
	// Whether or not this user is following the viewer. Inverse of viewerIsFollowing
	IsFollowingViewer bool `json:"isFollowingViewer"`
	// Whether or not this user is a member of the GitHub Stars Program.
	IsGitHubStar bool `json:"isGitHubStar"`
	// Whether or not the user has marked themselves as for hire.
	IsHireable bool `json:"isHireable"`
	// Whether or not this user is a site administrator.
	IsSiteAdmin bool `json:"isSiteAdmin"`
	// Whether the given account is sponsoring this user/organization.
	IsSponsoredBy bool `json:"isSponsoredBy"`
	// True if the viewer is sponsored by this user/organization.
	IsSponsoringViewer bool `json:"isSponsoringViewer"`
	// Whether or not this user is the viewing user.
	IsViewer bool `json:"isViewer"`
	// A list of issue comments made by this user.
	IssueComments *IssueCommentConnection `json:"issueComments"`
	// A list of issues associated with this user.
	Issues *IssueConnection `json:"issues"`
	// Showcases a selection of repositories and gists that the profile owner has
	// either curated or that have been selected automatically based on popularity.
	ItemShowcase *ProfileItemShowcase `json:"itemShowcase"`
	// Calculate how much each sponsor has ever paid total to this maintainer via
	// GitHub Sponsors. Does not include sponsorships paid via Patreon.
	LifetimeReceivedSponsorshipValues *SponsorAndLifetimeValueConnection `json:"lifetimeReceivedSponsorshipValues"`
	// A user-curated list of repositories
	Lists *UserListConnection `json:"lists"`
	// The user's public profile location.
	Location *string `json:"location,omitempty"`
	// The username used to login.
	Login string `json:"login"`
	// The estimated monthly GitHub Sponsors income for this user/organization in cents (USD).
	MonthlyEstimatedSponsorsIncomeInCents int32 `json:"monthlyEstimatedSponsorsIncomeInCents"`
	// The user's public profile name.
	Name *string `json:"name,omitempty"`
	// Find an organization by its login that the user belongs to.
	Organization *Organization `json:"organization,omitempty"`
	// Verified email addresses that match verified domains for a specified organization the user is a member of.
	OrganizationVerifiedDomainEmails []string `json:"organizationVerifiedDomainEmails"`
	// A list of organizations the user belongs to.
	Organizations *OrganizationConnection `json:"organizations"`
	// A list of packages under the owner.
	Packages *PackageConnection `json:"packages"`
	// A list of repositories and gists this profile owner can pin to their profile.
	PinnableItems *PinnableItemConnection `json:"pinnableItems"`
	// A list of repositories and gists this profile owner has pinned to their profile
	PinnedItems *PinnableItemConnection `json:"pinnedItems"`
	// Returns how many more items this profile owner can pin to their profile.
	PinnedItemsRemaining int32 `json:"pinnedItemsRemaining"`
	// Find project by number.
	Project *Project `json:"project,omitempty"`
	// Find a project by number.
	ProjectV2 *ProjectV2 `json:"projectV2,omitempty"`
	// A list of projects under the owner.
	Projects *ProjectConnection `json:"projects"`
	// The HTTP path listing user's projects
	ProjectsResourcePath URI `json:"projectsResourcePath"`
	// The HTTP URL listing user's projects
	ProjectsUrl URI `json:"projectsUrl"`
	// A list of projects under the owner.
	ProjectsV2 *ProjectV2Connection `json:"projectsV2"`
	// The user's profile pronouns
	Pronouns *string `json:"pronouns,omitempty"`
	// A list of public keys associated with this user.
	PublicKeys *PublicKeyConnection `json:"publicKeys"`
	// A list of pull requests associated with this user.
	PullRequests *PullRequestConnection `json:"pullRequests"`
	// Recent projects that this user has modified in the context of the owner.
	RecentProjects *ProjectV2Connection `json:"recentProjects"`
	// A list of repositories that the user owns.
	Repositories *RepositoryConnection `json:"repositories"`
	// A list of repositories that the user recently contributed to.
	RepositoriesContributedTo *RepositoryConnection `json:"repositoriesContributedTo"`
	// Find Repository.
	Repository *Repository `json:"repository,omitempty"`
	// Discussion comments this user has authored.
	RepositoryDiscussionComments *DiscussionCommentConnection `json:"repositoryDiscussionComments"`
	// Discussions this user has started.
	RepositoryDiscussions *DiscussionConnection `json:"repositoryDiscussions"`
	// The HTTP path for this user
	ResourcePath URI `json:"resourcePath"`
	// Replies this user has saved
	SavedReplies *SavedReplyConnection `json:"savedReplies,omitempty"`
	// The user's social media accounts, ordered as they appear on the user's profile.
	SocialAccounts *SocialAccountConnection `json:"socialAccounts"`
	// List of users and organizations this entity is sponsoring.
	Sponsoring *SponsorConnection `json:"sponsoring"`
	// List of sponsors for this user or organization.
	Sponsors *SponsorConnection `json:"sponsors"`
	// Events involving this sponsorable, such as new sponsorships.
	SponsorsActivities *SponsorsActivityConnection `json:"sponsorsActivities"`
	// The GitHub Sponsors listing for this user or organization.
	SponsorsListing *SponsorsListing `json:"sponsorsListing,omitempty"`
	// The sponsorship from the viewer to this user/organization; that is, the sponsorship where you're the sponsor.
	SponsorshipForViewerAsSponsor *Sponsorship `json:"sponsorshipForViewerAsSponsor,omitempty"`
	// The sponsorship from this user/organization to the viewer; that is, the sponsorship you're receiving.
	SponsorshipForViewerAsSponsorable *Sponsorship `json:"sponsorshipForViewerAsSponsorable,omitempty"`
	// List of sponsorship updates sent from this sponsorable to sponsors.
	SponsorshipNewsletters *SponsorshipNewsletterConnection `json:"sponsorshipNewsletters"`
	// The sponsorships where this user or organization is the maintainer receiving the funds.
	SponsorshipsAsMaintainer *SponsorshipConnection `json:"sponsorshipsAsMaintainer"`
	// The sponsorships where this user or organization is the funder.
	SponsorshipsAsSponsor *SponsorshipConnection `json:"sponsorshipsAsSponsor"`
	// Repositories the user has starred.
	StarredRepositories *StarredRepositoryConnection `json:"starredRepositories"`
	// The user's description of what they're currently doing.
	Status *UserStatus `json:"status,omitempty"`
	// Suggested names for user lists
	SuggestedListNames []UserListSuggestion `json:"suggestedListNames"`
	// Repositories the user has contributed to, ordered by contribution rank, plus repositories the user has created
	TopRepositories *RepositoryConnection `json:"topRepositories"`
	// The amount in United States cents (e.g., 500 = $5.00 USD) that this entity has
	// spent on GitHub to fund sponsorships. Only returns a value when viewed by the
	// user themselves or by a user who can manage sponsorships for the requested organization.
	TotalSponsorshipAmountAsSponsorInCents *int32 `json:"totalSponsorshipAmountAsSponsorInCents,omitempty"`
	// The user's Twitter username.
	TwitterUsername *string `json:"twitterUsername,omitempty"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The HTTP URL for this user
	Url URI `json:"url"`
	// Whether the request returns publicly visible information or privately visible information about the user
	UserViewType UserViewType `json:"userViewType"`
	// Can the viewer pin repositories and gists to the profile?
	ViewerCanChangePinnedItems bool `json:"viewerCanChangePinnedItems"`
	// Can the current viewer create new projects on this owner.
	ViewerCanCreateProjects bool `json:"viewerCanCreateProjects"`
	// Whether or not the viewer is able to follow the user.
	ViewerCanFollow bool `json:"viewerCanFollow"`
	// Whether or not the viewer is able to sponsor this user/organization.
	ViewerCanSponsor bool `json:"viewerCanSponsor"`
	// Whether or not this user is followed by the viewer. Inverse of isFollowingViewer.
	ViewerIsFollowing bool `json:"viewerIsFollowing"`
	// True if the viewer is sponsoring this user/organization.
	ViewerIsSponsoring bool `json:"viewerIsSponsoring"`
	// A list of repositories the given user is watching.
	Watching *RepositoryConnection `json:"watching"`
	// A URL pointing to the user's public website/blog.
	WebsiteUrl *URI `json:"websiteUrl,omitempty"`
}

func (*User) isAssignee() {}

func (*User) isAuditEntryActor() {}

func (*User) isBranchActorAllowanceActor() {}

func (*User) isClaimable() {}

func (*User) isDeploymentReviewer() {}

func (*User) isEnterpriseMember() {}

func (*User) isOrganizationOrUser() {}

func (*User) isProjectV2Actor() {}

func (*User) isPushAllowanceActor() {}

func (*User) isReactor() {}

func (*User) isRequestedReviewer() {}

func (*User) isReviewDismissalAllowanceActor() {}

func (*User) isSearchResultItem() {}

func (*User) isSponsor() {}

func (*User) isSponsorableItem() {}

func (*User) isSponsorsListingFeatureableItem() {}

func (*User) isActor() {}

func (*User) isNode() {}

func (*User) isPackageOwner() {}

func (*User) isProfileOwner() {}

func (*User) isProjectOwner() {}

func (*User) isProjectV2Owner() {}

func (*User) isProjectV2Recent() {}

func (*User) isRepositoryDiscussionAuthor() {}

func (*User) isRepositoryDiscussionCommentAuthor() {}

func (*User) isRepositoryOwner() {}

func (*User) isSponsorable() {}

func (*User) isUniformResourceLocatable() {}

// The possible durations that a user can be blocked for.
type UserBlockDuration string

const (
	// The user was blocked for 1 day
	UserBlockDurationOneDay UserBlockDuration = "ONE_DAY"
	// The user was blocked for 30 days
	UserBlockDurationOneMonth UserBlockDuration = "ONE_MONTH"
	// The user was blocked for 7 days
	UserBlockDurationOneWeek UserBlockDuration = "ONE_WEEK"
	// The user was blocked permanently
	UserBlockDurationPermanent UserBlockDuration = "PERMANENT"
	// The user was blocked for 3 days
	UserBlockDurationThreeDays UserBlockDuration = "THREE_DAYS"
)

// Represents a 'user_blocked' event on a given user.
type UserBlockedEvent struct {
	// Identifies the actor who performed the event.
	Actor *Actor `json:"actor,omitempty"`
	// Number of days that the user was blocked for.
	BlockDuration UserBlockDuration `json:"blockDuration"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The Node ID of the UserBlockedEvent object
	Id string `json:"id"`
	// The user who was blocked.
	Subject *User `json:"subject,omitempty"`
}

func (*UserBlockedEvent) isIssueTimelineItem() {}

func (*UserBlockedEvent) isIssueTimelineItems() {}

func (*UserBlockedEvent) isPullRequestTimelineItem() {}

func (*UserBlockedEvent) isPullRequestTimelineItems() {}

func (*UserBlockedEvent) isNode() {}

// A list of users.
type UserConnection struct {
	// A list of edges.
	Edges []*UserEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*User `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edit on user content
type UserContentEdit struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the date and time when the object was deleted.
	DeletedAt *DateTime `json:"deletedAt,omitempty"`
	// The actor who deleted this content
	DeletedBy *Actor `json:"deletedBy,omitempty"`
	// A summary of the changes for this edit
	Diff *string `json:"diff,omitempty"`
	// When this content was edited
	EditedAt DateTime `json:"editedAt"`
	// The actor who edited this content
	Editor *Actor `json:"editor,omitempty"`
	// The Node ID of the UserContentEdit object
	Id string `json:"id"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
}

func (*UserContentEdit) isNode() {}

// A list of edits to content.
type UserContentEditConnection struct {
	// A list of edges.
	Edges []*UserContentEditEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*UserContentEdit `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type UserContentEditEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *UserContentEdit `json:"node,omitempty"`
}

// Represents a user.
type UserEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *User `json:"node,omitempty"`
}

// Email attributes from External Identity
type UserEmailMetadata struct {
	// Boolean to identify primary emails
	Primary *bool `json:"primary,omitempty"`
	// Type of email
	Type *string `json:"type,omitempty"`
	// Email id
	Value string `json:"value"`
}

// A user-curated list of repositories
type UserList struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// The description of this list
	Description *string `json:"description,omitempty"`
	// The Node ID of the UserList object
	Id string `json:"id"`
	// Whether or not this list is private
	IsPrivate bool `json:"isPrivate"`
	// The items associated with this list
	Items *UserListItemsConnection `json:"items"`
	// The date and time at which this list was created or last had items added to it
	LastAddedAt DateTime `json:"lastAddedAt"`
	// The name of this list
	Name string `json:"name"`
	// The slug of this list
	Slug string `json:"slug"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The user to which this list belongs
	User *User `json:"user"`
}

func (*UserList) isNode() {}

// The connection type for UserList.
type UserListConnection struct {
	// A list of edges.
	Edges []*UserListEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*UserList `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type UserListEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *UserList `json:"node,omitempty"`
}

// Types that can be added to a user list.
type UserListItems struct {
	// Underlying value of the GraphQL union
	Value UserListItemsValue `json:"-"`
}

func (base *UserListItems) UnmarshalJSON(b []byte) error {
	type Raw UserListItems
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Repository":
		base.Value = new(Repository)
	case "":
		return fmt.Errorf("gqlclient: union UserListItems: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union UserListItems: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// UserListItemsValue is one of: Repository
type UserListItemsValue interface {
	isUserListItems()
}

// The connection type for UserListItems.
type UserListItemsConnection struct {
	// A list of edges.
	Edges []*UserListItemsEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*UserListItems `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type UserListItemsEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *UserListItems `json:"node,omitempty"`
}

// Represents a suggested user list.
type UserListSuggestion struct {
	// The ID of the suggested user list
	Id string `json:"id,omitempty"`
	// The name of the suggested user list
	Name *string `json:"name,omitempty"`
}

// A repository owned by an Enterprise Managed user.
type UserNamespaceRepository struct {
	// The Node ID of the UserNamespaceRepository object
	Id string `json:"id"`
	// The name of the repository.
	Name string `json:"name"`
	// The repository's name with owner.
	NameWithOwner string `json:"nameWithOwner"`
	// The user owner of the repository.
	Owner *RepositoryOwner `json:"owner"`
}

func (*UserNamespaceRepository) isNode() {}

// A list of repositories owned by users in an enterprise with Enterprise Managed Users.
type UserNamespaceRepositoryConnection struct {
	// A list of edges.
	Edges []*UserNamespaceRepositoryEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*UserNamespaceRepository `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type UserNamespaceRepositoryEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *UserNamespaceRepository `json:"node,omitempty"`
}

// The user's description of what they're currently doing.
type UserStatus struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// An emoji summarizing the user's status.
	Emoji *string `json:"emoji,omitempty"`
	// The status emoji as HTML.
	EmojiHTML *HTML `json:"emojiHTML,omitempty"`
	// If set, the status will not be shown after this date.
	ExpiresAt *DateTime `json:"expiresAt,omitempty"`
	// The Node ID of the UserStatus object
	Id string `json:"id"`
	// Whether this status indicates the user is not fully available on GitHub.
	IndicatesLimitedAvailability bool `json:"indicatesLimitedAvailability"`
	// A brief message describing what the user is doing.
	Message *string `json:"message,omitempty"`
	// The organization whose members can see this status. If null, this status is publicly visible.
	Organization *Organization `json:"organization,omitempty"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The user who has this status.
	User *User `json:"user"`
}

func (*UserStatus) isNode() {}

// The connection type for UserStatus.
type UserStatusConnection struct {
	// A list of edges.
	Edges []*UserStatusEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*UserStatus `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type UserStatusEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *UserStatus `json:"node,omitempty"`
}

// Ordering options for user status connections.
type UserStatusOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order user statuses by.
	Field UserStatusOrderField `json:"field"`
}

// Properties by which user status connections can be ordered.
type UserStatusOrderField string

const (
	// Order user statuses by when they were updated.
	UserStatusOrderFieldUpdatedAt UserStatusOrderField = "UPDATED_AT"
)

// Whether a user being viewed contains public or private information.
type UserViewType string

const (
	// A user containing information only visible to the authenticated user.
	UserViewTypePrivate UserViewType = "PRIVATE"
	// A user that is publicly visible.
	UserViewTypePublic UserViewType = "PUBLIC"
)

// A domain that can be verified or approved for an organization or an enterprise.
type VerifiableDomain struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The DNS host name that should be used for verification.
	DnsHostName *URI `json:"dnsHostName,omitempty"`
	// The unicode encoded domain.
	Domain URI `json:"domain"`
	// Whether a TXT record for verification with the expected host name was found.
	HasFoundHostName bool `json:"hasFoundHostName"`
	// Whether a TXT record for verification with the expected verification token was found.
	HasFoundVerificationToken bool `json:"hasFoundVerificationToken"`
	// The Node ID of the VerifiableDomain object
	Id string `json:"id"`
	// Whether or not the domain is approved.
	IsApproved bool `json:"isApproved"`
	// Whether this domain is required to exist for an organization or enterprise policy to be enforced.
	IsRequiredForPolicyEnforcement bool `json:"isRequiredForPolicyEnforcement"`
	// Whether or not the domain is verified.
	IsVerified bool `json:"isVerified"`
	// The owner of the domain.
	Owner VerifiableDomainOwner `json:"owner"`
	// The punycode encoded domain.
	PunycodeEncodedDomain URI `json:"punycodeEncodedDomain"`
	// The time that the current verification token will expire.
	TokenExpirationTime *DateTime `json:"tokenExpirationTime,omitempty"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The current verification token for the domain.
	VerificationToken *string `json:"verificationToken,omitempty"`
}

func (*VerifiableDomain) isNode() {}

// The connection type for VerifiableDomain.
type VerifiableDomainConnection struct {
	// A list of edges.
	Edges []*VerifiableDomainEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*VerifiableDomain `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type VerifiableDomainEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *VerifiableDomain `json:"node,omitempty"`
}

// Ordering options for verifiable domain connections.
type VerifiableDomainOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field to order verifiable domains by.
	Field VerifiableDomainOrderField `json:"field"`
}

// Properties by which verifiable domain connections can be ordered.
type VerifiableDomainOrderField string

const (
	// Order verifiable domains by their creation date.
	VerifiableDomainOrderFieldCreatedAt VerifiableDomainOrderField = "CREATED_AT"
	// Order verifiable domains by the domain name.
	VerifiableDomainOrderFieldDomain VerifiableDomainOrderField = "DOMAIN"
)

// Types that can own a verifiable domain.
type VerifiableDomainOwner struct {
	// Underlying value of the GraphQL union
	Value VerifiableDomainOwnerValue `json:"-"`
}

func (base *VerifiableDomainOwner) UnmarshalJSON(b []byte) error {
	type Raw VerifiableDomainOwner
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Enterprise":
		base.Value = new(Enterprise)
	case "Organization":
		base.Value = new(Organization)
	case "":
		return fmt.Errorf("gqlclient: union VerifiableDomainOwner: missing __typename field")
	default:
		return fmt.Errorf("gqlclient: union VerifiableDomainOwner: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// VerifiableDomainOwnerValue is one of: Enterprise | Organization
type VerifiableDomainOwnerValue interface {
	isVerifiableDomainOwner()
}

// Autogenerated input type of VerifyVerifiableDomain
type VerifyVerifiableDomainInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The ID of the verifiable domain to verify.
	Id string `json:"id"`
}

// Autogenerated return type of VerifyVerifiableDomain.
type VerifyVerifiableDomainPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationId *string `json:"clientMutationId,omitempty"`
	// The verifiable domain that was verified.
	Domain *VerifiableDomain `json:"domain,omitempty"`
}

// A hovercard context with a message describing how the viewer is related.
type ViewerHovercardContext struct {
	// A string describing this context
	Message string `json:"message"`
	// An octicon to accompany this context
	Octicon string `json:"octicon"`
	// Identifies the user who is related to this context.
	Viewer *User `json:"viewer"`
}

func (*ViewerHovercardContext) isHovercardContext() {}

// A subject that may be upvoted.
type Votable struct {
	// Number of upvotes that this subject has received.
	UpvoteCount int32 `json:"upvoteCount"`
	// Whether or not the current user can add or remove an upvote on this subject.
	ViewerCanUpvote bool `json:"viewerCanUpvote"`
	// Whether or not the current user has already upvoted this subject.
	ViewerHasUpvoted bool `json:"viewerHasUpvoted"`

	// Underlying value of the GraphQL interface
	Value VotableValue `json:"-"`
}

func (base *Votable) UnmarshalJSON(b []byte) error {
	type Raw Votable
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "Discussion":
		base.Value = new(Discussion)
	case "DiscussionComment":
		base.Value = new(DiscussionComment)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface Votable: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// VotableValue is one of: Discussion | DiscussionComment
type VotableValue interface {
	isVotable()
}

// A workflow contains meta information about an Actions workflow file.
type Workflow struct {
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The Node ID of the Workflow object
	Id string `json:"id"`
	// The name of the workflow.
	Name string `json:"name"`
	// The HTTP path for this workflow
	ResourcePath URI `json:"resourcePath"`
	// The runs of the workflow.
	Runs *WorkflowRunConnection `json:"runs"`
	// The state of the workflow.
	State WorkflowState `json:"state"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The HTTP URL for this workflow
	Url URI `json:"url"`
}

func (*Workflow) isNode() {}

func (*Workflow) isUniformResourceLocatable() {}

// A workflow that must run for this rule to pass
type WorkflowFileReference struct {
	// The path to the workflow file
	Path string `json:"path"`
	// The ref (branch or tag) of the workflow file to use
	Ref *string `json:"ref,omitempty"`
	// The ID of the repository where the workflow is defined
	RepositoryId int32 `json:"repositoryId"`
	// The commit SHA of the workflow file to use
	Sha *string `json:"sha,omitempty"`
}

// A workflow that must run for this rule to pass
type WorkflowFileReferenceInput struct {
	// The path to the workflow file
	Path string `json:"path"`
	// The ref (branch or tag) of the workflow file to use
	Ref *string `json:"ref,omitempty"`
	// The ID of the repository where the workflow is defined
	RepositoryId int32 `json:"repositoryId"`
	// The commit SHA of the workflow file to use
	Sha *string `json:"sha,omitempty"`
}

// A workflow run.
type WorkflowRun struct {
	// The check suite this workflow run belongs to.
	CheckSuite *CheckSuite `json:"checkSuite"`
	// Identifies the date and time when the object was created.
	CreatedAt DateTime `json:"createdAt"`
	// Identifies the primary key from the database.
	DatabaseId *int32 `json:"databaseId,omitempty"`
	// The log of deployment reviews
	DeploymentReviews *DeploymentReviewConnection `json:"deploymentReviews"`
	// The event that triggered the workflow run
	Event string `json:"event"`
	// The workflow file
	File *WorkflowRunFile `json:"file,omitempty"`
	// The Node ID of the WorkflowRun object
	Id string `json:"id"`
	// The pending deployment requests of all check runs in this workflow run
	PendingDeploymentRequests *DeploymentRequestConnection `json:"pendingDeploymentRequests"`
	// The HTTP path for this workflow run
	ResourcePath URI `json:"resourcePath"`
	// A number that uniquely identifies this workflow run in its parent workflow.
	RunNumber int32 `json:"runNumber"`
	// Identifies the date and time when the object was last updated.
	UpdatedAt DateTime `json:"updatedAt"`
	// The HTTP URL for this workflow run
	Url URI `json:"url"`
	// The workflow executed in this workflow run.
	Workflow *Workflow `json:"workflow"`
}

func (*WorkflowRun) isNode() {}

func (*WorkflowRun) isUniformResourceLocatable() {}

// The connection type for WorkflowRun.
type WorkflowRunConnection struct {
	// A list of edges.
	Edges []*WorkflowRunEdge `json:"edges,omitempty"`
	// A list of nodes.
	Nodes []*WorkflowRun `json:"nodes,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int32 `json:"totalCount"`
}

// An edge in a connection.
type WorkflowRunEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *WorkflowRun `json:"node,omitempty"`
}

// An executed workflow file for a workflow run.
type WorkflowRunFile struct {
	// The Node ID of the WorkflowRunFile object
	Id string `json:"id"`
	// The path of the workflow file relative to its repository.
	Path string `json:"path"`
	// The direct link to the file in the repository which stores the workflow file.
	RepositoryFileUrl URI `json:"repositoryFileUrl"`
	// The repository name and owner which stores the workflow file.
	RepositoryName URI `json:"repositoryName"`
	// The HTTP path for this workflow run file
	ResourcePath URI `json:"resourcePath"`
	// The parent workflow run execution for this file.
	Run *WorkflowRun `json:"run"`
	// The HTTP URL for this workflow run file
	Url URI `json:"url"`
	// If the viewer has permissions to push to the repository which stores the workflow.
	ViewerCanPushRepository bool `json:"viewerCanPushRepository"`
	// If the viewer has permissions to read the repository which stores the workflow.
	ViewerCanReadRepository bool `json:"viewerCanReadRepository"`
}

func (*WorkflowRunFile) isNode() {}

func (*WorkflowRunFile) isUniformResourceLocatable() {}

// Ways in which lists of workflow runs can be ordered upon return.
type WorkflowRunOrder struct {
	// The direction in which to order workflow runs by the specified field.
	Direction OrderDirection `json:"direction"`
	// The field by which to order workflows.
	Field WorkflowRunOrderField `json:"field"`
}

// Properties by which workflow run connections can be ordered.
type WorkflowRunOrderField string

const (
	// Order workflow runs by most recently created
	WorkflowRunOrderFieldCreatedAt WorkflowRunOrderField = "CREATED_AT"
)

// The possible states for a workflow.
type WorkflowState string

const (
	// The workflow is active.
	WorkflowStateActive WorkflowState = "ACTIVE"
	// The workflow was deleted from the git repository.
	WorkflowStateDeleted WorkflowState = "DELETED"
	// The workflow was disabled by default on a fork.
	WorkflowStateDisabledFork WorkflowState = "DISABLED_FORK"
	// The workflow was disabled for inactivity in the repository.
	WorkflowStateDisabledInactivity WorkflowState = "DISABLED_INACTIVITY"
	// The workflow was disabled manually.
	WorkflowStateDisabledManually WorkflowState = "DISABLED_MANUALLY"
)

// Require all changes made to a targeted branch to pass the specified workflows before they can be merged.
type WorkflowsParameters struct {
	// Allow repositories and branches to be created if a check would otherwise prohibit it.
	DoNotEnforceOnCreate bool `json:"doNotEnforceOnCreate"`
	// Workflows that must pass for this rule to pass.
	Workflows []WorkflowFileReference `json:"workflows"`
}

func (*WorkflowsParameters) isRuleParameters() {}

// Require all changes made to a targeted branch to pass the specified workflows before they can be merged.
type WorkflowsParametersInput struct {
	// Allow repositories and branches to be created if a check would otherwise prohibit it.
	DoNotEnforceOnCreate *bool `json:"doNotEnforceOnCreate,omitempty"`
	// Workflows that must pass for this rule to pass.
	Workflows []WorkflowFileReferenceInput `json:"workflows"`
}

// A valid x509 certificate string
type X509Certificate string

func FetchLogin(client *gqlclient.Client, ctx context.Context) (viewer *User, err error) {
	op := gqlclient.NewOperation("query fetchLogin {\n\tviewer {\n\t\tlogin\n\t}\n}\n")
	var respData struct {
		Viewer *User
	}
	err = client.Execute(ctx, op, &respData)
	return respData.Viewer, err
}

func FetchPullRequests(client *gqlclient.Client, ctx context.Context, owner string, name string, limit int32, states []PullRequestState) (repository *Repository, err error) {
	op := gqlclient.NewOperation("query fetchPullRequests ($owner: String!, $name: String!, $limit: Int!, $states: [PullRequestState!]) {\n\trepository(owner: $owner, name: $name) {\n\t\tpullRequests(first: $limit, states: $states, orderBy: {field:CREATED_AT,direction:DESC}) {\n\t\t\tedges {\n\t\t\t\tnode {\n\t\t\t\t\tauthor {\n\t\t\t\t\t\tlogin\n\t\t\t\t\t}\n\t\t\t\t\tbaseRefOid\n\t\t\t\t\tnumber\n\t\t\t\t\ttitle\n\t\t\t\t\tcreatedAt\n\t\t\t\t\theadRef {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t\tcomments {\n\t\t\t\t\t\ttotalCount\n\t\t\t\t\t}\n\t\t\t\t\tcommits(last: 1) {\n\t\t\t\t\t\tnodes {\n\t\t\t\t\t\t\tcommit {\n\t\t\t\t\t\t\t\tstatus {\n\t\t\t\t\t\t\t\t\tstate\n\t\t\t\t\t\t\t\t\tcontexts {\n\t\t\t\t\t\t\t\t\t\tstate\n\t\t\t\t\t\t\t\t\t\tcontext\n\t\t\t\t\t\t\t\t\t\tdescription\n\t\t\t\t\t\t\t\t\t\ttargetUrl\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trepository {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t\treviews(first: 100) {\n\t\t\t\t\t\tedges {\n\t\t\t\t\t\t\tnode {\n\t\t\t\t\t\t\t\tauthor {\n\t\t\t\t\t\t\t\t\tlogin\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbody\n\t\t\t\t\t\t\t\tcomments {\n\t\t\t\t\t\t\t\t\ttotalCount\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n")
	op.Var("owner", owner)
	op.Var("name", name)
	op.Var("limit", limit)
	op.Var("states", states)
	var respData struct {
		Repository *Repository
	}
	err = client.Execute(ctx, op, &respData)
	return respData.Repository, err
}

func FetchPullRequestID(client *gqlclient.Client, ctx context.Context, owner string, name string, number int32) (repository *Repository, err error) {
	op := gqlclient.NewOperation("query fetchPullRequestID ($owner: String!, $name: String!, $number: Int!) {\n\trepository(owner: $owner, name: $name) {\n\t\tpullRequest(number: $number) {\n\t\t\tid\n\t\t}\n\t}\n}\n")
	op.Var("owner", owner)
	op.Var("name", name)
	op.Var("number", number)
	var respData struct {
		Repository *Repository
	}
	err = client.Execute(ctx, op, &respData)
	return respData.Repository, err
}

func FetchMyPullRequests(client *gqlclient.Client, ctx context.Context, limit int32) (viewer *User, err error) {
	op := gqlclient.NewOperation("query fetchMyPullRequests ($limit: Int!) {\n\tviewer {\n\t\tpullRequests(first: $limit, states: OPEN, orderBy: {field:CREATED_AT,direction:DESC}) {\n\t\t\tedges {\n\t\t\t\tnode {\n\t\t\t\t\tauthor {\n\t\t\t\t\t\tlogin\n\t\t\t\t\t}\n\t\t\t\t\tnumber\n\t\t\t\t\ttitle\n\t\t\t\t\tcreatedAt\n\t\t\t\t\theadRef {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t\tcomments {\n\t\t\t\t\t\ttotalCount\n\t\t\t\t\t}\n\t\t\t\t\trepository {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t\treviews(first: 100) {\n\t\t\t\t\t\tedges {\n\t\t\t\t\t\t\tnode {\n\t\t\t\t\t\t\t\tauthor {\n\t\t\t\t\t\t\t\t\tlogin\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbody\n\t\t\t\t\t\t\t\tcomments {\n\t\t\t\t\t\t\t\t\ttotalCount\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n")
	op.Var("limit", limit)
	var respData struct {
		Viewer *User
	}
	err = client.Execute(ctx, op, &respData)
	return respData.Viewer, err
}

func FetchMyPullRequestReviewQueue(client *gqlclient.Client, ctx context.Context, query string, limit int32) (search *SearchResultItemConnection, err error) {
	op := gqlclient.NewOperation("query fetchMyPullRequestReviewQueue ($query: String!, $limit: Int!) {\n\tsearch(query: $query, type: ISSUE, first: $limit) {\n\t\tedges {\n\t\t\tnode {\n\t\t\t\t... on PullRequest {\n\t\t\t\t\t__typename\n\t\t\t\t\tauthor {\n\t\t\t\t\t\tlogin\n\t\t\t\t\t}\n\t\t\t\t\tnumber\n\t\t\t\t\ttitle\n\t\t\t\t\tcreatedAt\n\t\t\t\t\theadRef {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t\tcomments {\n\t\t\t\t\t\ttotalCount\n\t\t\t\t\t}\n\t\t\t\t\trepository {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t\treviews(first: 100) {\n\t\t\t\t\t\tedges {\n\t\t\t\t\t\t\tnode {\n\t\t\t\t\t\t\t\tauthor {\n\t\t\t\t\t\t\t\t\tlogin\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbody\n\t\t\t\t\t\t\t\tcomments {\n\t\t\t\t\t\t\t\t\ttotalCount\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttimelineItems(last: 10) {\n\t\t\t\t\t\tnodes {\n\t\t\t\t\t\t\t__typename\n\t\t\t\t\t\t\t... on ReviewRequestedEvent {\n\t\t\t\t\t\t\t\tcreatedAt\n\t\t\t\t\t\t\t\trequestedReviewer {\n\t\t\t\t\t\t\t\t\t... on User {\n\t\t\t\t\t\t\t\t\t\t__typename\n\t\t\t\t\t\t\t\t\t\tlogin\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n")
	op.Var("query", query)
	op.Var("limit", limit)
	var respData struct {
		Search *SearchResultItemConnection
	}
	err = client.Execute(ctx, op, &respData)
	return respData.Search, err
}

func FetchConversation(client *gqlclient.Client, ctx context.Context, number int32, owner string, name string) (repository *Repository, err error) {
	op := gqlclient.NewOperation("query fetchConversation ($number: Int!, $owner: String!, $name: String!) {\n\trepository(owner: $owner, name: $name) {\n\t\tpullRequest(number: $number) {\n\t\t\ttitle\n\t\t\tnumber\n\t\t\tbody\n\t\t\tauthor {\n\t\t\t\tlogin\n\t\t\t\t... on User {\n\t\t\t\t\t__typename\n\t\t\t\t\tname\n\t\t\t\t}\n\t\t\t}\n\t\t\tcomments(first: 100) {\n\t\t\t\tedges {\n\t\t\t\t\tnode {\n\t\t\t\t\t\tauthor {\n\t\t\t\t\t\t\tlogin\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbody\n\t\t\t\t\t\tcreatedAt\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcreatedAt\n\t\t\tnumber\n\t\t\trepository {\n\t\t\t\tname\n\t\t\t}\n\t\t\treviews(first: 100) {\n\t\t\t\tedges {\n\t\t\t\t\tnode {\n\t\t\t\t\t\tauthor {\n\t\t\t\t\t\t\tlogin\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbody\n\t\t\t\t\t\tcreatedAt\n\t\t\t\t\t\tcomments(first: 100) {\n\t\t\t\t\t\t\tedges {\n\t\t\t\t\t\t\t\tnode {\n\t\t\t\t\t\t\t\t\tauthor {\n\t\t\t\t\t\t\t\t\t\tlogin\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbody\n\t\t\t\t\t\t\t\t\tcreatedAt\n\t\t\t\t\t\t\t\t\tdiffHunk\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n")
	op.Var("number", number)
	op.Var("owner", owner)
	op.Var("name", name)
	var respData struct {
		Repository *Repository
	}
	err = client.Execute(ctx, op, &respData)
	return respData.Repository, err
}

func MarkAsReady(client *gqlclient.Client, ctx context.Context, input MarkPullRequestReadyForReviewInput) (markPullRequestReadyForReview *MarkPullRequestReadyForReviewPayload, err error) {
	op := gqlclient.NewOperation("mutation markAsReady ($input: MarkPullRequestReadyForReviewInput!) {\n\tmarkPullRequestReadyForReview(input: $input) {\n\t\tpullRequest {\n\t\t\tid\n\t\t}\n\t}\n}\n")
	op.Var("input", input)
	var respData struct {
		MarkPullRequestReadyForReview *MarkPullRequestReadyForReviewPayload
	}
	err = client.Execute(ctx, op, &respData)
	return respData.MarkPullRequestReadyForReview, err
}
